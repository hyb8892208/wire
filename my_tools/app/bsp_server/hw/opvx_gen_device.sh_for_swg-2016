#!/bin/bash

#==========================================================
#功能：根据硬件版本生成STM8,STM32 单片机相应的udev rules文件.
#      并只针对/dev/ttyUSBx,/dev/ttyACMx 设备触发系统默认udev事件，
#      以便系统使用刚刚生成 的udev rules文件为STM8,STM32单片机设备
#      生成符号链接。这样就可以根据通道(STM32)或底板MCU(STM8)，
#      生成固定文件。即此脚本主要功能是生成固定设备名，并完成
#      固定设备名与实现设备之间的映射关系(创建符号链接)。
#
#      固定设备名格式如下：
#      /dev/opvx/
#      ├── chan_brd
#      │   ├── 0 -> ../../ttyACM0
#      │   ├── 1 -> ../../ttyACM1
#      │   ├── 10 -> ../../ttyACM12
#      │   ├── 11 -> ../../ttyACM13
#      │   ├── 12 -> ../../ttyACM14
#      │   ├── 13 -> ../../ttyACM15
#      │   ├── 14 -> ../../ttyACM16
#      │   ├── 15 -> ../../ttyACM5
#      │   ├── 2 -> ../../ttyACM2
#      │   ├── 3 -> ../../ttyACM4
#      │   ├── 4 -> ../../ttyACM6
#      │   ├── 5 -> ../../ttyACM8
#      │   ├── 6 -> ../../ttyACM10
#      │   ├── 7 -> ../../ttyACM3
#      │   ├── 8 -> ../../ttyACM9
#      │   └── 9 -> ../../ttyACM11
#      ├── emu
#      │   ├── 0 -> ../../ttyUSB4
#      │   ├── 1 -> ../../ttyUSB5
#      │   ├── 2 -> ../../ttyUSB6
#      │   └── 3 -> ../../ttyUSB8
#      ├── lcd
#      │   └── 0 -> ../../ttyACM7
#      └── mod_brd
#          ├── 0 -> ../../ttyUSB2
#          └── 1 -> ../../ttyUSB3

#========================================================

#参数 $1 为模块板MUC设备, 从此设备中获取版本信息
MB_MCU_DEV=$1

APP_GET_VER="/my_tools/get_version"
APP_GET_VER_WAIT_TIME_MS=100
UDEV_RULE_FILE="/etc/udev/rules.d/10_opvx.rules"

HW_VER_1="v1.0"
HW_VER_2="V2.0"
HW_VER_TITLE="HW version"

#udev生成的所有设备在/dev/$OPVX_DEV_ROOT目录下
OPVX_DEV_ROOT=opvx

#通道板设备目录/dev/$OPVX_DEV_ROOT/$CHAN_BRD_DIR
CHAN_BRD_DIR=chan_brd

#Debug通道目录/dev/$OPVX_DEV_ROOT/$DEBUG_DIR
DEBUG_DIR=debug

#模块板MCU /dev/$OPVX_DEV_ROOT/$MOD_BOARD_DIR
MOD_BOARD_DIR=mod_brd

#SWG设备lcd 目录 /dev/$OPVX_DEV_ROOT/$MOD_BOARD_DIR
LCD_DIR=lcd

#SWG设备lcd 目录 /dev/$OPVX_DEV_ROOT/$LCD_DIR
LCD_DIR=lcd

#SWG设备lcd 目录 /dev/$OPVX_DEV_ROOT/$EMU_DIR
EMU_DIR=emu

# $1 - 指定生成的udev规则文件 
# $2 - 模块板硬件版本信息 
function generate_udev_rules_title()
{
    RULE_FILE=$1
    HW_VER=$2

    cat > $RULE_FILE << END_INPUT

# Autogenerated by $0 on `date`
# If you edit this file and execute $0 again,
# your manual changes will be LOST.
#
# Openvox hardware udev rules
#
#$HW_VER_TITLE : $HW_VER
#

END_INPUT
}

# $1 - 指定生成的udev规则文件 
# $2 - 模块板硬件版本信息 
function generate_udev_rules_hw_ver_1()
{
    RULE_FILE=$1
    HW_VER=$2
    generate_udev_rules_title $RULE_FILE $HW_VER

    cat > $RULE_FILE << END_INPUT
#Not implement yet !!!
END_INPUT
}

# $1 - 指定生成的udev规则文件 
# $2 - 模块板硬件版本信息 
function generate_udev_rules_hw_ver_2()
{
    RULE_FILE=$1
    HW_VER=$2

    generate_udev_rules_title $RULE_FILE $HW_VER

    cat >> $RULE_FILE << END_INPUT

#Create channel symbol links
DEVPATH=="*devices/pci0000:00/0000:00:1d.0/usb1/1-1/1-1.2/1-1.2.1/1-1.2.1.1/1-1.2.1.1:1.0*", SYMLINK+="$OPVX_DEV_ROOT/$CHAN_BRD_DIR/0" 
DEVPATH=="*devices/pci0000:00/0000:00:1d.0/usb1/1-1/1-1.2/1-1.2.1/1-1.2.1.2/1-1.2.1.2:1.0*", SYMLINK+="$OPVX_DEV_ROOT/$CHAN_BRD_DIR/1"
DEVPATH=="*devices/pci0000:00/0000:00:1d.0/usb1/1-1/1-1.2/1-1.2.1/1-1.2.1.3/1-1.2.1.3:1.0*", SYMLINK+="$OPVX_DEV_ROOT/$CHAN_BRD_DIR/2"
DEVPATH=="*devices/pci0000:00/0000:00:1d.0/usb1/1-1/1-1.2/1-1.2.1/1-1.2.1.4/1-1.2.1.4:1.0*", SYMLINK+="$OPVX_DEV_ROOT/$CHAN_BRD_DIR/3"
DEVPATH=="*devices/pci0000:00/0000:00:1d.0/usb1/1-1/1-1.2/1-1.2.1/1-1.2.1.5/1-1.2.1.5:1.0*", SYMLINK+="$OPVX_DEV_ROOT/$CHAN_BRD_DIR/4"
DEVPATH=="*devices/pci0000:00/0000:00:1d.0/usb1/1-1/1-1.2/1-1.2.1/1-1.2.1.6/1-1.2.1.6:1.0*", SYMLINK+="$OPVX_DEV_ROOT/$CHAN_BRD_DIR/5"
DEVPATH=="*devices/pci0000:00/0000:00:1d.0/usb1/1-1/1-1.2/1-1.2.1/1-1.2.1.7/1-1.2.1.7:1.0*", SYMLINK+="$OPVX_DEV_ROOT/$CHAN_BRD_DIR/6"
DEVPATH=="*devices/pci0000:00/0000:00:1d.0/usb1/1-1/1-1.2/1-1.2.2/1-1.2.2.3/1-1.2.2.3:1.0*", SYMLINK+="$OPVX_DEV_ROOT/$CHAN_BRD_DIR/7"


DEVPATH=="*devices/pci0000:00/0000:00:1d.0/usb1/1-1/1-1.2/1-1.2.5/1-1.2.5.4/1-1.2.5.4.1/1-1.2.5.4.1:1.0*", SYMLINK+="$OPVX_DEV_ROOT/$CHAN_BRD_DIR/8" 
DEVPATH=="*devices/pci0000:00/0000:00:1d.0/usb1/1-1/1-1.2/1-1.2.5/1-1.2.5.4/1-1.2.5.4.2/1-1.2.5.4.2:1.0*", SYMLINK+="$OPVX_DEV_ROOT/$CHAN_BRD_DIR/9"
DEVPATH=="*devices/pci0000:00/0000:00:1d.0/usb1/1-1/1-1.2/1-1.2.5/1-1.2.5.4/1-1.2.5.4.3/1-1.2.5.4.3:1.0*", SYMLINK+="$OPVX_DEV_ROOT/$CHAN_BRD_DIR/10"
DEVPATH=="*devices/pci0000:00/0000:00:1d.0/usb1/1-1/1-1.2/1-1.2.5/1-1.2.5.4/1-1.2.5.4.4/1-1.2.5.4.4:1.0*", SYMLINK+="$OPVX_DEV_ROOT/$CHAN_BRD_DIR/11"
DEVPATH=="*devices/pci0000:00/0000:00:1d.0/usb1/1-1/1-1.2/1-1.2.5/1-1.2.5.4/1-1.2.5.4.5/1-1.2.5.4.5:1.0*", SYMLINK+="$OPVX_DEV_ROOT/$CHAN_BRD_DIR/12"
DEVPATH=="*devices/pci0000:00/0000:00:1d.0/usb1/1-1/1-1.2/1-1.2.5/1-1.2.5.4/1-1.2.5.4.6/1-1.2.5.4.6:1.0*", SYMLINK+="$OPVX_DEV_ROOT/$CHAN_BRD_DIR/13"
DEVPATH=="*devices/pci0000:00/0000:00:1d.0/usb1/1-1/1-1.2/1-1.2.5/1-1.2.5.4/1-1.2.5.4.7/1-1.2.5.4.7:1.0*", SYMLINK+="$OPVX_DEV_ROOT/$CHAN_BRD_DIR/14"
DEVPATH=="*devices/pci0000:00/0000:00:1d.0/usb1/1-1/1-1.2/1-1.2.5/1-1.2.5.3/1-1.2.5.3:1.0*", SYMLINK+="$OPVX_DEV_ROOT/$CHAN_BRD_DIR/15"

#Create LCD symbol link
DEVPATH=="*devices/pci0000:00/0000:00:1d.0/usb1/1-1/1-1.2/1-1.2.4/1-1.2.4.4/1-1.2.4.4:1.0*", SYMLINK+="$OPVX_DEV_ROOT/$LCD_DIR/0"

#Create EMU symbol link
DEVPATH=="*devices/pci0000:00/0000:00:1d.0/usb1/1-1/1-1.2/1-1.2.2/1-1.2.2.5/1-1.2.2.5:1.0*", SYMLINK+="$OPVX_DEV_ROOT/$EMU_DIR/0"
DEVPATH=="*devices/pci0000:00/0000:00:1d.0/usb1/1-1/1-1.2/1-1.2.2/1-1.2.2.7/1-1.2.2.7:1.0*", SYMLINK+="$OPVX_DEV_ROOT/$EMU_DIR/1"
DEVPATH=="*devices/pci0000:00/0000:00:1d.0/usb1/1-1/1-1.2/1-1.2.5/1-1.2.5.5/1-1.2.5.5:1.0*", SYMLINK+="$OPVX_DEV_ROOT/$EMU_DIR/2"
DEVPATH=="*devices/pci0000:00/0000:00:1d.0/usb1/1-1/1-1.2/1-1.2.5/1-1.2.5.7/1-1.2.5.7:1.0*", SYMLINK+="$OPVX_DEV_ROOT/$EMU_DIR/3"

#Create board mcu symbol link
DEVPATH=="*devices/pci0000:00/0000:00:1d.0/usb1/1-1/1-1.2/1-1.2.2/1-1.2.2.2/1-1.2.2.2:1.0*", SYMLINK+="$OPVX_DEV_ROOT/$MOD_BOARD_DIR/0"
DEVPATH=="*devices/pci0000:00/0000:00:1d.0/usb1/1-1/1-1.2/1-1.2.5/1-1.2.5.2/1-1.2.5.2:1.0*", SYMLINK+="$OPVX_DEV_ROOT/$MOD_BOARD_DIR/1"

END_INPUT

}

function generate_udev_rules()
{
    MB_MCU_DEV=$1
    MB_HW_VER=$2

    rule_name=`echo "$MB_MCU_DEV""_""$MB_HW_VER" |tr '/' '_'` #将'/' 替换为 '_'
    tmp_udev_rule=/tmp/"$rule_name".rule

    if [ x"$HW_VER_1" == x"$MB_HW_VER" ]
    then
        generate_udev_rules_hw_ver_1 $tmp_udev_rule $MB_HW_VER

    elif [ x"$HW_VER_2" == x"$MB_HW_VER" ] 
    then
        generate_udev_rules_hw_ver_2 $tmp_udev_rule $MB_HW_VER
    else
        echo "$0 : Unkown hardware version : $MB_HW_VER"
        return
    fi

    ########################################################
    #   当有多个模块板插入系统，而每块模块板生成规则文件
    #   $UDEV_RULE_FILE 需要一段时间，因此系统可能同时执行
    #   此脚本生成$UDEV_RULE_FILE.为防止生成多次以及生成时
    #   不同进程相互覆盖问题，先对每个模块板生成一个udev规则
    #   文件，然后再拷贝为$UDEV_RULE_FILE, 如果已经存在则不
    #   拷贝, 确保只生成一份。
    ########################################################

    #   如果文件 $UDEV_RULE_FILE 已经存在，则不覆盖
    if [ ! -f $UDEV_RULE_FILE ]
    then
        cp -f $tmp_udev_rule $UDEV_RULE_FILE
        #触发udev默认事件，以便生成软链接(SYMLINK)
        sleep 3 #等待之前的触发事件完成，再触发
        #重新加载udev配置文件 
        udevadm control -R 
        #触发 /dev/ttyUSBx /dev/ttyACMx 
        #以便系统根据新生成$UDEV_RULE_FILE的规则生成/dev/opvx/目录
        udevadm trigger --sysname-match=tty[AU]*
    fi
}

#开机后硬件版本便确定，因此只需开机时生成rules文件，
#开机后插拔不用重新生成。

grep "$HW_VER_TITLE" $UDEV_RULE_FILE > /dev/null 2>&1
if [ 0 -eq $? ]
then
    #开机时清空$UDEV_RULE_FILE文件
    #文件已经存在，说明开机后已经生成过此文件，
    #不需要重新生成,只生成一次即可。
    exit;
fi

#获取硬件版本号
#====='APP_GET_VER'输出版本信息格式如下=======
#   SWG1032_BASED
#   HwVer : V2.0
#   SwVer : V2.0
#   Jan  8 2018
#   17:32:28
#=============================================
MB_HW_VER=`$APP_GET_VER $MB_MCU_DEV $APP_GET_VER_WAIT_TIME_MS 2>&1 |\
        grep "HwVer" |\
        awk -F":" '{print $2}' |\
        sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//'` #去掉首尾空格

generate_udev_rules $MB_MCU_DEV $MB_HW_VER 

