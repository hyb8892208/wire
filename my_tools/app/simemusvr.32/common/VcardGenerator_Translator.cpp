// TestSimBox.cpp : Defines the entry point for the console application.
//


#include "Misc.h"
#include "card.h"  
#include "EmuVcard.h"  



#include <iostream>
#include "stdlib.h" 
#include <string.h>
#include <errno.h>
#include <time.h>
#include <termios.h> 



/******************************* 
* For VcardGenerator Test Start
*******************************/

/******************************* 
* For VcardGenerator Test End
*******************************/

rid_inform_t vc_ridset[] ={
	{{0xa0,0,0,0,0x87},RIDTYPE_3GPP },
	{{0xa0,0,0,03,0x43},RIDTYPE_3GPP2 },
	{{0xa0,0,0,0,0x09},RIDTYPE_ETSI }
};  	

/******************************* 
* For VcardGenerator Test Start
*******************************/
//Vcard文件属性表，保存Gsm11.11 中的文件属性
vcard_file_property_t vcard_file_property_list[]={    //只有GSM 空间 和TELECOM 空间下的文件可能重名
	{
	 MF_IDENTIFIER,
	 FILE_TYPE_MF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	//EF --Parent is MF 
	{
	 EFICCID_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	
	{
	 EFELP_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	//DF
	{
	 DFDCS1800_IDENTIFIER,
	 FILE_TYPE_DF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	
	{
	 DFGSM_IDENTIFIER,
	 FILE_TYPE_DF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	//EF --Parent is DFGSM
	{
	 EFLP_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},	
  {
	 PGSM_EFIMSI_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
  },
 {
	 EFKc_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|CAN_FORK,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFPLMNsel_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},	
	{
	 EFHPLMN_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	
 	{
	 EFACMmax_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
 {
	 EFSST_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFACM_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_CYCLIC|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_0_LINEARFIXED_CYCLIC|CAN_FORK,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},	
	
	{
	 EFGID1_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFGID2_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	
	{
	 EFSPN_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFPUCT_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFCBMI_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},		
	{
	 EFBCCH_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|CAN_FORK,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFACC_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},	
	{
	 EFFPLMN_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|CAN_FORK,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFLOCI_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|CAN_FORK,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFAD_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},	
  {
	 EFPhase_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	
	{
	 EFVGCS_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFVGCSS_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFVBS_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFVBSS_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFEmlpp_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFAAeM_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFCBMID_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},	
	{
	 EFECC_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFCBMIR_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFDCK_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFCNL_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFNIA_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},		
	{
	 EFKcGPRS_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|CAN_FORK,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFLOCIGPRS_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|CAN_FORK,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFSUME_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},	
	{
	 EFPLMNwAcT_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},	
	{
	 EFOPLMNwAcT_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 PFGSM_EF_6F11,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	},	
	{
	 PFGSM_EF_6F13,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	},	
	{
	 PFGSM_EF_6F14,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	},	
		{
	 PFGSM_EF_6F15,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	},		
		{
	 PFGSM_EF_6F16,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	},	
		{
	 PFGSM_EF_6F17,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	},	
	{
	 PFGSM_EF_6F18,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	},	
		{
	 PFGSM_EF_6F19,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	},	
		{
	 PFGSM_EF_6F60,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	},	
		{
	 PFGSM_EF_6F61,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	},	
		{
	 PFGSM_EF_6F62,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	},	
		{
	 PFGSM_EF_6FC5,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	},	
		{
	 PFGSM_EF_6FC6,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	},	
		{
	 PFGSM_EF_6FCB,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	},	
		{
	 PFGSM_EF_6FCD,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	},	
	//DF
	{
	 DFTELECOM_IDENTIFIER,
	 FILE_TYPE_DF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	
	},
	


	//EF --Parent is DFTELECOM	
	{
	 EFADN_IDENTIFIER,
   FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,	
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFFDN_IDENTIFIER,
   FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},	
	{
	 EFSMS_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC|STARTBYTE_1_LINEARFIXED_CYCLIC,
	  DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFSMSR_IDENTIFIER,
	// FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|EXIST_SAME_EF_NAME|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC|STARTBYTE_1_LINEARFIXED_CYCLIC,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC|STARTBYTE_1_LINEARFIXED_CYCLIC,
	
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
	{
	 EFCCP_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED,
	  DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFMSISDN_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,
	  DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFSMSP_IDENTIFIER,
   FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,
    DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
		
	{
	 EFSMSS_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|CAN_FORK,
	  DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFLND_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_CYCLIC|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC|CAN_FORK,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFSDN_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,
	  DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},

	{
	 EFEXT1_IDENTIFIER,
   FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|SPARE_MODE_LINEARFIXED_CYCLIC\
   |DEFAULT_FF_LINEARFIXED_CYCLIC|STARTBYTE_1_LINEARFIXED_CYCLIC,
	  DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFEXT2_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|SPARE_MODE_LINEARFIXED_CYCLIC\
	 |DEFAULT_FF_LINEARFIXED_CYCLIC|STARTBYTE_1_LINEARFIXED_CYCLIC,
	  DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFEXT3_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|SPARE_MODE_LINEARFIXED_CYCLIC\
	 |DEFAULT_FF_LINEARFIXED_CYCLIC|STARTBYTE_1_LINEARFIXED_CYCLIC,
	  DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},

	{
	 EFBDN_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED,
	  DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFEXT4_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED,
	  DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	}
	 
	 }; 
//EXIST_SAME_EF_NAME 和EXIST_SAME_DF_NAME 属性的文件标识符需要写全路径grandfather_identifier，great_grandfather_identifier
vcard_file_property_t vcard_file_property_list_Uim[]={
 {
	 MF_IDENTIFIER,
	 FILE_TYPE_MF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	//EF --Parent is MF 
	{
	 EFICCID_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
		
	{
	 EFELP_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
	//DF
	{
	 DFDCS1800_IDENTIFIER,
	 FILE_TYPE_DF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
	
	{
	 DFGSM_IDENTIFIER,
	 FILE_TYPE_DF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
	
	{
	 DFCDMA_IDENTIFIER,
	 FILE_TYPE_DF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
	//wx add B 2018/6/7
		//EF --Parent is DFGSM
	{
	 EFLP_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},	
  {
	 PGSM_EFIMSI_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
  },
 {
	 EFKc_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|CAN_FORK,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFPLMNsel_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},	
	{
	 EFHPLMN_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	
 	{
	 EFACMmax_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
 {
	 EFSST_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFACM_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_CYCLIC|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_0_LINEARFIXED_CYCLIC|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},	
	
	{
	 EFGID1_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFGID2_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	
	{
	 EFSPN_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFPUCT_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFCBMI_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},		
	{
	 EFBCCH_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFACC_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},	
	{
	 EFFPLMN_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|CAN_FORK,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFLOCI_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME|CAN_FORK,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFAD_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},	
  {
	 EFPhase_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	
	{
	 EFVGCS_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFVGCSS_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFVBS_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFVBSS_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFEmlpp_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFAAeM_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFCBMID_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},	
	{
	 EFECC_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFCBMIR_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFDCK_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFCNL_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFNIA_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},		
	{
	 EFKcGPRS_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|CAN_FORK,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFLOCIGPRS_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME|CAN_FORK,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFSUME_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	  MF_IDENTIFIER,
	 MF_IDENTIFIER
	},	
	{
	 EFPLMNwAcT_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},	
	{
	 EFOPLMNwAcT_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 PFGSM_EF_6F11,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	},	
	{
	 PFGSM_EF_6F13,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	},	
	{
	 PFGSM_EF_6F14,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	},
	{
	 PFGSM_EF_6F15,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	},
	{
	 PFGSM_EF_6F16,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	},
	{
	 PFGSM_EF_6F17,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	},
	{
	 PFGSM_EF_6F18,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	},		
		{
	 PFGSM_EF_6F19,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	},	
	//wx add E 2018/6/7
	
	//EF --Parent is DFCDMA
	{
	 EFCOUNT_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_MANDATORY|EF_STRUCTURE_CYCLIC|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_0_LINEARFIXED_CYCLIC,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	
  {
	 EFIMSI_M_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
  },
 {
	 EFIMSI_T_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
	{
	 EFTMSI_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	
	{
	 EFAH_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
 	{
	 EFAOP_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_CYCLIC,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	
	
  {
	 EFALOC_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
  },
 {
	 EFCDMAHOME_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_LINEARFIXED|DEFAULT_0_LINEARFIXED_CYCLIC|SPARE_MODE_LINEARFIXED_CYCLIC,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
	{
	 EFZNREGI_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_MANDATORY|EF_STRUCTURE_LINEARFIXED|DEFAULT_0_LINEARFIXED_CYCLIC|SPARE_MODE_LINEARFIXED_CYCLIC,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	
	{
	 EFSNREGI_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
		{
	 EFDISTREGI_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	
	{
	 EFACCOLC_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
	
{
	 EFTERM_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	
	{
	 EFSSCI_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
 	{
	 EFACP_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	
	
  {
	 EFPRL_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|LONG_TRANSPARENT_EF_CUT_TAIL_DEFAULT_0|EXIST_SAME_EF_NAME,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
  },
 {
	 EFRUIMID_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
	{
	 EFCST_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	
	{
	 EFTSPC_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
		{
	 EFOTAPASPC_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	
	{
	 EFNAMLOCK_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	
		{
	 EFOTA_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
		{
	 EFSP_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	
	{
	 EFESNME_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	
	{
	 EFREVISION_CDMA,
	// FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 //20200339 EFREVISION_CDMA 有些card 没有MANDATORY
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
	
		{
	 EFPL_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	

	{
	 EFSMS_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|EXIST_SAME_EF_NAME|STARTBYTE_2_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC|SPARE_MODE_LINEARFIXED_CYCLIC,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	
		{
	 EFSMSP_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED\
	 |SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC|EXIST_SAME_EF_NAME,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
		{
	 EFSMSS_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME|CAN_FORK,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	
	{
	 EFESSFC_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
	
{
	 EFSPN_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	
		{
	 EFUSGINDN_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
		{
	 EFAD_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	
	{
	 EFMDN_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|EXIST_SAME_EF_NAME,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},		

	{
	 EFMAXPRL_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
		{
	 EFSPCS_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	
	{
	 EFECC_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	
		{
	 EFME3GPDOPC_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME|CAN_FORK,
	 //FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	
		
	{
	 EF3GPDOPM_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
		{
	 EFSIPCAP_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	
	{
	 EFMIPCAP_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},		

	{
	 EFSIPUPP_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
		{
	 EFMIPUPP_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	
	{
	 EFSIPSP_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	
		{
	 EFMIPSP_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},		

	{
	 EFSIPPAPSS_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	
	{
	 EFPUZL_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
	
{
	 EMAXPUZL_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	
		{
	 EFMECRP_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
		{
	 EFHRPDCAP_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	

	{
	 EFHRPDUPP_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},		

	{
	 EFCSSPR_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
		{
	 EFATC_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	
	{
	 EFEPRL_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|LONG_TRANSPARENT_EF_CUT_TAIL_DEFAULT_0,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	
		{
	 EFBCSMSCFG_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	
		
	{
	 EFBCSMSPREF_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
		{
	 EFBCSMSTABLE_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	
		{
	 EFBCSMSP_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
		{
	 EFIMPI_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	
	

{
	 EFDOMAIN_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	
	{
	 EFIMPU_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|EXIST_SAME_EF_NAME,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	
		{
	 EFPCSCF_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
	
	{
	 EFBAKPARA_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	
		
	{
	 EFUpBAKPARA_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_CYCLIC,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},			
		{
	 EFMMSN_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},		
		{
	 EFEXT8_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	



{
	 EFMMSICP_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	
	{
	 EFMMSUP_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	
		{
	 EFMMSUCP_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
	
	{
	 EFAUTHCAPABILITY_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	
  	
	{
	 EF3GCIK_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},			
		{
	 EFDCK_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},		
		{
	 EFGID1_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	
	
	{
	 EFGID2_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},			
		{
	 EFCDMACNL_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},		
		{
	 EFHOME_TAG_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	
		
	{
	 EFGROUP_TAG_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},			
		{
	 EFSPECIFIC_TAG_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},		
		
	{
	 EFCALL_PROMPT_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	
	
	{
	 EFSF_EUIMID_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
  
  {
	 EFEST_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
	{
	 EFICI_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_CYCLIC,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
	{
	 EFEXT2_CDMA, // 发现EF结构和标准不符
	// FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED,
  	FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
  {
	 EFOCI_CDMA,  // 发现EF结构和标准不符
	// FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_CYCLIC|EF_READ_HEADER_ONLY,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
	{
	 EFCCP2_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
	{
	 EFHIDDENKEY_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
	{
	 EFEXT5_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC|EXIST_SAME_EF_NAME,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
	{
	 EFFDN_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
	{
	 EF_6F85_CDMA,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
	{
	 EF_6F86_CDMA,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 DFCDMA_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
	//DF
	{
	 DFTELECOM_IDENTIFIER,
	 FILE_TYPE_DF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
	


	//EF --Parent is DFTELECOM	
	 {
	 PTELECOM_DF5F3C,
   FILE_TYPE_DF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl,	
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 PPTELECOM_PDF5F3C_4F20,
   FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,	
	 PTELECOM_DF5F3C,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 PPTELECOM_PDF5F3C_4F21,
   FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,	
	 PTELECOM_DF5F3C,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFADN_IDENTIFIER,
   FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC|EXIST_SAME_EF_NAME,	
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
	{
	 EFFDN_IDENTIFIER,
   FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},	
	{
	 EFSMS_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC\
	 |STARTBYTE_1_LINEARFIXED_CYCLIC|EXIST_SAME_EF_NAME,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
	{
	 EFCCP_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|EXIST_SAME_EF_NAME,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
	
	{
	 EFMSISDN_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
	{
	 EFSMSP_IDENTIFIER,
   FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|SPARE_MODE_LINEARFIXED_CYCLIC\
   |DEFAULT_FF_LINEARFIXED_CYCLIC|EXIST_SAME_EF_NAME,
   DFTELECOM_IDENTIFIER,
   MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
		
	{
	 EFSMSS_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME|CAN_FORK,
	 DFTELECOM_IDENTIFIER,
	},
	{
	 EFLND_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_CYCLIC|EXIST_SAME_EF_NAME|CAN_FORK,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
	{
	 EFSDN_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|SPARE_MODE_LINEARFIXED_CYCLIC\
	 |DEFAULT_FF_LINEARFIXED_CYCLIC|EXIST_SAME_EF_NAME,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},

	{
	 EFEXT1_IDENTIFIER,
   FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|SPARE_MODE_LINEARFIXED_CYCLIC\
   |DEFAULT_FF_LINEARFIXED_CYCLIC|EXIST_SAME_EF_NAME|STARTBYTE_1_LINEARFIXED_CYCLIC,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
	{
	 EFEXT2_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|SPARE_MODE_LINEARFIXED_CYCLIC\
	 |DEFAULT_FF_LINEARFIXED_CYCLIC|EXIST_SAME_EF_NAME|STARTBYTE_1_LINEARFIXED_CYCLIC,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
	{
	 EFEXT3_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|SPARE_MODE_LINEARFIXED_CYCLIC\
	 |DEFAULT_FF_LINEARFIXED_CYCLIC|EXIST_SAME_EF_NAME,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},

	{
	 EFBDN_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|EXIST_SAME_EF_NAME,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
	
	{
	 EFEXT4_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|EXIST_SAME_EF_NAME,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
	{
	 EFSMSR_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|EXIST_SAME_EF_NAME|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC|STARTBYTE_1_LINEARFIXED_CYCLIC,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	},
	
 
 
  {
	 PDFPHONEBOOK_EFGAS_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,
	 PTELECOM_DFPHONEBOOK_IDENTIFIER,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER
	},	
	{
	 PPTELECOM_PDFPHONEBOOK_EFPSC_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 PTELECOM_DFPHONEBOOK_IDENTIFIER,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER
	}, 
	{
	 PPTELECOM_PDFPHONEBOOK_EFEMAIL_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,
	 PTELECOM_DFPHONEBOOK_IDENTIFIER,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER
	}, 
	
	{
	 PPTELECOM_PDFPHONEBOOK_EFGRP_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_0_LINEARFIXED_CYCLIC,
	 PTELECOM_DFPHONEBOOK_IDENTIFIER,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER
	}, 
	{
	 PPTELECOM_PDFPHONEBOOK_EFAAS_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,
	 PTELECOM_DFPHONEBOOK_IDENTIFIER,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER
	}, 
	{
	 PPTELECOM_PDFPHONEBOOK_EFPBC_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_0_LINEARFIXED_CYCLIC,
	 PTELECOM_DFPHONEBOOK_IDENTIFIER,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 PTELECOM_EFARR_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_LINEARFIXED|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER
	}
	
	 
	 };

	 
//Vcard文件属性表，保存TS31.102 中的文件属性  
//3GPP2 CDMA  中的SFI 参考C.S0065-0_v2.0
vcard_file_property_t vcard_file_property_list_Usim[]={ 
	{
	 MF_IDENTIFIER,
	 FILE_TYPE_MF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	 
	},
	//EF --Parent is MF 
	{
	 EFICCID_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 2
	},
	
	{
	 EFELP_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 5
	},
	//wx Add B   TS102.221 Annex H SFI at MF Level
	{
	 EFDIR_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_LINEARFIXED|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0x1e
	},
	
	{
	 PMF_EFARR_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 6
	},
	//wx Add E
	//DF
	{
	 DFDCS1800_IDENTIFIER,
	 FILE_TYPE_DF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	
	{
	 DFGSM_IDENTIFIER,
	 FILE_TYPE_DF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	
	//EF --Parent is DFGSM
	{
	 EFLP_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
   DFGSM_IDENTIFIER,
   MF_IDENTIFIER,
	 MF_IDENTIFIER
	 
	},	
	{
	 PFGSM_EF_6F11,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	},	
	{
	 PFGSM_EF_6F13,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	},	
	{
	 PFGSM_EF_6F14,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	},
	{
	 PFGSM_EF_6F15,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	},
	{
	 PFGSM_EF_6F16,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	},
	{
	 PFGSM_EF_6F17,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	},
	{
	 PFGSM_EF_6F18,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	},		
		{
	 PFGSM_EF_6F19,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	},	
  {
	 PGSM_EFIMSI_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	 
  },
 {
	 EFKc_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFPLMNsel_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},	
	{
	 EFHPLMN_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	
 	{
	 EFACMmax_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
 {
	 EFSST_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFACM_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_CYCLIC|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_0_LINEARFIXED_CYCLIC|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},	
	
	{
	 EFGID1_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFGID2_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	
	{
	 EFSPN_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFPUCT_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFCBMI_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},		
	{
	 EFBCCH_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFACC_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},	
	{
	 EFFPLMN_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFLOCI_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME|CAN_FORK,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFAD_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},	
  {
	 EFPhase_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	
	{
	 EFVGCS_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFVGCSS_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFVBS_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFVBSS_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFEmlpp_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFAAeM_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFCBMID_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},	
	{
	 EFECC_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFCBMIR_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFDCK_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFCNL_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFNIA_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},		
	{
	 EFKcGPRS_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFLOCIGPRS_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|CAN_FORK,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFSUME_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},	
			
	{
	 EFPLMNwAcT_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
		
	{
	 EFOPLMNwAcT_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 DFGSM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},	
	//DF
	{
	 DFTELECOM_IDENTIFIER,
	 FILE_TYPE_DF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	 //DF --Parent is DFTELECOM	
	{
	 PTELECOMDF_DFGRAPHICS_IDENTIFIER,
   FILE_TYPE_DF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EXIST_SAME_DF_NAME,	
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},

  {
	 PTELECOM_DFPHONEBOOK_IDENTIFIER,
   FILE_TYPE_DF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EXIST_SAME_DF_NAME,	
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	 {
	 PTELECOM_DF5F3C,
   FILE_TYPE_DF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EXIST_SAME_DF_NAME,	
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	
	{
	 PPTELECOM_PDF5F3C_4F21,
   FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,	
	 PTELECOM_DF5F3C,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 PPTELECOM_PDF5F3C_4F20,
   FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,	
	 PTELECOM_DF5F3C,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER
	},
	//EF --Parent is DFTELECOM	
	{
	 EFADN_IDENTIFIER,
   FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,	
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFFDN_IDENTIFIER,
   FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|SPARE_MODE_LINEARFIXED_CYCLIC\
   |DEFAULT_FF_LINEARFIXED_CYCLIC|EXIST_SAME_EF_NAME,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},	
	{
	 EFSMS_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|SPARE_MODE_LINEARFIXED_CYCLIC\
	 |DEFAULT_FF_LINEARFIXED_CYCLIC|STARTBYTE_1_LINEARFIXED_CYCLIC|EXIST_SAME_EF_NAME,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFCCP_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFMSISDN_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|SPARE_MODE_LINEARFIXED_CYCLIC\
	 |DEFAULT_FF_LINEARFIXED_CYCLIC|EXIST_SAME_EF_NAME,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFSMSP_IDENTIFIER,
   FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED\
   |SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC|EXIST_SAME_EF_NAME,
   DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
		
	{
	 EFSMSS_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME|CAN_FORK,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFLND_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_CYCLIC|EXIST_SAME_EF_NAME|CAN_FORK,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFSDN_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED\
	 |SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC|EXIST_SAME_EF_NAME,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},

	{
	 EFEXT1_IDENTIFIER,
   FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED\
   |SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC|EXIST_SAME_EF_NAME,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFEXT2_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED\
	 |SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC|EXIST_SAME_EF_NAME,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFEXT3_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED\
	 |SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC|EXIST_SAME_EF_NAME,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},

	{
	 EFBDN_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|EXIST_SAME_EF_NAME,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 EFEXT4_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|EXIST_SAME_EF_NAME,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	
		{
	 PTELECOM_EFARR_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_LINEARFIXED|EXIST_SAME_EF_NAME|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
		{
	 EFSMSR_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|EXIST_SAME_EF_NAME|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC|STARTBYTE_1_LINEARFIXED_CYCLIC,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
 // EF 	PARENT is PTELECOM_DFPHONEBOOK_IDENTIFIER
	{
	 PPTELECOM_PDFPHONEBOOK_EFADN_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|EXIST_SAME_EF_NAME|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,
	 PTELECOM_DFPHONEBOOK_IDENTIFIER,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	 1
	},
	 
	{
	 PPTELECOM_PDFPHONEBOOK_EFADN1_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|EXIST_SAME_EF_NAME|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,
	 PTELECOM_DFPHONEBOOK_IDENTIFIER,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER
	},
	 
	{
	 PDFPHONEBOOK_EFGAS_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,
	 PTELECOM_DFPHONEBOOK_IDENTIFIER,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 PPTELECOM_PDFPHONEBOOK_EFPSC_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 PTELECOM_DFPHONEBOOK_IDENTIFIER,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 PPTELECOM_PDFPHONEBOOK_EFEMAIL_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,
	 PTELECOM_DFPHONEBOOK_IDENTIFIER,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER
	}, 
	{
	 PPTELECOM_PDFPHONEBOOK_EFGRP_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_0_LINEARFIXED_CYCLIC,
	 PTELECOM_DFPHONEBOOK_IDENTIFIER,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER
	}, 
	{
	 PPTELECOM_PDFPHONEBOOK_EFAAS_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,
	 PTELECOM_DFPHONEBOOK_IDENTIFIER,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER
	}, 
	{
	 PPTELECOM_PDFPHONEBOOK_EFPBC_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_0_LINEARFIXED_CYCLIC,
	 PTELECOM_DFPHONEBOOK_IDENTIFIER,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER
	},
		//wx Add B
// SFI at USIM ADF Level TS31.102 Annex H  不同目录下的SFI可以相同
	{
	 USIMADF_IDENTIFIER,
	 FILE_TYPE_DF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|FILE_ACESS_AID_ONLY,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0,
	 RIDTYPE_3GPP
	},

  
	{
	 PADF_EFLI_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0x02 ,
	 RIDTYPE_3GPP
	},
  
  {
	 PADF_EFARR_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_EF_NAME|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0x17 ,
	 RIDTYPE_3GPP
	},
	
  {
	 PADF_EFIMSI_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0x7 ,
	 RIDTYPE_3GPP
	},		
  
  {
	 PADF_EFKeys_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|CAN_FORK,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0x8 ,
	 RIDTYPE_3GPP
	},			
  
  {
	 PADF_EFKEYPS_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|CAN_FORK,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0x9 ,
	 RIDTYPE_3GPP
	},	
	
	{
	 PADF_EFDCK_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER  ,
	  0,
	 RIDTYPE_3GPP
	},

 
  {
	 PADF_EFHPPLMN_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0x12 ,
	 RIDTYPE_3GPP
	},	
	//201807/05
	{
	 PADF_EFCNL_IDENTIFIER,
//	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_EF_NAME,
	 //20300330
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},

  {
	 PADF_EFACMmax_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},	
	
	{
	 PADF_EFUST_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 4 ,
	 RIDTYPE_3GPP
	},
	{
	 PADF_EFACM_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_CYCLIC|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_EF_NAME|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_0_LINEARFIXED_CYCLIC,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0x1c,
	 RIDTYPE_3GPP
	},	
	
	{
	 PADF_EFFDN_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|\
	 EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_EF_NAME|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	{
	 PADF_EFSMS_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS\
	 |SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC|STARTBYTE_1_LINEARFIXED_CYCLIC|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	{
	 PADF_EFGID1_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},	
	
	{
	 PADF_EFGID2_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
  
  {
	 PADF_EFMSISDN_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS\
	 |SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	{
	 PADF_EFPUCT_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},	
	
	{
	 PADF_EFSMSP_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS\
	 |SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},

  {   //ds
	 PADF_EFSMSS_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_EF_NAME|CAN_FORK,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	{
	 PADF_EFCBMI_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},	
	
	{
	 PADF_EFSPN_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	
	
  {
	 PADF_EFSMSR_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_EF_NAME|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC|STARTBYTE_1_LINEARFIXED_CYCLIC,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	{
	 PADF_EFCBMID_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0xe,
	 RIDTYPE_3GPP
	},	
	
	{
	 PADF_EFSDN_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS\
	  |SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	 {
	 PADF_EFEXT2_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS\
	  |SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC|EXIST_SAME_EF_NAME|STARTBYTE_1_LINEARFIXED_CYCLIC,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	{
	 PADF_EFEXT3_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS\
	 |SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC|EXIST_SAME_EF_NAME||STARTBYTE_1_LINEARFIXED_CYCLIC,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},	
	
	{
	 PADF_EFBDN_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	
		{
	 PADF_EFEXT5_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_EF_NAME\
	 |SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC|EXIST_SAME_EF_NAME|STARTBYTE_1_LINEARFIXED_CYCLIC,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	 {
	 PADF_EFCCP2_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0x16,
	 RIDTYPE_3GPP
	},
	{
	 PADF_EFCBMIR_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},	
	
	{
	 PADF_EFEXT4_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	
		{
	 PADF_EFEST_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 5,
	 RIDTYPE_3GPP
	},
	 {
	 PADF_EFACL_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	{
	 PADF_EFCMI_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	 
	},	
	
	{
	 PADF_EFSTART_HFN_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|CAN_FORK,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0xf,
	 RIDTYPE_3GPP
	},
	
		{
	 PADF_EFTHRESHOLD_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0x10,
	 RIDTYPE_3GPP
	},
	 {
	 PADF_EFPLMNwAcT_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0xa,
	 RIDTYPE_3GPP
	},
	{
	 PADF_EFOPLMNwAcT_IDENTIFIER,
	// FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_EF_NAME,
	//20200330
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0x11,
	 RIDTYPE_3GPP
	},	
	
	{
	 PADF_EFHPLMNwAcT_IDENTIFIER,
	// FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 //20200330
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0x13,
	 RIDTYPE_3GPP
	},
	
		{
	 PADF_EFPSLOCI_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|CAN_FORK,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0xc,
	 RIDTYPE_3GPP
	},
	 {
	 PADF_EFACC_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0x6,
	 RIDTYPE_3GPP
	},
	{
	 PADF_EFFPLMN_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_EF_NAME|CAN_FORK,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0xd,
	 RIDTYPE_3GPP
	},	
	
	{
	 PADF_EFLOCI_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_EF_NAME|CAN_FORK,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0xb,
	 RIDTYPE_3GPP
	},
	
	{
	 PADF_EFICI_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_CYCLIC|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0x14,
	 RIDTYPE_3GPP
	},
	 {
	 PADF_EFOCI_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_CYCLIC|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|DEFAULT_FF_LINEARFIXED_CYCLIC|SPARE_MODE_LINEARFIXED_CYCLIC,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0x15,
	 RIDTYPE_3GPP
	},
	{
	 PADF_EFICT_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_CYCLIC|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 RIDTYPE_3GPP
	},	
	
	{
	 PADF_EFOCT_IDENTIFIER,
	  FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_CYCLIC|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 RIDTYPE_3GPP
	},
	
	{
	 PADF_EFAD_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0x3,
	 RIDTYPE_3GPP
	},
	 {
	 PADF_EFVGCS_IDENTIFIER,
	FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	{
	 PADF_EFVGCSS_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},	
	
	{
	 PADF_EFVBS_IDENTIFIER,
	  FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},

	{
	 PADF_EFVBSS_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	 {
	 PADF_EFeMLPP_IDENTIFIER,
	FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER
	},
	{
	 PADF_EFAAeM_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},	
	
	{
	  // 与GSM空间下的同名文件属性不同EF_STRUCTURE_LINEARFIXED
	 PADF_EFEFECC_IDENTIFIER,
	  FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_LINEARFIXED|\
	  FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_EF_NAME|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 1,
	 RIDTYPE_3GPP
	},
	
	{
	 PADF_EFHiddenkey_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	 {
	 PADF_EFNETPAR_IDENTIFIER,
	FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|CAN_FORK,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	{
	 PADF_EFPNN_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS\
	 |SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0x19,
	 RIDTYPE_3GPP
	},	
	
	{
	 PADF_EFOPL_IDENTIFIER,
	  FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS\
	  |SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0x1a,
	 RIDTYPE_3GPP
	},
	
		{
	 PADF_EFMBDN_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	 {
	 PADF_EFEXT6_IDENTIFIER,
	FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	{
	 PADF_EFMBI_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},	
	
	{
	 PADF_EFMWIS_IDENTIFIER,
	  FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	
			{
	 PADF_EFCFIS_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	 {
	 PADF_EFEXT7_IDENTIFIER,
	FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	{
	 PADF_EFSPDI_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0x1b,
	 RIDTYPE_3GPP
	},	
	
	{
	 PADF_EFMMSN_IDENTIFIER,
	  FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	
			{
	 PADF_EFEXT8_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	 {
	 PADF_EFMMSICP_IDENTIFIER,
	FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	{
	 PADF_EFMMSUP_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},	
	
	{
	 PADF_EFMMSUCP_IDENTIFIER,
	  FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
			{
	 PADF_EFNIA_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	 {
	 PADF_EFVGCSCA_IDENTIFIER,
	FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	{
	 PADF_EFVBSCA_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},	
	
	{
	 PADF_EFGBAP_IDENTIFIER,
	  FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
			{
	 PADF_EFMSK_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	 {
	 PADF_EFMUK_IDENTIFIER,
	FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	{
	 PADF_EFEHPLMN_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0x1d,
	 RIDTYPE_3GPP
	},	
	
	{
	 PADF_EFGBANL_IDENTIFIER,
	  FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
			{
	 PADF_EFEHPLMNPI_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	 {
	 PADF_EFLRPLMNSI_IDENTIFIER,
	FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	{
	 PADF_EFNAFKCA_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},	
	
	{
	 PADF_EFSPNI_IDENTIFIER,
	  FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	
				{
	 PADF_EFPNNI_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	 {
	 PADF_EFNCP_IP_IDENTIFIER,
	FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	{
	 PADF_EFEPSLOCI_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|CAN_FORK,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0x1e,
	 RIDTYPE_3GPP
	},	
	
	{
	 PADF_EFEPSNSC_IDENTIFIER,
	  FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC|CAN_FORK,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0x18,
	 RIDTYPE_3GPP
	},
	
  //DFPHONEBOOK
  {
	 PADF_DFPHONEBOOK_IDENTIFIER,
	// FILE_TYPE_DF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_DF_NAME,
	 FILE_TYPE_DF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_DF_NAME, //20200330 处理Invaild card 
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	
	 {
	 PDFPHONEBOOK_EFPSC_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 PADF_DFPHONEBOOK_IDENTIFIER,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	
				{
	 PDFPHONEBOOK_EFPBR_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_DF_NAME,
	 PADF_DFPHONEBOOK_IDENTIFIER,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
		//文件，父目录都重名， 但在TELEPHONE 空间
					{
	 PDFPHONEBOOK_EFPBR_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|EXIST_SAME_DF_NAME,
	 PTELECOM_DFPHONEBOOK_IDENTIFIER,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER
	 
	},
	
	 {
	 PDFPHONEBOOK_EFCC_IDENTIFIER,
	FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_DF_NAME,
	 PADF_DFPHONEBOOK_IDENTIFIER,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	
	{
	 PADF_6F14,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
		{
	 PADF_6F15,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
		{
	 PADF_6F16,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	{
	 PADF_6F17,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	{
	 PADF_6F18,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	{
	 PADF_6F65,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	
	
	//文件，父目录都重名， 但在TELEPHONE 空间
	{
	 PDFPHONEBOOK_EFCC_IDENTIFIER,
	FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_DF_NAME,
	 PTELECOM_DFPHONEBOOK_IDENTIFIER,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,	 
	},
	
	{
	 PPTELECOM_PDFPHONEBOOK_4F31,
	FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_UNKOWN_LINEARFIXED_CYCLIC,
	 PTELECOM_DFPHONEBOOK_IDENTIFIER,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,	 
	},
	{
	 PPTELECOM_PDFPHONEBOOK_4F41,
	FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_0_LINEARFIXED_CYCLIC,
	 PTELECOM_DFPHONEBOOK_IDENTIFIER,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,	 
	},
	{
	 PPTELECOM_PDFPHONEBOOK_4F51,
	FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_0_LINEARFIXED_CYCLIC,
	 PTELECOM_DFPHONEBOOK_IDENTIFIER,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,	 
	},
	{
	 PPTELECOM_PDFPHONEBOOK_4F52,
	FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_0_LINEARFIXED_CYCLIC,
	 PTELECOM_DFPHONEBOOK_IDENTIFIER,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,	 
	},
	{
	 PPTELECOM_PDFPHONEBOOK_4F5A,
	FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,
	 PTELECOM_DFPHONEBOOK_IDENTIFIER,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,	 
	},
	{
	 PPTELECOM_PDFPHONEBOOK_4F61,
	FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_0_LINEARFIXED_CYCLIC,
	 PTELECOM_DFPHONEBOOK_IDENTIFIER,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,	 
	},
	{
	 PPTELECOM_PDFPHONEBOOK_4F72,
	FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,
	 PTELECOM_DFPHONEBOOK_IDENTIFIER,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,	 
	},	
	
	
	{
	 PPTELECOM_PDFPHONEBOOK_EFANRA_IDENTIFIER,
	FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,
	 PTELECOM_DFPHONEBOOK_IDENTIFIER,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,	 
	},	
	
	{
	 PPTELECOM_PDFPHONEBOOK_EFGRP1_IDENTIFIER,
	FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_0_LINEARFIXED_CYCLIC,
	 PTELECOM_DFPHONEBOOK_IDENTIFIER,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,	 
	},
	{
	 PPTELECOM_PDFPHONEBOOK_EFANRB_IDENTIFIER,
	FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,
	 PTELECOM_DFPHONEBOOK_IDENTIFIER,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,	 
	},	
	{
	 PPTELECOM_PDFPHONEBOOK_4F34,
	FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,
	 PTELECOM_DFPHONEBOOK_IDENTIFIER,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,	 
	},
	{
	 PPTELECOM_PDFPHONEBOOK_4F33,
	FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,
	 PTELECOM_DFPHONEBOOK_IDENTIFIER,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,	 
	},
	{
	 PPTELECOM_PDFPHONEBOOK_4F39,
	FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,
	 PTELECOM_DFPHONEBOOK_IDENTIFIER,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,	 
	},
	{
	 PPTELECOM_PDFPHONEBOOK_EFPBC1_IDENTIFIER,
	FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_0_LINEARFIXED_CYCLIC,
	 PTELECOM_DFPHONEBOOK_IDENTIFIER,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,	 
	},
	
	{
	 PDFPHONEBOOK_EFUID1_IDENTIFIER,
	FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 PTELECOM_DFPHONEBOOK_IDENTIFIER,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,	 
	},	
		
	{
	 PPTELECOM_PDFPHONEBOOK_4F32,
	FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_UNKOWN_LINEARFIXED_CYCLIC,
	 PTELECOM_DFPHONEBOOK_IDENTIFIER,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,	 
	},	
	
	{
	 PPTELECOM_PDFPHONEBOOK_4F42,
	FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_0_LINEARFIXED_CYCLIC,
	 PTELECOM_DFPHONEBOOK_IDENTIFIER,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,	 
	},
	{
	 PPTELECOM_PDFPHONEBOOK_4F62,
	FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_0_LINEARFIXED_CYCLIC,
	 PTELECOM_DFPHONEBOOK_IDENTIFIER,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,	 
	},
	{
	 PPTELECOM_PDFPHONEBOOK_4F71,
	FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,
	 PTELECOM_DFPHONEBOOK_IDENTIFIER,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,	 
	},
	{
	 PPTELECOM_PDFPHONEBOOK_4F5B,
	FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,
	 PTELECOM_DFPHONEBOOK_IDENTIFIER,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,	 
	},	
	
	{
	 PDFPHONEBOOK_EFPUID_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 PADF_DFPHONEBOOK_IDENTIFIER,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	//文件，父目录都重名， 但在TELEPHONE 空间	
	{
	 PDFPHONEBOOK_EFPUID_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 PTELECOM_DFPHONEBOOK_IDENTIFIER,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER,
	},	
	
	{
	 PDFPHONEBOOK_EFUID_IDENTIFIER,
	  FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 PADF_DFPHONEBOOK_IDENTIFIER,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	
	//DFGSM_ACCESS
	{
	 PADF_DFGSM_ACCESS_IDENTIFIER,
	// FILE_TYPE_DF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	//20200330
	 FILE_TYPE_DF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 USIMADF_IDENTIFIER,
	  MF_IDENTIFIER,
	   MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	{
	 PDFGSM_ACCESS_EFKc_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_DF_NAME|CAN_FORK,
	 PADF_DFGSM_ACCESS_IDENTIFIER,
	 USIMADF_IDENTIFIER,
	  MF_IDENTIFIER,
	  1,
	 RIDTYPE_3GPP
	 
	},
	
		 {
	 PDFGSM_ACCESS_EFKcGPRS_IDENTIFIER,
	FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|CAN_FORK,
	 PADF_DFGSM_ACCESS_IDENTIFIER,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0x2,
	 RIDTYPE_3GPP
	},
	{
	 PDFGSM_ACCESS_EFCPBCCH_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 PADF_DFGSM_ACCESS_IDENTIFIER,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},	
	
	{
	 PDFGSM_ACCESS_EFinvSCAN_IDENTIFIER,
	  FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 PADF_DFGSM_ACCESS_IDENTIFIER,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	
	//DFMExE
	{
	 PADF_DFMExE_IDENTIFIER,
	// FILE_TYPE_DF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	//20200330
	 FILE_TYPE_DF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	{
	 PDFDFMExE_EFMExE_ST_IDENTIFIER,
	  FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 PADF_DFMExE_IDENTIFIER,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	
	{
	 PDFDFMExE_EFORPK_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_DF_NAME,
	 PADF_DFMExE_IDENTIFIER,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	{
	 PDFDFMExE_EFARPK_IDENTIFIER,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_DF_NAME,
	 PADF_DFMExE_IDENTIFIER,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	{
	 PDFDFMExE_EFTPRK_IDENTIFIER,
	  FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_DF_NAME,
	 PADF_DFMExE_IDENTIFIER,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	//DFSoLSA
	{
	 PADF_DFSoLSA_IDENTIFIER,
	// FILE_TYPE_DF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	//20200330
	 FILE_TYPE_DF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	{
	 PDFDFSoLSA_EFSLL_IDENTIFIER,
	  FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 PADF_DFSoLSA_IDENTIFIER,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	
	{
	 PDFDFSoLSA_EFSAI_IDENTIFIER,
	  FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_DF_NAME,
	 PADF_DFSoLSA_IDENTIFIER,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	//DFWLAN
	{
	 PADF_DFWLAN_IDENTIFIER,
	 //FILE_TYPE_DF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 //20200330
	 FILE_TYPE_DF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	{
	 PDFDFWLAN_EFUWSIDL_IDENTIFIER,
	  FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 PADF_DFWLAN_IDENTIFIER,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 4,
	 RIDTYPE_3GPP
	},
	
	{
	 PDFDFWLAN_EFPseudo_IDENTIFIER,
	  FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_DF_NAME,
	  PADF_DFWLAN_IDENTIFIER,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 1,
	 RIDTYPE_3GPP
	},
	
	{
	 PDFDFWLAN_EFUPLMNWLAN_IDENTIFIER,
	  FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_DF_NAME,
	 PADF_DFWLAN_IDENTIFIER,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 2,
	 RIDTYPE_3GPP
	},
	
	{
	 PDFDFWLAN_EF0PLMNWLAN_IDENTIFIER,
	  FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_DF_NAME,
	 PADF_DFWLAN_IDENTIFIER,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 3,
	 RIDTYPE_3GPP
	},
	
	{
	 PDFDFWLAN_EFOWSIDL_IDENTIFIER,
	  FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 PADF_DFWLAN_IDENTIFIER,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 5,
	 RIDTYPE_3GPP
	},

	{
	 PDFDFWLAN_EFWRI_IDENTIFIER,
	  FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 PADF_DFWLAN_IDENTIFIER,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 6,
	 RIDTYPE_3GPP
	},
	{
	 PDFDFWLAN_EFHWSIDL_IDENTIFIER,
	  FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 PADF_DFWLAN_IDENTIFIER,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 7,
	 RIDTYPE_3GPP
	},
	{
	 PDFDFWLAN_EFWEHPLMNPI_IDENTIFIER,
	  FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 PADF_DFWLAN_IDENTIFIER,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 8,
	 RIDTYPE_3GPP
	},
	{
	 PDFDFWLAN_EFWHPI_IDENTIFIER,
	  FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 PADF_DFWLAN_IDENTIFIER,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 9,

	 RIDTYPE_3GPP
	},
	{
	 PDFDFWLAN_EFWLRPLMN_IDENTIFIER,
	  FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 PADF_DFWLAN_IDENTIFIER,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0xa,

	 RIDTYPE_3GPP
	},
	{
	 PDFDFWLAN_EFHPLMNDAI_IDENTIFIER,
	  FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 PADF_DFWLAN_IDENTIFIER,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0xb,
	
	 RIDTYPE_3GPP
	},

// DFHNB	
	{
	 PADF_DFHNB_IDENTIFIER,
	// FILE_TYPE_DF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_DF_NAME,
	//20200330
	 FILE_TYPE_DF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS|EXIST_SAME_DF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP
	},
	{
	 PDFDFHNB_EFACSGL_IDENTIFIER,
	  FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 PADF_DFHNB_IDENTIFIER,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 1,

	 RIDTYPE_3GPP
	},
	{
	 PDFDFHNB_EFCSGI_IDENTIFIER,
	  FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	 PADF_DFHNB_IDENTIFIER,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 2,

	 RIDTYPE_3GPP
	},
	{
	 PDFDFHNBN_EFACSGL_IDENTIFIER,
	  FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|FILE_SESSION_ACTIVATE_AFTER_AID_ACCESS,
	  PADF_DFHNB_IDENTIFIER,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	 3,
	 RIDTYPE_3GPP
	},
	{
	 PPTELECOM_PDFPHONEBOOK_EFEXT1_IDENTIFIER,
	  FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED\
	  |SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC|STARTBYTE_1_LINEARFIXED_CYCLIC,
	 PTELECOM_DFPHONEBOOK_IDENTIFIER,
	 DFTELECOM_IDENTIFIER,
	 MF_IDENTIFIER
	 //8
	},
	 
	//EF --Parent is DFCDMA  以ADF形式出现
	{
	 EFCOUNT_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_MANDATORY|EF_STRUCTURE_CYCLIC|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_0_LINEARFIXED_CYCLIC,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},	
  {
	 EFIMSI_M_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 4 ,
	 RIDTYPE_3GPP2
  },
 {
	 EFIMSI_T_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 5 ,
	 RIDTYPE_3GPP2
	},
	{
	 EFTMSI_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 6 ,
	 RIDTYPE_3GPP2
	},	
	{
	 EFAH_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},
 	{
	 EFAOP_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_CYCLIC,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},	
	
  {
	 EFALOC_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
  },
 {
	 EFCDMAHOME_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_LINEARFIXED|DEFAULT_0_LINEARFIXED_CYCLIC|SPARE_MODE_LINEARFIXED_CYCLIC,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0xc ,
	 RIDTYPE_3GPP2
	},
	{
	 EFZNREGI_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_MANDATORY|EF_STRUCTURE_LINEARFIXED|DEFAULT_0_LINEARFIXED_CYCLIC|SPARE_MODE_LINEARFIXED_CYCLIC,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},	
	{
	 EFSNREGI_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0xd ,
	 RIDTYPE_3GPP2
	},
		{
	 EFDISTREGI_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},	
	{
	 EFACCOLC_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 3 ,
	 RIDTYPE_3GPP2
	},
	
{
	 EFTERM_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},	
	{
	 EFSSCI_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},
 	{
	 EFACP_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},	
	
  {
	 EFPRL_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|LONG_TRANSPARENT_EF_CUT_TAIL_DEFAULT_0|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 7 ,
	 RIDTYPE_3GPP2
  },
 {
	 EFRUIMID_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},
	{
	 EFCST_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 2 ,
	 RIDTYPE_3GPP2
	},	
	{
	 EFTSPC_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},
		{
	 EFOTAPASPC_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},	
	{
	 EFNAMLOCK_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},	
		{
	 EFOTA_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},
		{
	 EFSP_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},	
	{
	 EFESNME_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},	
	{
	 EFREVISION_CDMA,
	// FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	  //20200330 EFREVISION_CDMA 有些正常card 没有MANDATORY
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},
	//	/*
		{
	 EFPL_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0xa ,
	 RIDTYPE_3GPP2
	},	
//	*/
	{
	 EFSMS_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|EXIST_SAME_EF_NAME|STARTBYTE_2_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC|SPARE_MODE_LINEARFIXED_CYCLIC,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0x0,
	 RIDTYPE_3GPP2
	},	
		{
	 EFSMSP_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED\
	 |SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},
		{
	 EFSMSS_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME|CAN_FORK,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},	
	{
	 EFESSFC_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},
	
{
	 EFSPN_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 8 ,
	 RIDTYPE_3GPP2
	},	
		{
	 EFUSGINDN_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},
		{
	 EFAD_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 1 ,
	 RIDTYPE_3GPP2
	},	
	{
	 EFMDN_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},		

	{
	 EFMAXPRL_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},
		{
	 EFSPCS_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},	
	{
	 EFECC_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 9 ,
	 RIDTYPE_3GPP2
	},	
		{
	 EFME3GPDOPC_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME|CAN_FORK,
	 //FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},	
		
	{
	 EF3GPDOPM_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},
		{
	 EFSIPCAP_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},	
	{
	 EFMIPCAP_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},		

	{
	 EFSIPUPP_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},
		{
	 EFMIPUPP_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},	
	{
	 EFSIPSP_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},	
		{
	 EFMIPSP_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},		

	{
	 EFSIPPAPSS_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},	
	{
	 EFPUZL_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},
	
{
	 EMAXPUZL_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},	
		{
	 EFMECRP_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT|CAN_FORK,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},
		{
	 EFHRPDCAP_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},	

	{
	 EFHRPDUPP_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},	
		
  {   //20181022
	 PADF_6F06_CDMA,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},	
	{
	 EFCSSPR_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},
		{
	 EFATC_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},	
	{
	 EFEPRL_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|LONG_TRANSPARENT_EF_CUT_TAIL_DEFAULT_0,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0xe ,
	 RIDTYPE_3GPP2
	},	
		{
	 EFBCSMSCFG_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},	
		
	{
	 EFBCSMSPREF_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},
		{
	 EFBCSMSTABLE_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},	
		{
	 EFBCSMSP_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},
		{
	 EFIMPI_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},	
	

{
	 EFDOMAIN_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},	
	{
	 EFIMPU_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},	
		{
	 EFPCSCF_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},
	
	{
	 EFBAKPARA_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},	
		
	{
	 EFUpBAKPARA_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_CYCLIC,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},			
		{
	 EFMMSN_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},		
		{
	 EFEXT8_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},	



{
	 EFMMSICP_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},	
	{
	 EFMMSUP_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},	
		{
	 EFMMSUCP_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},
	
	{
	 EFAUTHCAPABILITY_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},	
  	
	{
	 EF3GCIK_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0xb ,
	 RIDTYPE_3GPP2
	},			
		{
	 EFDCK_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},		
		{
	 EFGID1_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},	
	
	{
	 EFGID2_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},			
		{
	 EFCDMACNL_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},		
		{
	 EFHOME_TAG_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},	
		
	{
	 EFGROUP_TAG_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},			
		{
	 EFSPECIFIC_TAG_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},		
		
	{
	 EFCALL_PROMPT_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|EF_STRUCTURE_TRANSPARENT,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},	
	
	{
	 EFSF_EUIMID_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT|EXIST_SAME_EF_NAME,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	 0 ,
	 RIDTYPE_3GPP2
	},
	{
	 EFEST_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	  0xf ,
	 RIDTYPE_3GPP2
	},
	
  {
	 EFICI_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_CYCLIC,
	 DFCDMA_IDENTIFIER,
	 USIMADF_IDENTIFIER,
	  MF_IDENTIFIER,
	  0x10 ,
	 RIDTYPE_3GPP2
	},
	
	{
	 EFOCI_CDMA,
	// FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_HIGH|FILE_OPTIONAl|EF_STRUCTURE_CYCLIC,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	  0x11 ,
	 RIDTYPE_3GPP2
	},
	{
	 EFCCP2_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	  0x12 ,
	 RIDTYPE_3GPP2
	},
	
	{
	 EFHIDDENKEY_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_TRANSPARENT,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	  0 ,
	 RIDTYPE_3GPP2
	},
	
	{
	 EFEXT5_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	  0 ,
	 RIDTYPE_3GPP2
	},
	{
	 EFFDN_CDMA,
	 FILE_TYPE_EF|FILE_UPDATE_ACTIVITY_LOW|FILE_OPTIONAl|EF_STRUCTURE_LINEARFIXED|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	  0 ,
	 RIDTYPE_3GPP2
	},
	{   //20181022 
	 PADF_6F85_CDMA,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	  0 ,
	 RIDTYPE_3GPP2
	},
	{   //20181022 
	 PADF_6F80_CDMA,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	  0 ,
	 RIDTYPE_3GPP2
	},
	{   //20181022 
	 PADF_6F81_CDMA,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER|SPARE_MODE_LINEARFIXED_CYCLIC|DEFAULT_FF_LINEARFIXED_CYCLIC|CAN_FORK,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	  0 ,
	 RIDTYPE_3GPP2
	},
	{   //20181022 
	 PADF_6F83_CDMA,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER|CAN_FORK,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	  0 ,
	 RIDTYPE_3GPP2
	},
	{   //20181022 
	 PADF_6F89_CDMA,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER|CAN_FORK,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	  0 ,
	 RIDTYPE_3GPP2
	},
	{   //20181022 
	 PADF_6F8F_CDMA,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER|CAN_FORK,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	  0 ,
	 RIDTYPE_3GPP2
	},
	{   //20181022 
	 PADF_6F90_CDMA,
	 FILE_TYPE_EF|GET_EF_TYPE_FROM_HEADER|CAN_FORK,
	 USIMADF_IDENTIFIER,
	 MF_IDENTIFIER,
	  MF_IDENTIFIER,
	  0 ,
	 RIDTYPE_3GPP2
	},
	{
	 USIMADF_IDENTIFIER,
	 FILE_TYPE_DF|FILE_UPDATE_ACTIVITY_LOW|FILE_MANDATORY|FILE_ACESS_AID_ONLY,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 MF_IDENTIFIER,
	 0,
	 RIDTYPE_3GPP2
	}, 

}; 	
	 
vcard_file_hierarchy_t vcard_file_hierarchy[6]={
	{
	 FILE_1ST_ID_MF
	},
	
	{
	FILE_1ST_ID_UNDER_MF_EF,
	FILE_1ST_ID_MF
	},
	
	{
	FILE_1ST_ID_1LEVEL_DF,
	FILE_1ST_ID_MF
	},
	{
	FILE_1ST_ID_UNDER_1LEVEL_DF_EF,	
	FILE_1ST_ID_1LEVEL_DF,
	FILE_1ST_ID_MF
	},
	{
	FILE_1ST_ID_2LEVEL_DF,	
	FILE_1ST_ID_1LEVEL_DF,
	FILE_1ST_ID_MF
	},
	{
	FILE_1ST_ID_UNDER_2LEVEL_DF_EF,	
	FILE_1ST_ID_2LEVEL_DF,	
	FILE_1ST_ID_1LEVEL_DF,
	FILE_1ST_ID_MF
	}	
	};
	  
unsigned char vcard_file_property_list_num=sizeof(vcard_file_property_list)/sizeof(vcard_file_property_t);
//unsigned char vcard_file_property_list_Usim_num=sizeof(vcard_file_property_list_Usim)/sizeof(vcard_file_property_t);
unsigned short vcard_file_property_list_Usim_num=sizeof(vcard_file_property_list_Usim)/sizeof(vcard_file_property_t);  //超过256
unsigned char vcard_file_property_list_Uim_num=sizeof(vcard_file_property_list_Uim)/sizeof(vcard_file_property_t);

// vcardfile_identifier ， Vcard 中需要包含的文件标识， 顺序无关
	//Sim卡 只有GSM 和TELECOM 空间下的文件名可能冲突，目前尚未发现冲突的文件，
	//为结构上兼容冲突文件处理，增强扩展性，特此修正数据结构

alltype_vcard_identifier_t vcardfile_identifier_sim[]={

	{1,MF_IDENTIFIER},
	{1,DFDCS1800_IDENTIFIER},	
  {1,DFGSM_IDENTIFIER},
	{1,DFTELECOM_IDENTIFIER},
  {1,EFICCID_IDENTIFIER},
  {1,PGSM_EFIMSI_IDENTIFIER},
  {1,EFLOCI_IDENTIFIER},  //20181009 尝试增加 理论上High activity EF,实际也是High activity
  {1,EFACC_IDENTIFIER},  //20181009 尝试增加 理论上High activity EF,实际也是High activity
  {1,EFKc_IDENTIFIER},  //20181009 尝试增加 理论上High activity EF,实际也是High activity
  {1,EFACM_IDENTIFIER},  //20181009 尝试增加 理论上High activity EF,实际也是High activity
  {1,EFBCCH_IDENTIFIER},  //20181026 尝试增加 理论上High activity EF,实际也是High activity
  {1,EFCBMIR_IDENTIFIER},  //20181031 
  
  
  {1,PFGSM_EF_6F11},  //20181009 尝试增加 标准中没有， 但模块会访问的文件
  {1,PFGSM_EF_6F13},  //20181009 尝试增加 标准中没有， 但模块会访问的文件
  {1,PFGSM_EF_6F14},  //20181009 尝试增加 标准中没有， 但模块会访问的文件
  {1,PFGSM_EF_6F15},  //20181009 尝试增加 标准中没有， 但模块会访问的文件
  {1,PFGSM_EF_6F16},  //20181009 尝试增加 标准中没有， 但模块会访问的文件
  {1,PFGSM_EF_6F17},  //20181009 尝试增加 标准中没有， 但模块会访问的文件
  {1,PFGSM_EF_6F18},  //20181009 尝试增加 标准中没有， 但模块会访问的文件
  {1,PFGSM_EF_6F19},  //20181009 尝试增加 标准中没有， 但模块会访问的文件
  {1,PFGSM_EF_6F60},  //20181009 尝试增加 标准中没有， 但模块会访问的文件
  {1,PFGSM_EF_6F61},  //20181009 尝试增加 标准中没有， 但模块会访问的文件
  {1,PFGSM_EF_6F62},  //20181009 尝试增加 标准中没有， 但模块会访问的文件
  {1,PFGSM_EF_6FC5},  //20181009 尝试增加 标准中没有， 但模块会访问的文件
  {1,PFGSM_EF_6FC6},  //20181009 尝试增加 标准中没有， 但模块会访问的文件
  {1,PFGSM_EF_6FCB},  //20181009 尝试增加 标准中没有， 但模块会访问的文件
  {1,PFGSM_EF_6FCD},  //20181009 尝试增加 标准中没有， 但模块会访问的文件
  
  {1,EFECC_IDENTIFIER}, 
  {1,EFSMS_IDENTIFIER},  
  {1,EFELP_IDENTIFIER},  
  {1,EFLP_IDENTIFIER}, 
  {1,EFPhase_IDENTIFIER},
  {1,EFSST_IDENTIFIER},
 // {2,DFGSM_IDENTIFIER,EFSST_IDENTIFIER};
  {1,EFGID1_IDENTIFIER},
  {1,EFGID2_IDENTIFIER},
  {1,EFPLMNsel_IDENTIFIER},
  {1,EFAD_IDENTIFIER},
  {1,EFHPLMN_IDENTIFIER},
  {1,EFFPLMN_IDENTIFIER},
  {1,EFPUCT_IDENTIFIER},
  {1,EFACMmax_IDENTIFIER},
  {1,EFSMSS_IDENTIFIER}, 
  {1,EFCBMI_IDENTIFIER},
  {1,EFCBMID_IDENTIFIER}, 
  {1,EFADN_IDENTIFIER}, 
  {1,EFMSISDN_IDENTIFIER},
  {1,EFSMSP_IDENTIFIER},
  {1,EFSMSR_IDENTIFIER},  //20181009 尝试增加 理论上High activity EF,实际也是High activity
  {1,EFLND_IDENTIFIER},  //20181009 尝试增加 理论上High activity EF,实际也是High activity
  
  {1,EFKcGPRS_IDENTIFIER},  //20181023尝试增加 理论上High activity EF,实际也是High activity
  {1,EFLOCIGPRS_IDENTIFIER},  //20181023尝试增加 理论上High activity EF,实际也是High activity
  
  {1,EFEXT1_IDENTIFIER},
  {1,EFEXT2_IDENTIFIER},  
  {1,EFFDN_IDENTIFIER},
  {1,EFSPN_IDENTIFIER},
  {1,EFSDN_IDENTIFIER},
  {1,EFEXT3_IDENTIFIER}
	};		


	
alltype_vcard_identifier_t vcardfile_identifier_uim[]={
	{1,MF_IDENTIFIER},
	{1,DFDCS1800_IDENTIFIER},	
  {1,DFGSM_IDENTIFIER},
	{1,DFTELECOM_IDENTIFIER},
  {1,DFCDMA_IDENTIFIER},
  {1,EFICCID_IDENTIFIER},
  {1,EFIMSI_M_CDMA},
  {1,EFIMSI_T_CDMA},
  {1,EFHRPDUPP_CDMA},
  {2,DFCDMA_IDENTIFIER,EFACCOLC_CDMA},

// EFECC_IDENTIFIER,EFSMS_IDENTIFIER,
  {1,EFELP_IDENTIFIER},
  {2,DFCDMA_IDENTIFIER,EFRUIMID_CDMA},
  {2,DFCDMA_IDENTIFIER,EFECC_CDMA},
  {2,DFCDMA_IDENTIFIER,EFPL_CDMA},
 
  {2,DFCDMA_IDENTIFIER,EFCST_CDMA},
  {2,DFCDMA_IDENTIFIER,EFREVISION_CDMA},
  {2,DFCDMA_IDENTIFIER,EFUSGINDN_CDMA},
  
  ///EFACCOLC_CDMA,
  {2,DFCDMA_IDENTIFIER,EFME3GPDOPC_CDMA},   // 20181024 经常性写 经常性写 ,在网关应用中可能可以优化到EMU端
 // EFSIPUPP_CDMA,
  {2,DFCDMA_IDENTIFIER,EFSMSS_CDMA},
 
  {1,EFCDMAHOME_CDMA},
  {2,DFCDMA_IDENTIFIER,EFSPN_CDMA},
  {1,EFTERM_CDMA},
  {2,DFCDMA_IDENTIFIER,EFSIPUPP_CDMA},
  {1,EFOTAPASPC_CDMA},
  {1,EFNAMLOCK_CDMA},
  
  {1,EFFDN_IDENTIFIER},
  {1,EFSSCI_CDMA},
  {1,EFAH_CDMA},
  {2,DFCDMA_IDENTIFIER,EFMAXPRL_CDMA},
  {2,DFCDMA_IDENTIFIER,EFSPCS_CDMA},
  {1,EFOTA_CDMA},
  {1,EFSNREGI_CDMA},   //20181023 尝试增加 理论上High activity EF,实际是low activity 
  {1,EFDISTREGI_CDMA},   //20181023 尝试增加 理论上High activity EF,实际是low activity 
  {1,EFZNREGI_CDMA},   //20181023 尝试增加 理论上High activity EF,实际是low activity 
  {1,EFEPRL_CDMA},   //20181023 
  {1,EFOCI_CDMA},   //20181023 尝试增加 理论上High activity EF,实际是low activity 
  {1,EFHIDDENKEY_CDMA},   //20181023 尝试增加 理论上High activity EF,实际是low activity 
  {1,EFCOUNT_CDMA},   //20181023 尝试增加 理论上High activity EF,实际是low activity
  {1,EFTMSI_CDMA},   //20181023 尝试增加 理论上High activity EF,实际是low activity
  {1,EF_6F85_CDMA},   //20181023 尝试增加 未在标准中,但实际出现的
  {1,EF_6F86_CDMA},   //20181023 尝试增加 未在标准中,但实际出现的
  {2,DFCDMA_IDENTIFIER,EFSMS_CDMA},   //20181023 尝试增加 理论上High activity EF,实际是low activity
  
  {1,EFEXT2_CDMA},   //20181023 
  
  {2,DFCDMA_IDENTIFIER,EFMDN_CDMA}, 
  {2,DFCDMA_IDENTIFIER,EF3GPDOPM_CDMA},
  {2,DFCDMA_IDENTIFIER,EFPRL_CDMA},  
  {2,DFTELECOM_IDENTIFIER,EFLND_IDENTIFIER},
  {2,DFTELECOM_IDENTIFIER,EFEXT1_IDENTIFIER},
  {2,DFTELECOM_IDENTIFIER,EFEXT2_IDENTIFIER},
  {2,DFTELECOM_IDENTIFIER,EFEXT3_IDENTIFIER},
  
  {2,DFTELECOM_IDENTIFIER,EFSDN_IDENTIFIER},
  //尝试更新频率高的6f3d
  {2,DFCDMA_IDENTIFIER,EFSMSP_CDMA},     
  //wx add B 2018/6/8
		//EF --Parent is DFGSM
	{1,PGSM_EFIMSI_IDENTIFIER},
  {1,EFECC_IDENTIFIER}, 
  {2, DFTELECOM_IDENTIFIER,EFSMS_IDENTIFIER},    
  {1,EFLP_IDENTIFIER}, 
  {1,EFPhase_IDENTIFIER},
  {2,DFGSM_IDENTIFIER,EFSST_IDENTIFIER},
  {2,DFGSM_IDENTIFIER,EFGID1_IDENTIFIER},
  {2,DFGSM_IDENTIFIER,EFGID2_IDENTIFIER},
  {2,DFGSM_IDENTIFIER,EFPLMNsel_IDENTIFIER},
  {1,EFAD_IDENTIFIER},
  {2,DFGSM_IDENTIFIER,EFHPLMN_IDENTIFIER},
  {1,EFFPLMN_IDENTIFIER},
  {2,DFGSM_IDENTIFIER,EFPUCT_IDENTIFIER},
  {2,DFGSM_IDENTIFIER,EFACMmax_IDENTIFIER},
  {2,DFTELECOM_IDENTIFIER,EFSMSS_IDENTIFIER}, 
  {2,DFGSM_IDENTIFIER,EFCBMI_IDENTIFIER},
  {2,DFGSM_IDENTIFIER,EFCBMID_IDENTIFIER}, 
 // {2,DFTELECOM_IDENTIFIER,EFADN_IDENTIFIER}, 
  {1,EFMSISDN_IDENTIFIER},
  {1,PFGSM_EF_6F13},  //20181009 尝试增加 标准中没有， 但模块会访问的文件
  {1,PFGSM_EF_6F14},  //20181009 尝试增加 标准中没有， 但模块会访问的文件
  {1,PFGSM_EF_6F15},  //20181009 尝试增加 标准中没有， 但模块会访问的文件
  {1,PFGSM_EF_6F16},  //20181009 尝试增加 标准中没有， 但模块会访问的文件
  {1,PFGSM_EF_6F17},  //20181009 尝试增加 标准中没有， 但模块会访问的文件
  {2,DFGSM_IDENTIFIER,EFACM_IDENTIFIER},  //20181009 尝试增加 理论上High activity EF,实际也是High activity
 // {1,EFEXT1_IDENTIFIER},
//  {1,EFEXT2_IDENTIFIER},  
//  {1,EFFDN_IDENTIFIER},
  {2,DFGSM_IDENTIFIER,EFSPN_IDENTIFIER},
  {2,DFGSM_IDENTIFIER,EFLOCI_IDENTIFIER},  //20181023 尝试增加 理论上High activity EF,实际也是High activity
  {1,EFACC_IDENTIFIER},  //20181023 尝试增加 理论上High activity EF,实际也是High activity
  {1,EFKc_IDENTIFIER},  //20181023 尝试增加 理论上High activity EF,实际也是High activity
  {1,EFKcGPRS_IDENTIFIER},  //20181023尝试增加 理论上High activity EF,实际也是High activity
  
   {2,DFGSM_IDENTIFIER,EFLOCIGPRS_IDENTIFIER},  //20181023 尝试增加 理论上High activity EF,实际也是High activity 
   {2,DFTELECOM_IDENTIFIER,EFSMSP_IDENTIFIER},
   {1,PTELECOM_DF5F3C},
   {1,PPTELECOM_PDF5F3C_4F20},
   {1,PPTELECOM_PDF5F3C_4F21},
   
//  {1,EFSDN_IDENTIFIER},
 // {1,EFEXT3_IDENTIFIER},	
	//wx add E 2018/6/8
		//EF --Parent is DFGSM	
  {2,DFTELECOM_IDENTIFIER,EFADN_IDENTIFIER} 
   
	};		
	
	
//unsigned char vcardfile_identifier[][2]={	DFTELECOM_IDENTIFIER,EFSMSP_IDENTIFIER};

// Usim)vcardfile_identifier ， Vcard 中需要包含的文件标识， 顺序无关  快x出EFDIR_IDENTIFIER, 路径中不显式带MF；
alltype_vcard_identifier_t usim_vcard_identifier[]={
	{1,MF_IDENTIFIER},
	{1,DFGSM_IDENTIFIER},
	{1,DFTELECOM_IDENTIFIER},
  {1,PMF_EFARR_IDENTIFIER},  //20181031
	{1,EFICCID_IDENTIFIER},
	{1,EFDIR_IDENTIFIER},  //EFdir 必须在 所有ADF文件被操作之前先被操作
	{1,EFELP_IDENTIFIER},

	
	//可能不存在的文件往后放
//	{2,DFGSM_IDENTIFIER,PFGSM_EF_6F13},  //20181009 尝试增加 Administrative EF
//	{2,DFGSM_IDENTIFIER,PFGSM_EF_6F11},  //20181009 尝试增加 Administrative EF
	{2,USIMADF_IDENTIFIER,PADF_EFIMSI_IDENTIFIER,{0,0},RIDTYPE_3GPP},
	{2,USIMADF_IDENTIFIER,PADF_EFEFECC_IDENTIFIER,{0,0},RIDTYPE_3GPP},
	{2,USIMADF_IDENTIFIER,PADF_EFLI_IDENTIFIER,{0,0},RIDTYPE_3GPP},
	{2,USIMADF_IDENTIFIER,PADF_EFEHPLMN_IDENTIFIER,{0,0},RIDTYPE_3GPP},     //20180620   
	{2,USIMADF_IDENTIFIER,PADF_EFHiddenkey_IDENTIFIER,{0,0},RIDTYPE_3GPP},     //20180620  
	{2,USIMADF_IDENTIFIER,PADF_EFSMSR_IDENTIFIER,{0,0},RIDTYPE_3GPP},     //20180620

	{2,USIMADF_IDENTIFIER,PADF_EFAD_IDENTIFIER,{0,0},RIDTYPE_3GPP},
	{2,USIMADF_IDENTIFIER,PADF_EFUST_IDENTIFIER,{0,0},RIDTYPE_3GPP},
	{2,USIMADF_IDENTIFIER,PADF_EFEST_IDENTIFIER,{0,0},RIDTYPE_3GPP},
	{2,USIMADF_IDENTIFIER,PADF_EFACC_IDENTIFIER,{0,0},RIDTYPE_3GPP},
	{2,USIMADF_IDENTIFIER,PADF_EFHPPLMN_IDENTIFIER,{0,0},RIDTYPE_3GPP},
	{2,USIMADF_IDENTIFIER,PADF_EFHPLMNwAcT_IDENTIFIER,{0,0},RIDTYPE_3GPP},
	{2,USIMADF_IDENTIFIER,PADF_EFPLMNwAcT_IDENTIFIER,{0,0},RIDTYPE_3GPP},
  {2,USIMADF_IDENTIFIER,PADF_EFOPLMNwAcT_IDENTIFIER,{0,0},RIDTYPE_3GPP},
	{2,USIMADF_IDENTIFIER,PADF_EFFPLMN_IDENTIFIER,{0,0},RIDTYPE_3GPP},
	{2,USIMADF_IDENTIFIER,PADF_EFTHRESHOLD_IDENTIFIER,{0,0},RIDTYPE_3GPP},
	{2,USIMADF_IDENTIFIER,PADF_EFGID1_IDENTIFIER,{0,0},RIDTYPE_3GPP},
	{2,USIMADF_IDENTIFIER,PADF_EFGID2_IDENTIFIER,{0,0},RIDTYPE_3GPP},
	{2,USIMADF_IDENTIFIER,PADF_EFSPN_IDENTIFIER,{0,0},RIDTYPE_3GPP},
	{2,USIMADF_IDENTIFIER,PADF_EFPUCT_IDENTIFIER,{0,0},RIDTYPE_3GPP},
	{2,USIMADF_IDENTIFIER,PADF_EFMSISDN_IDENTIFIER,{0,0},RIDTYPE_3GPP},
  {2,USIMADF_IDENTIFIER,PADF_EFACMmax_IDENTIFIER,{0,0},RIDTYPE_3GPP},
  {2,USIMADF_IDENTIFIER,PADF_EFSMSS_IDENTIFIER,{0,0},RIDTYPE_3GPP},
  {2,USIMADF_IDENTIFIER,PADF_EFOCI_IDENTIFIER,{0,0},RIDTYPE_3GPP},  //20180927 尝试增加 High activity EF
  {2,USIMADF_IDENTIFIER,PADF_EFICI_IDENTIFIER,{0,0},RIDTYPE_3GPP},  //20180927 尝试增加 High activity EF
  {2,USIMADF_IDENTIFIER,PADF_EFNETPAR_IDENTIFIER,{0,0},RIDTYPE_3GPP},  //20180927 尝试增加 High activity EF
  {2,USIMADF_IDENTIFIER,PADF_EFACM_IDENTIFIER,{0,0},RIDTYPE_3GPP},  //20180927 尝试增加 High activity EF
  {2,USIMADF_IDENTIFIER,PADF_EFARR_IDENTIFIER,{0,0},RIDTYPE_3GPP},  //20180927 尝试增加 High activity EF
  
  {2,USIMADF_IDENTIFIER,PADF_EFSPDI_IDENTIFIER,{0,0},RIDTYPE_3GPP},  //20181025
  {2,USIMADF_IDENTIFIER,PADF_EFOPL_IDENTIFIER,{0,0},RIDTYPE_3GPP},  //20181025
  {2,USIMADF_IDENTIFIER,PADF_EFPNN_IDENTIFIER,{0,0},RIDTYPE_3GPP},  //20181025
  {2,USIMADF_IDENTIFIER,PADF_EFMBI_IDENTIFIER,{0,0},RIDTYPE_3GPP},  //20181025  
  
  //联通卡会读  
  {2,USIMADF_IDENTIFIER,PADF_EFEHPLMNPI_IDENTIFIER,{0,0},RIDTYPE_3GPP},  //20181025      
  {2,USIMADF_IDENTIFIER,PADF_EFCBMIR_IDENTIFIER,{0,0},RIDTYPE_3GPP},  //20181025 
  {2,USIMADF_IDENTIFIER,PADF_EFSDN_IDENTIFIER,{0,0},RIDTYPE_3GPP},  //20181025 
  {2,USIMADF_IDENTIFIER,PADF_EFEXT3_IDENTIFIER,{0,0},RIDTYPE_3GPP},  //20181025  
  {2,USIMADF_IDENTIFIER,PADF_EFDCK_IDENTIFIER,{0,0},RIDTYPE_3GPP},  //20181101                              
    
  
  {2,USIMADF_IDENTIFIER,PADF_6F14,{0,0},RIDTYPE_3GPP},  //20181009 尝试增加 Administrative EF
  {2,USIMADF_IDENTIFIER,PADF_6F15,{0,0},RIDTYPE_3GPP},  //20181009 尝试增加 Administrative EF
  {2,USIMADF_IDENTIFIER,PADF_6F16,{0,0},RIDTYPE_3GPP},  //20181009 尝试增加 Administrative EF
  {2,USIMADF_IDENTIFIER,PADF_6F17,{0,0},RIDTYPE_3GPP},  //20181009 尝试增加 Administrative EF
  {2,USIMADF_IDENTIFIER,PADF_6F18,{0,0},RIDTYPE_3GPP},  //20181009 尝试增加 Administrative EF
  {2,USIMADF_IDENTIFIER,PADF_6F65,{0,0},RIDTYPE_3GPP},  //20181009 尝试增加 Earlier EF
  
  
  {2,USIMADF_IDENTIFIER,PADF_EFLOCI_IDENTIFIER,{0,0},RIDTYPE_3GPP},  //20181009 尝试增加 理论上High activity EF,实际也是High activity
  {2,USIMADF_IDENTIFIER,PADF_EFEPSNSC_IDENTIFIER,{0,0},RIDTYPE_3GPP},  //20181009 尝试增加 理论上High activity EF,实际也是High activity
  {2,USIMADF_IDENTIFIER,PADF_EFPSLOCI_IDENTIFIER,{0,0},RIDTYPE_3GPP},  //20181009 尝试增加 理论上High activity EF,实际也是High activity
  {2,USIMADF_IDENTIFIER,PADF_EFEPSLOCI_IDENTIFIER,{0,0},RIDTYPE_3GPP},  //20181009 尝试增加 理论上High activity EF,实际也是High activity
  {2,USIMADF_IDENTIFIER,PADF_EFSTART_HFN_IDENTIFIER,{0,0},RIDTYPE_3GPP},  //20181009 尝试增加 理论上High activity EF,实际也是High activity
 
  {2,USIMADF_IDENTIFIER,PADF_EFKeys_IDENTIFIER,{0,0},RIDTYPE_3GPP},  //20181016 尝试增加 安全，鉴权敏感的文件,
  {2,USIMADF_IDENTIFIER,PADF_EFKEYPS_IDENTIFIER,{0,0},RIDTYPE_3GPP}, //20181016 安全，鉴权敏感的文件,
  {3,USIMADF_IDENTIFIER,PADF_DFGSM_ACCESS_IDENTIFIER,PDFGSM_ACCESS_EFKcGPRS_IDENTIFIER,RIDTYPE_3GPP},  //20181016 安全，鉴权敏感的文件,
  {3,USIMADF_IDENTIFIER,PADF_DFGSM_ACCESS_IDENTIFIER,PDFGSM_ACCESS_EFKc_IDENTIFIER,RIDTYPE_3GPP}, //20181016 安全，鉴权敏感的文件,
  
  
  {2,DFGSM_IDENTIFIER,PFGSM_EF_6F13},  //20181009 尝试增加 Administrative EF
	{2,DFGSM_IDENTIFIER,PFGSM_EF_6F11},  //20181009 尝试增加 Administrative EF
	{2,DFGSM_IDENTIFIER,PFGSM_EF_6F16},  //20181009 尝试增加 Administrative EF
 
	 
  {2,DFTELECOM_IDENTIFIER,PTELECOM_DFPHONEBOOK_IDENTIFIER},  //20180620
  {2,DFTELECOM_IDENTIFIER,EFSDN_IDENTIFIER},  
  {2,DFTELECOM_IDENTIFIER,PTELECOM_EFARR_IDENTIFIER},  //20180927
  {2,DFTELECOM_IDENTIFIER,EFFDN_IDENTIFIER},  //20181102
  {2,DFTELECOM_IDENTIFIER,EFLND_IDENTIFIER},  //20181102
  {2,DFTELECOM_IDENTIFIER,EFMSISDN_IDENTIFIER},  //20181102
  {2,DFTELECOM_IDENTIFIER,EFEXT3_IDENTIFIER},  //20181102

  
  {3,DFTELECOM_IDENTIFIER,PTELECOM_DFPHONEBOOK_IDENTIFIER,PDFPHONEBOOK_EFPBR_IDENTIFIER},
  {3,DFTELECOM_IDENTIFIER,PTELECOM_DFPHONEBOOK_IDENTIFIER,PDFPHONEBOOK_EFGAS_IDENTIFIER},
  {3,DFTELECOM_IDENTIFIER,PTELECOM_DFPHONEBOOK_IDENTIFIER,PPTELECOM_PDFPHONEBOOK_EFPSC_IDENTIFIER},
  {3,DFTELECOM_IDENTIFIER,PTELECOM_DFPHONEBOOK_IDENTIFIER,PPTELECOM_PDFPHONEBOOK_EFEMAIL_IDENTIFIER},
  {3,DFTELECOM_IDENTIFIER,PTELECOM_DFPHONEBOOK_IDENTIFIER,PPTELECOM_PDFPHONEBOOK_EFGRP_IDENTIFIER},
  {3,DFTELECOM_IDENTIFIER,PTELECOM_DFPHONEBOOK_IDENTIFIER,PPTELECOM_PDFPHONEBOOK_EFAAS_IDENTIFIER},
  {3,DFTELECOM_IDENTIFIER,PTELECOM_DFPHONEBOOK_IDENTIFIER,PPTELECOM_PDFPHONEBOOK_EFPBC_IDENTIFIER},
  {3,DFTELECOM_IDENTIFIER,PTELECOM_DFPHONEBOOK_IDENTIFIER,PDFPHONEBOOK_EFCC_IDENTIFIER},//20180927 
  {3,DFTELECOM_IDENTIFIER,PTELECOM_DFPHONEBOOK_IDENTIFIER,PDFPHONEBOOK_EFPUID_IDENTIFIER},//20180927 
  
  {3,DFTELECOM_IDENTIFIER,PTELECOM_DFPHONEBOOK_IDENTIFIER,PPTELECOM_PDFPHONEBOOK_4F31},//20180927 
  {3,DFTELECOM_IDENTIFIER,PTELECOM_DFPHONEBOOK_IDENTIFIER,PPTELECOM_PDFPHONEBOOK_4F41},//20180927 
  {3,DFTELECOM_IDENTIFIER,PTELECOM_DFPHONEBOOK_IDENTIFIER,PPTELECOM_PDFPHONEBOOK_4F51},//20180927 
  {3,DFTELECOM_IDENTIFIER,PTELECOM_DFPHONEBOOK_IDENTIFIER,PPTELECOM_PDFPHONEBOOK_4F52},//20180927 
  {3,DFTELECOM_IDENTIFIER,PTELECOM_DFPHONEBOOK_IDENTIFIER,PPTELECOM_PDFPHONEBOOK_4F5A},//20180927 
  
  {3,DFTELECOM_IDENTIFIER,PTELECOM_DFPHONEBOOK_IDENTIFIER,PPTELECOM_PDFPHONEBOOK_4F61},//20180927 
  {3,DFTELECOM_IDENTIFIER,PTELECOM_DFPHONEBOOK_IDENTIFIER,PPTELECOM_PDFPHONEBOOK_4F72},//20180927 
  {3,DFTELECOM_IDENTIFIER,PTELECOM_DFPHONEBOOK_IDENTIFIER,PPTELECOM_PDFPHONEBOOK_4F32},//20180927 
  {3,DFTELECOM_IDENTIFIER,PTELECOM_DFPHONEBOOK_IDENTIFIER,PPTELECOM_PDFPHONEBOOK_4F42},//20180927 
  {3,DFTELECOM_IDENTIFIER,PTELECOM_DFPHONEBOOK_IDENTIFIER,PPTELECOM_PDFPHONEBOOK_4F62},//20180927 
  {3,DFTELECOM_IDENTIFIER,PTELECOM_DFPHONEBOOK_IDENTIFIER,PPTELECOM_PDFPHONEBOOK_4F71},//20180927 
  {3,DFTELECOM_IDENTIFIER,PTELECOM_DFPHONEBOOK_IDENTIFIER,PPTELECOM_PDFPHONEBOOK_4F5B},//20180927 
  {3,DFTELECOM_IDENTIFIER,PTELECOM_DFPHONEBOOK_IDENTIFIER,PDFPHONEBOOK_EFUID1_IDENTIFIER},//20180927 
  {3,DFTELECOM_IDENTIFIER,PTELECOM_DFPHONEBOOK_IDENTIFIER,PPTELECOM_PDFPHONEBOOK_EFANRA_IDENTIFIER},//20181022
  {3,DFTELECOM_IDENTIFIER,PTELECOM_DFPHONEBOOK_IDENTIFIER,PPTELECOM_PDFPHONEBOOK_EFGRP1_IDENTIFIER},//20181022
  {3,DFTELECOM_IDENTIFIER,PTELECOM_DFPHONEBOOK_IDENTIFIER,PPTELECOM_PDFPHONEBOOK_EFANRB_IDENTIFIER},//20181022
  {3,DFTELECOM_IDENTIFIER,PTELECOM_DFPHONEBOOK_IDENTIFIER,PPTELECOM_PDFPHONEBOOK_4F34},//20181022
  {3,DFTELECOM_IDENTIFIER,PTELECOM_DFPHONEBOOK_IDENTIFIER,PPTELECOM_PDFPHONEBOOK_4F33},//20181022
  {3,DFTELECOM_IDENTIFIER,PTELECOM_DFPHONEBOOK_IDENTIFIER,PPTELECOM_PDFPHONEBOOK_EFPBC1_IDENTIFIER},//20181022
  {3,DFTELECOM_IDENTIFIER,PTELECOM_DFPHONEBOOK_IDENTIFIER,PPTELECOM_PDFPHONEBOOK_4F39},//20181029
  
  {3,DFTELECOM_IDENTIFIER,PTELECOM_DF5F3C,PPTELECOM_PDF5F3C_4F21},   //20181022
  {3,DFTELECOM_IDENTIFIER,PTELECOM_DF5F3C,PPTELECOM_PDF5F3C_4F20},   //20181022
  
  {3,USIMADF_IDENTIFIER,PADF_DFPHONEBOOK_IDENTIFIER,PDFPHONEBOOK_EFPBR_IDENTIFIER,RIDTYPE_3GPP},
  {2,USIMADF_IDENTIFIER,PADF_DFPHONEBOOK_IDENTIFIER,{0,0},RIDTYPE_3GPP},       //20180620
  {2,USIMADF_IDENTIFIER,PADF_EFSMSP_IDENTIFIER,{0,0},RIDTYPE_3GPP},
  {2,USIMADF_IDENTIFIER,PADF_EFFDN_IDENTIFIER,{0,0},RIDTYPE_3GPP},
  {2,USIMADF_IDENTIFIER,PADF_EFSMS_IDENTIFIER,{0,0},RIDTYPE_3GPP},
  
  {3,DFTELECOM_IDENTIFIER,PTELECOM_DFPHONEBOOK_IDENTIFIER,PPTELECOM_PDFPHONEBOOK_EFEXT1_IDENTIFIER},
  {3,DFTELECOM_IDENTIFIER,PTELECOM_DFPHONEBOOK_IDENTIFIER,PPTELECOM_PDFPHONEBOOK_EFADN_IDENTIFIER},
  {3,DFTELECOM_IDENTIFIER,PTELECOM_DFPHONEBOOK_IDENTIFIER,PPTELECOM_PDFPHONEBOOK_EFADN1_IDENTIFIER},//20180927 
  
  {2,USIMADF_IDENTIFIER,PADF_EFCFIS_IDENTIFIER,{0,0},RIDTYPE_3GPP}, 
  {2,USIMADF_IDENTIFIER,PADF_EFEXT2_IDENTIFIER,{0,0},RIDTYPE_3GPP},
  {2,USIMADF_IDENTIFIER,PADF_EFEXT5_IDENTIFIER,{0,0},RIDTYPE_3GPP},  
  {2,USIMADF_IDENTIFIER,PADF_EFCBMI_IDENTIFIER,{0,0},RIDTYPE_3GPP},  
  {2,USIMADF_IDENTIFIER,PADF_EFCBMID_IDENTIFIER,{0,0},RIDTYPE_3GPP},  
  {2,USIMADF_IDENTIFIER,PADF_EFEXT6_IDENTIFIER,{0,0},RIDTYPE_3GPP},  //20180620
  {2,USIMADF_IDENTIFIER,PADF_EFMBDN_IDENTIFIER,{0,0},RIDTYPE_3GPP},  //20180620
   
   
  {1,USIMADF_IDENTIFIER,{0,0},{0,0},RIDTYPE_3GPP},  //用于Session 激活后 获取status 数据
  
  
  //3GPP2
   {2,USIMADF_IDENTIFIER,EFIMSI_M_CDMA,{0,0},RIDTYPE_3GPP2},  
   {1,USIMADF_IDENTIFIER,{0,0},{0,0},RIDTYPE_3GPP2},  //用于Session 激活后 获取status 数据
   {2,USIMADF_IDENTIFIER,EFIMSI_T_CDMA,{0,0},RIDTYPE_3GPP2},  
   {2,USIMADF_IDENTIFIER,EFHRPDUPP_CDMA,{0,0},RIDTYPE_3GPP2},  
   
   {2,USIMADF_IDENTIFIER,EFACCOLC_CDMA,{0,0},RIDTYPE_3GPP2},  
   {2,USIMADF_IDENTIFIER,EFRUIMID_CDMA,{0,0},RIDTYPE_3GPP2},  
   {2,USIMADF_IDENTIFIER,EFECC_CDMA,{0,0},RIDTYPE_3GPP2},  
  
   {2,USIMADF_IDENTIFIER,EFPL_CDMA,{0,0},RIDTYPE_3GPP2},  
   {2,USIMADF_IDENTIFIER,EFCST_CDMA,{0,0},RIDTYPE_3GPP2},  
   {2,USIMADF_IDENTIFIER,EFREVISION_CDMA,{0,0},RIDTYPE_3GPP2},  
   {2,USIMADF_IDENTIFIER,EFUSGINDN_CDMA,{0,0},RIDTYPE_3GPP2},  
   {2,USIMADF_IDENTIFIER,EFSMSS_CDMA,{0,0},RIDTYPE_3GPP2},  
  
   {2,USIMADF_IDENTIFIER,EFCDMAHOME_CDMA,{0,0},RIDTYPE_3GPP2},  
   {2,USIMADF_IDENTIFIER,EFSPN_CDMA,{0,0},RIDTYPE_3GPP2},   
   {2,USIMADF_IDENTIFIER,EFTERM_CDMA,{0,0},RIDTYPE_3GPP2}, 
   {2,USIMADF_IDENTIFIER,EFSIPUPP_CDMA,{0,0},RIDTYPE_3GPP2},  
   {2,USIMADF_IDENTIFIER,EFMAXPRL_CDMA,{0,0},RIDTYPE_3GPP2},  
   {2,USIMADF_IDENTIFIER,EFMDN_CDMA,{0,0},RIDTYPE_3GPP2},  
   {2,USIMADF_IDENTIFIER,EF3GPDOPM_CDMA,{0,0},RIDTYPE_3GPP2},  
        
   {2,USIMADF_IDENTIFIER,EFOTAPASPC_CDMA,{0,0},RIDTYPE_3GPP2},  
   {2,USIMADF_IDENTIFIER,EFNAMLOCK_CDMA,{0,0},RIDTYPE_3GPP2},  
   {2,USIMADF_IDENTIFIER,EFAH_CDMA,{0,0},RIDTYPE_3GPP2},  
   {2,USIMADF_IDENTIFIER,EFSPCS_CDMA,{0,0},RIDTYPE_3GPP2},  
   {2,USIMADF_IDENTIFIER,EFOTA_CDMA,{0,0},RIDTYPE_3GPP2},  
   {2,USIMADF_IDENTIFIER,EFPRL_CDMA,{0,0},RIDTYPE_3GPP2},  
 //  {2,USIMADF_IDENTIFIER,EFSDN_IDENTIFIER,{0,0},RIDTYPE_3GPP2},  
   {2,USIMADF_IDENTIFIER,EFEST_CDMA,{0,0},RIDTYPE_3GPP2},  
   {2,USIMADF_IDENTIFIER,EFAD_CDMA,{0,0},RIDTYPE_3GPP2},
   {2,USIMADF_IDENTIFIER,EFSP_CDMA,{0,0},RIDTYPE_3GPP2},
    {2,USIMADF_IDENTIFIER,EFEPRL_CDMA,{0,0},RIDTYPE_3GPP2},
   {2,USIMADF_IDENTIFIER,EFHIDDENKEY_CDMA,{0,0},RIDTYPE_3GPP2},
   {2,USIMADF_IDENTIFIER,EFEXT5_CDMA,{0,0},RIDTYPE_3GPP2},
   {2,USIMADF_IDENTIFIER,EFSSCI_CDMA,{0,0},RIDTYPE_3GPP2},
   {2,USIMADF_IDENTIFIER,EFFDN_CDMA,{0,0},RIDTYPE_3GPP2},
   {2,USIMADF_IDENTIFIER,EFSIPCAP_CDMA,{0,0},RIDTYPE_3GPP2},
   
   {2,USIMADF_IDENTIFIER,EFME3GPDOPC_CDMA,{0,0},RIDTYPE_3GPP2},//20181021 尝试增加 理论上low activity EF,实际是High activity
   {2,USIMADF_IDENTIFIER,EFMECRP_CDMA,{0,0},RIDTYPE_3GPP2},//20181021 尝试增加 理论上low activity EF,实际是High activity 
    
   {2,USIMADF_IDENTIFIER,PADF_6F85_CDMA,{0,0},RIDTYPE_3GPP2},//20181021 尝试增加 标准中未列明,但实际存在的
   {2,USIMADF_IDENTIFIER,PADF_6F80_CDMA,{0,0},RIDTYPE_3GPP2},//20181021 尝试增加 标准中未列明,但实际存在的
   {2,USIMADF_IDENTIFIER,PADF_6F06_CDMA,{0,0},RIDTYPE_3GPP2},//20181021 尝试增加 标准中未列明,但实际存在的 
   {2,USIMADF_IDENTIFIER,PADF_6F81_CDMA,{0,0},RIDTYPE_3GPP2},//20181021 尝试增加 标准中未列明,但实际存在的
   {2,USIMADF_IDENTIFIER,PADF_6F83_CDMA,{0,0},RIDTYPE_3GPP2},//20181021 尝试增加 标准中未列明,但实际存在的
   {2,USIMADF_IDENTIFIER,PADF_6F89_CDMA,{0,0},RIDTYPE_3GPP2},//20181021 尝试增加 标准中未列明,但实际存在的   
   {2,USIMADF_IDENTIFIER,PADF_6F8F_CDMA,{0,0},RIDTYPE_3GPP2},//20181021 尝试增加 标准中未列明,但实际存在的  
   {2,USIMADF_IDENTIFIER,PADF_6F90_CDMA,{0,0},RIDTYPE_3GPP2},//20181021 尝试增加 标准中未列明,但实际存在的
   
   {2,USIMADF_IDENTIFIER,EFCOUNT_CDMA,{0,0},RIDTYPE_3GPP2},//20181021 尝试增加 理论上High activity EF 
   {2,USIMADF_IDENTIFIER,EFTMSI_CDMA,{0,0},RIDTYPE_3GPP2},//20181021 尝试增加 理论上High activity EF 
   {2,USIMADF_IDENTIFIER,EFDISTREGI_CDMA,{0,0},RIDTYPE_3GPP2},//20181021 尝试增加 理论上High activity EF 
   {2,USIMADF_IDENTIFIER,EFSNREGI_CDMA,{0,0},RIDTYPE_3GPP2},//20181021 尝试增加 理论上High activity EF 
   {2,USIMADF_IDENTIFIER,EFZNREGI_CDMA,{0,0},RIDTYPE_3GPP2},//20181021 尝试增加 理论上High activity EF 
   

   
   //尝试更新频率高的6f3d,6f3c
   {2,USIMADF_IDENTIFIER,EFSMS_CDMA,{0,0},RIDTYPE_3GPP2}, 
   {2,USIMADF_IDENTIFIER,EFSMSP_CDMA,{0,0},RIDTYPE_3GPP2},  
 //  {2,USIMADF_IDENTIFIER,EF3GPDOPM_CDMA,{0,0},RIDTYPE_3GPP2},  
//   {2,USIMADF_IDENTIFIER,EF3GPDOPM_CDMA,{0,0},RIDTYPE_3GPP2},  
   {1,USIMADF_IDENTIFIER,{0,0},{0,0},RIDTYPE_3GPP2},  //用于Session 激活后 获取status 数据
	};



//ETSI TS 101.220 relase 12   AID 
unsigned char aid_rid_3gpp[]={0xa0,0,0,0,0x87};
unsigned char aid_rid_etsi[]={0xa0,0,0,0,0x09};
unsigned char aid_rid_3gpp2[]={0xa0,0,0,03,0x43};	//2018.7.3
	
// GSM APDU 命令 Select， Get Response，Read，Read Record

unsigned char command_select[]={0XA0,0XA4,0,0,2};
unsigned char command_get_reponse[]={0XA0,0XC0,0,0};
unsigned char command_read[]={0XA0,0XB0,0,0,0};
unsigned char command_read_record[]={0XA0,0XB2,0,4,0};


// Usim APDU 命令 Select， Get Response，Read，Read Record
unsigned char usimselect_pathfromMfReturnFcp[]={0X0,0XA4,8,4};
unsigned char usimselect_pathByFidReturnFcp[]= {0X0,0XA4,0,4};
unsigned char usimcommand_get_reponse[]={0X0,0XC0,0,0};
unsigned char usimcommand_read[]={0X0,0XB0,0,0,0};
unsigned char usimcommand_read_record[]={0X0,0XB2,0,4,0};  //P2=4 Absolute/current mode, 
unsigned char usimselect_ByDFName_NoDataReturn[]={0X0,0XA4,4,0xC};
unsigned char usimselect_ByFIReturnFcpForSelectMF[]={0X0,0XA4,0,4,2};
unsigned char usim_verify_chv1_globe_check_times[]={0X0,0X20,0,1,0};  //P2=1 chv, 
unsigned char usim_verify_chv1_globe[]={0X0,0X20,0,1};  //P2=1 chv, 
unsigned char usim_verify_chv1_specific_check_times[]={0X0,0X20,0,0x81,0};  //P2=1 chv, 
unsigned char usim_verify_chv1_specific[]={0X0,0X20,0,0x81};  //P2=1 chv, 

unsigned char usim_unblock_chv1_globe_check_times[]={0X0,0X2c,0,1,0};  //P2=1 chv, 
unsigned char usim_unblock_chv1_specific_check_times[]={0X0,0X2c,0,81,0};  //P2=1 chv,  

unsigned char sim_uim_verify_chv1_globe[]={0Xa0,0X20,0,1};  //P2=1 chv, 

//201810918 Vcard 中增加Apdu命令操作表
vcard_comand_operation_list_t  usim_vcard_comand_operation_list[]{
	{TAG_UNBLOCK_GLOBLE_USIM,APDU_UNBLOCK_GLOBLE_USIM,{0X0,0X2c,0,1,0}},
	};
/*
// 虚拟卡命令操作列表
typedef struct VCARD_COMMAND_OPERATION_LIST_S     //20181018
{
	unsigned char tag;	
	unsigned char ApduOperation;				                     
	unsigned char ApduCommand[5];                              
	unsigned char ApduArgumentLength;                             
	unsigned char ApduArgument[APDU_BUF_MAX_LENGTH];				                  
	
}vcard_comand_operation_list_t;
*/

// vcard_generator_t vgs;

unsigned long VcardGenerator::GetTickCount()  
{  
    struct timespec ts;  
  
    clock_gettime(CLOCK_MONOTONIC, &ts);  
  
    return (ts.tv_sec * 1000 + ts.tv_nsec / 1000000);  
}


/**************************************************************************** 
* 函数名称 : GetVcardFileProperty
* 类       ：VcardGenerator
* 功能描述 : 检查文件标识是否属于GSM11.11定义的文件
* 参    数 : identifier ：文件标识，
* 参    数 :  vcard_file_property：文件属性表指针
* 参    数 : 
* 返 回 值 : 属于 返回 1  不属于 返回 -1
* 作    者 : 王翔
* 设计日期 : 
* 修改日期		  修改人		   修改内容  
 *****************************************************************************/
int VcardGenerator::GetVcardFileProperty(unsigned char identifier[2],vcard_file_property_t *vcard_file_property) {
		int iListCounter;		
	  
		for (iListCounter=0;iListCounter<sizeof(vcard_file_property_list)/sizeof(vcard_file_property_t);iListCounter++){
		  	if( (vcard_file_property_list[iListCounter].identifier[0]==identifier[0])&&(vcard_file_property_list[iListCounter].identifier[1]==identifier[1])){	  	   
		  	     (*vcard_file_property)=vcard_file_property_list[iListCounter];		  	  
		  	     break;
		  	}
		}
	if (iListCounter==sizeof(vcard_file_property_list)/sizeof(vcard_file_property_t)){
			 vgs.ucStatusCode=ERROR_IDENTIFIER_MISMATCH;
			 return -1;
			}
	  return 1;
	}
int VcardGenerator::GetVcardFileProperty_Uim(unsigned char identifier[2],vcard_file_property_t *vcard_file_property) {
		int iListCounter;		
	  
		for (iListCounter=0;iListCounter<sizeof(vcard_file_property_list_Uim)/sizeof(vcard_file_property_t);iListCounter++){
		  	if( (vcard_file_property_list_Uim[iListCounter].identifier[0]==identifier[0])&&(vcard_file_property_list_Uim[iListCounter].identifier[1]==identifier[1])){	  	   
		  	     (*vcard_file_property)=vcard_file_property_list_Uim[iListCounter];		  	  
		  	     break;
		  	}
		}
	if (iListCounter==sizeof(vcard_file_property_list_Uim)/sizeof(vcard_file_property_t)){
			 vgs.ucStatusCode=ERROR_IDENTIFIER_MISMATCH;
			 return -1;
			}
	  return 1;
	}
	
int VcardGenerator::GetVcardFileProperty_Sim(unsigned char identifier[2],vcard_file_property_t *vcard_file_property) {
		int iListCounter;		
	      
		for (iListCounter=0;iListCounter<sizeof(vcard_file_property_list)/sizeof(vcard_file_property_t);iListCounter++){
		  	if( (vcard_file_property_list[iListCounter].identifier[0]==identifier[0])&&(vcard_file_property_list[iListCounter].identifier[1]==identifier[1])){	  	   
		  	     (*vcard_file_property)=vcard_file_property_list[iListCounter];		  	  
		  	     break;
		  	}
		}
	if (iListCounter==sizeof(vcard_file_property_list)/sizeof(vcard_file_property_t)){
			 vgs.ucStatusCode=ERROR_IDENTIFIER_MISMATCH;
			 return -1;
			}
	  return 1;
	}
// 带路径查询避免同名文件冲突
int VcardGenerator::GetVcardFilePropertyWithPath_Sim(alltype_vcard_identifier_t vcardfile_identifier,vcard_file_property_t *vcard_file_property) {
		int iListCounter;		
	  
	  if (vcardfile_identifier.length==1)
	  	 return (GetVcardFileProperty_Sim(vcardfile_identifier.identifier1,vcard_file_property));
	  	 
	  else
	  if (vcardfile_identifier.length==2){
	  	  	for (iListCounter=0;iListCounter<sizeof(vcard_file_property_list)/sizeof(vcard_file_property_t);iListCounter++){
		  	      if( (vcard_file_property_list[iListCounter].identifier[0]==vcardfile_identifier.identifier2[0])\
		  	      	&&(vcard_file_property_list[iListCounter].identifier[1]==vcardfile_identifier.identifier2[1])\
		  	      	&&(vcard_file_property_list[iListCounter].parent_identifier[0]==vcardfile_identifier.identifier1[0])\
		  	      	&&(vcard_file_property_list[iListCounter].parent_identifier[1]==vcardfile_identifier.identifier1[1])\
		  	      	){	  	   
		  	             (*vcard_file_property)=vcard_file_property_list[iListCounter];		  	  
		  	               break;
		  	        }
		      }
		      if (iListCounter==sizeof(vcard_file_property_list)/sizeof(vcard_file_property_t)){
			       vgs.ucStatusCode=ERROR_IDENTIFIER_MISMATCH;
			      return -1;
			    }  		
	  }
		else
	  if (vcardfile_identifier.length==3){   
	  	  	for (iListCounter=0;iListCounter<sizeof(vcard_file_property_list)/sizeof(vcard_file_property_t);iListCounter++){
		  	      if( (vcard_file_property_list[iListCounter].identifier[0]==vcardfile_identifier.identifier3[0])\
		  	      	&&(vcard_file_property_list[iListCounter].identifier[1]==vcardfile_identifier.identifier3[1])\
		  	      	&&(vcard_file_property_list[iListCounter].parent_identifier[0]==vcardfile_identifier.identifier2[0])\
		  	      	&&(vcard_file_property_list[iListCounter].parent_identifier[1]==vcardfile_identifier.identifier2[1])\
		  	      	&&(vcard_file_property_list[iListCounter].grandfather_identifier[0]==vcardfile_identifier.identifier1[0])\
		  	      	&&(vcard_file_property_list[iListCounter].grandfather_identifier[1]==vcardfile_identifier.identifier1[1])\
		  	      	){	  	   
		  	             (*vcard_file_property)=vcard_file_property_list[iListCounter];		  	  
		  	               break;
		  	        }
		      }
		      if (iListCounter==sizeof(vcard_file_property_list)/sizeof(vcard_file_property_t)){
			       vgs.ucStatusCode=ERROR_IDENTIFIER_MISMATCH;
			      return -1;
			    }  		
	  }
	  else
	  	return -1;
	
	  return 1;
	}	
// 带路径查询避免同名文件冲突
int VcardGenerator::GetVcardFilePropertyWithPath_Uim(alltype_vcard_identifier_t vcardfile_identifier,vcard_file_property_t *vcard_file_property) {
		int iListCounter;		
	  
	  if (vcardfile_identifier.length==1)
	  	 return (GetVcardFileProperty_Uim(vcardfile_identifier.identifier1,vcard_file_property));
	  	 
	  else
	  if (vcardfile_identifier.length==2){
	  	  	for (iListCounter=0;iListCounter<sizeof(vcard_file_property_list_Uim)/sizeof(vcard_file_property_t);iListCounter++){
		  	      if( (vcard_file_property_list_Uim[iListCounter].identifier[0]==vcardfile_identifier.identifier2[0])\
		  	      	&&(vcard_file_property_list_Uim[iListCounter].identifier[1]==vcardfile_identifier.identifier2[1])\
		  	      	&&(vcard_file_property_list_Uim[iListCounter].parent_identifier[0]==vcardfile_identifier.identifier1[0])\
		  	      	&&(vcard_file_property_list_Uim[iListCounter].parent_identifier[1]==vcardfile_identifier.identifier1[1])\
		  	      	){	  	   
		  	             (*vcard_file_property)=vcard_file_property_list_Uim[iListCounter];		  	  
		  	               break;
		  	        }
		      }
		      if (iListCounter==sizeof(vcard_file_property_list_Uim)/sizeof(vcard_file_property_t)){
			       vgs.ucStatusCode=ERROR_IDENTIFIER_MISMATCH;
			      return -1;
			    }  		
	  }
		else
	  if (vcardfile_identifier.length==3){   
	  	  	for (iListCounter=0;iListCounter<sizeof(vcard_file_property_list_Uim)/sizeof(vcard_file_property_t);iListCounter++){
		  	      if( (vcard_file_property_list_Uim[iListCounter].identifier[0]==vcardfile_identifier.identifier3[0])\
		  	      	&&(vcard_file_property_list_Uim[iListCounter].identifier[1]==vcardfile_identifier.identifier3[1])\
		  	      	&&(vcard_file_property_list_Uim[iListCounter].parent_identifier[0]==vcardfile_identifier.identifier2[0])\
		  	      	&&(vcard_file_property_list_Uim[iListCounter].parent_identifier[1]==vcardfile_identifier.identifier2[1])\
		  	      	&&(vcard_file_property_list_Uim[iListCounter].grandfather_identifier[0]==vcardfile_identifier.identifier1[0])\
		  	      	&&(vcard_file_property_list_Uim[iListCounter].grandfather_identifier[1]==vcardfile_identifier.identifier1[1])\
		  	      	){	  	   
		  	             (*vcard_file_property)=vcard_file_property_list_Uim[iListCounter];		  	  
		  	               break;
		  	        }
		      }
		      if (iListCounter==sizeof(vcard_file_property_list_Uim)/sizeof(vcard_file_property_t)){
			       vgs.ucStatusCode=ERROR_IDENTIFIER_MISMATCH;
			      return -1;
			    }  		
	  }
	  else
	  	return -1;
	
	  return 1;
	}

/**************************************************************************** 
* 函数名称 : GetVcardFileProperty_Usim
* 类       ：VcardGenerator
* 功能描述 : 检查文件标识是否属于TS31.102定义的文件
* 参    数 : identifier ：文件标识，
* 参    数 :  vcard_file_property：文件属性表指针
* 参    数 : 
* 返 回 值 : 属于 返回 1  不属于 返回 -1
* 作    者 : 王翔
* 设计日期 : 
* 修改日期		  修改人		   修改内容  
 *****************************************************************************/
int VcardGenerator::GetVcardFileProperty_Usim(unsigned char length,unsigned char *identifier  ,\
	                                            vcard_file_property_t *vcard_file_property) {
		int iListCounter;		
	  if (length<2)
	  	return -1;
		for (iListCounter=0;iListCounter<sizeof(vcard_file_property_list_Usim)/sizeof(vcard_file_property_t);iListCounter++){
			  if (length==2)
			  	 if ((vcard_file_property_list_Usim[iListCounter].identifier[0]== *identifier)\
			  	   && (vcard_file_property_list_Usim[iListCounter].identifier[1]== *(identifier+1))
			  	   ) {
			  	    (*vcard_file_property)=vcard_file_property_list_Usim[iListCounter];		 
			  	   break;
			  	 }
			  	
		  	if (length==4)
			  	 if ((vcard_file_property_list_Usim[iListCounter].parent_identifier[0]== *identifier)\
			  	   && (vcard_file_property_list_Usim[iListCounter].parent_identifier[1]== *(identifier+1)) \
			  	   && (vcard_file_property_list_Usim[iListCounter].identifier[0]== *(identifier+2)) \
			  	   && (vcard_file_property_list_Usim[iListCounter].identifier[1]== *(identifier+3))
			  	   ){
			  	    (*vcard_file_property)=vcard_file_property_list_Usim[iListCounter];	
			  	   break;
			  	   
			      }
			  if (length==6)
			  	 if ((vcard_file_property_list_Usim[iListCounter].parent_identifier[0]== *(identifier+2))\
			  	   && (vcard_file_property_list_Usim[iListCounter].parent_identifier[1]== *(identifier+3)) \
			  	   && (vcard_file_property_list_Usim[iListCounter].identifier[0]== *(identifier+4)) \
			  	   && (vcard_file_property_list_Usim[iListCounter].identifier[1]== *(identifier+5))\
			  	   && (vcard_file_property_list_Usim[iListCounter].grandfather_identifier[0]== *(identifier)) \
			  	   && (vcard_file_property_list_Usim[iListCounter].grandfather_identifier[1]== *(identifier+1))
			  	   ){
			  	    (*vcard_file_property)=vcard_file_property_list_Usim[iListCounter];	
			  	   break;
			  	   
			      }
		}
	if (iListCounter==sizeof(vcard_file_property_list_Usim)/sizeof(vcard_file_property_t)){
			 vgs.ucStatusCode=ERROR_IDENTIFIER_MISMATCH;
			 return -1;
			}
	  return 1;
	}

/**************************************************************************** 
* 函数名称 : GetVcardFileProperty_WithUsimRidType
* 类       ：VcardGenerator
* 功能描述 : 检查文件标识是否属于TS31.102定义的文件
* 参    数 : lengh, 文件标识长度 ，identifier ：文件标识，ridtype 类型
* 参    数 :  vcard_file_property：文件属性表指针
* 参    数 : 
* 返 回 值 : 属于 返回 1  不属于 返回 -1
* 作    者 : 王翔
* 设计日期 : 
* 修改日期		  修改人		   修改内容  
 *****************************************************************************/
int VcardGenerator::GetVcardFileProperty_WithUsimRidType(unsigned char length,unsigned char *identifier  , unsigned char ridtype, \
	                                            vcard_file_property_t *vcard_file_property) {
		int iListCounter;		
	  if (length<2)
	  	return -1;
		for (iListCounter=0;iListCounter<sizeof(vcard_file_property_list_Usim)/sizeof(vcard_file_property_t);iListCounter++){
			  if (length==2)
			  	 if ((vcard_file_property_list_Usim[iListCounter].identifier[0]== *identifier)\
			  	   && (vcard_file_property_list_Usim[iListCounter].identifier[1]== *(identifier+1)) \
			  	   && (vcard_file_property_list_Usim[iListCounter].application_id_type== ridtype) 
			  	   ) {
			  	    (*vcard_file_property)=vcard_file_property_list_Usim[iListCounter];		 
			  	   break;
			  	 }
			  	if (iListCounter==0x112)
			  		 int i=0;
		  	if (length==4)
			  	 if ((vcard_file_property_list_Usim[iListCounter].parent_identifier[0]== *identifier)\
			  	   && (vcard_file_property_list_Usim[iListCounter].parent_identifier[1]== *(identifier+1)) \
			  	   && (vcard_file_property_list_Usim[iListCounter].identifier[0]== *(identifier+2)) \
			  	   && (vcard_file_property_list_Usim[iListCounter].identifier[1]== *(identifier+3))\
			  	    && (vcard_file_property_list_Usim[iListCounter].application_id_type== ridtype) 
			  	   ){
			  	    (*vcard_file_property)=vcard_file_property_list_Usim[iListCounter];	
			  	   break;
			  	   
			      }
			  if (length==6)
			  	 if ((vcard_file_property_list_Usim[iListCounter].parent_identifier[0]== *(identifier+2))\
			  	   && (vcard_file_property_list_Usim[iListCounter].parent_identifier[1]== *(identifier+3)) \
			  	   && (vcard_file_property_list_Usim[iListCounter].identifier[0]== *(identifier+4)) \
			  	   && (vcard_file_property_list_Usim[iListCounter].identifier[1]== *(identifier+5))\
			  	   && (vcard_file_property_list_Usim[iListCounter].grandfather_identifier[0]== *(identifier)) \
			  	   && (vcard_file_property_list_Usim[iListCounter].grandfather_identifier[1]== *(identifier+1))\
			  	    && (vcard_file_property_list_Usim[iListCounter].application_id_type== ridtype) 
			  	   ){
			  	    (*vcard_file_property)=vcard_file_property_list_Usim[iListCounter];	
			  	   break;
			  	   
			      }
		}
	if (iListCounter==sizeof(vcard_file_property_list_Usim)/sizeof(vcard_file_property_t)){
			 vgs.ucStatusCode=ERROR_IDENTIFIER_MISMATCH;
			 return -1;
			}
	  return 1;
	}

/**************************************************************************** 
* 函数名称 : CheckNextFileThrough
* 类       ：VcardGenerator
* 功能描述 : 检查是否能直接有效选择下1个文件
* 参    数 : identifier ：文件标识
* 参    数 :  next_identifier：下一个文件标识
* 参    数 : 
* 返 回 值 : 可以 返回 1  不可以 返回 -1
* 作    者 : 王翔
* 设计日期 : 
* 修改日期		  修改人		   修改内容  
 *****************************************************************************/
int  VcardGenerator:: CheckNextFileThrough(unsigned char identifier[2],unsigned char next_identifier[2]){
	   vcard_file_property_t file1,file2,file3;

	   if (GetVcardFileProperty(identifier, &file1)<0) 
	   	   return -1;
	  
	   if (GetVcardFileProperty(next_identifier, &file2)<0) 
	   	   return -1;	
	   	   
	   if 	((file1.property&FILE_TYPE_MF)||(file1.property&FILE_TYPE_DF))
	        if ((file2.parent_identifier[0]==file1.identifier[0])&&(file2.parent_identifier[1]==file1.identifier[1])) //当前目录的直接子文件
	   	   	      return 1;
	   if 	(file1.property&FILE_TYPE_EF)
	        if ((file2.parent_identifier[0]==file1.parent_identifier[0])&&(file2.parent_identifier[1]==file1.parent_identifier[1]))  
	   	   	  		return 1;	
	   	   	  		  
	   if (file1.property&FILE_TYPE_DF)   	  		   
	   	   if ((file2.parent_identifier[0]==file1.parent_identifier[0])&&(file2.parent_identifier[1]==file1.parent_identifier[1])&&(file2.property&FILE_TYPE_DF)) //当前DF件的父目录下的直接DF文件;
	   	   	  		 return 1;	 
	   if (file1.property&FILE_TYPE_EF){   	  		 	   	   	  		 
	   	   	 if (GetVcardFileProperty(file1.parent_identifier, &file3)<0) 
	   	             return -1;	   	      
	   	   	 if ((file3.parent_identifier[0]==file2.parent_identifier[0])&&(file3.parent_identifier[1]==file2.parent_identifier[1])&&(file2.property&FILE_TYPE_DF)) 
	   	   	 			 return 1;
	   	} 	  		 
	   	   	  		 
	   if 	((file1.property&FILE_TYPE_MF)||(file1.property&FILE_TYPE_DF))	   	  		 
	   	   if ((file2.identifier[0]==file1.parent_identifier[0])&&(file2.identifier[1]==file1.parent_identifier[1]))  //当前目录的父目录
	   	   	 			 return 1;  		   
	   if 	(file1.property&FILE_TYPE_EF){
	       if (GetVcardFileProperty(file1.parent_identifier, &file3)<0) 
	   	           return -1;
	   	   if ((file3.parent_identifier[0]==file2.identifier[0])&&(file3.parent_identifier[1]==file2.identifier[1]))  
	   	   	 			 return 1;    
	   }
	    
	   if (file1.property&FILE_TYPE_DF)  
	       if ((file1.identifier[0]==file2.identifier[0])&&(file1.identifier[1]==file2.identifier[1])&&(file2.property&FILE_TYPE_DF)) //当前的DF文件
	   	   	  		 return 1;
	   	   	  		 	
	   if (file2.property&FILE_TYPE_MF)                                                                       // MF文件
	   	   			   return 1;   	  		 
	   	   	  		 
	   return 0;
	   
	  
}

int  VcardGenerator:: CheckNextFileThrough_Sim(unsigned char identifier[2],unsigned char next_identifier[2]){
	   vcard_file_property_t file1,file2,file3;

	   if (GetVcardFileProperty_Sim(identifier, &file1)<0) 
	   	   return -1;
	  
	   if (GetVcardFileProperty_Sim(next_identifier, &file2)<0) 
	   	   return -1;	
	   	   
	   if 	((file1.property&FILE_TYPE_MF)||(file1.property&FILE_TYPE_DF))
	        if ((file2.parent_identifier[0]==file1.identifier[0])&&(file2.parent_identifier[1]==file1.identifier[1])) //当前目录的直接子文件
	   	   	      return 1;
	   if 	(file1.property&FILE_TYPE_EF)
	        if ((file2.parent_identifier[0]==file1.parent_identifier[0])&&(file2.parent_identifier[1]==file1.parent_identifier[1]))  
	   	   	  		return 1;	
	   	   	  		  
	   if (file1.property&FILE_TYPE_DF)   	  		   
	   	   if ((file2.parent_identifier[0]==file1.parent_identifier[0])&&(file2.parent_identifier[1]==file1.parent_identifier[1])&&(file2.property&FILE_TYPE_DF)) //当前DF件的父目录下的直接DF文件;
	   	   	  		 return 1;	 
	   if (file1.property&FILE_TYPE_EF){   	  		 	   	   	  		 
	   	   	 if (GetVcardFileProperty_Sim(file1.parent_identifier, &file3)<0) 
	   	             return -1;	   	      
	   	   	 if ((file3.parent_identifier[0]==file2.parent_identifier[0])&&(file3.parent_identifier[1]==file2.parent_identifier[1])&&(file2.property&FILE_TYPE_DF)) 
	   	   	 			 return 1;
	   	} 	  		 
	   	   	  		 
	   if 	((file1.property&FILE_TYPE_MF)||(file1.property&FILE_TYPE_DF))	   	  		 
	   	   if ((file2.identifier[0]==file1.parent_identifier[0])&&(file2.identifier[1]==file1.parent_identifier[1]))  //当前目录的父目录
	   	   	 			 return 1;  		   
	   if 	(file1.property&FILE_TYPE_EF){
	       if (GetVcardFileProperty_Sim(file1.parent_identifier, &file3)<0) 
	   	           return -1;
	   	   if ((file3.parent_identifier[0]==file2.identifier[0])&&(file3.parent_identifier[1]==file2.identifier[1]))  
	   	   	 			 return 1;    
	   }
	   
	   if (file1.property&FILE_TYPE_DF)  
	       if ((file1.identifier[0]==file2.identifier[0])&&(file1.identifier[1]==file2.identifier[1])&&(file2.property&FILE_TYPE_DF)) //当前的DF文件
	   	   	  		 return 1;
	   	   	  		 	
	   if (file2.property&FILE_TYPE_MF)                                                                       // MF文件
	   	   			   return 1;   	  		 
	   	   	  		 
	   return 0;
	   
	  
}

int  VcardGenerator:: CheckNextFileThrough_Uim(unsigned char identifier[2],unsigned char next_identifier[2]){
	   vcard_file_property_t file1,file2,file3;

	   if (GetVcardFileProperty_Uim(identifier, &file1)<0) 
	   	   return -1;
	  
	   if (GetVcardFileProperty_Uim(next_identifier, &file2)<0) 
	   	   return -1;	
	   	   
	   if 	((file1.property&FILE_TYPE_MF)||(file1.property&FILE_TYPE_DF))
	        if ((file2.parent_identifier[0]==file1.identifier[0])&&(file2.parent_identifier[1]==file1.identifier[1])) //当前目录的直接子文件
	   	   	      return 1;
	   if 	(file1.property&FILE_TYPE_EF)
	        if ((file2.parent_identifier[0]==file1.parent_identifier[0])&&(file2.parent_identifier[1]==file1.parent_identifier[1]))  
	   	   	  		return 1;	
	   	   	  		  
	   if (file1.property&FILE_TYPE_DF)   	  		   
	   	   if ((file2.parent_identifier[0]==file1.parent_identifier[0])&&(file2.parent_identifier[1]==file1.parent_identifier[1])&&(file2.property&FILE_TYPE_DF)) //当前DF件的父目录下的直接DF文件;
	   	   	  		 return 1;	 
	   if (file1.property&FILE_TYPE_EF){   	  		 	   	   	  		 
	   	   	 if (GetVcardFileProperty_Uim(file1.parent_identifier, &file3)<0) 
	   	             return -1;	   	      
	   	   	 if ((file3.parent_identifier[0]==file2.parent_identifier[0])&&(file3.parent_identifier[1]==file2.parent_identifier[1])&&(file2.property&FILE_TYPE_DF)) 
	   	   	 			 return 1;
	   	} 	  		 
	   	   	  		 
	   if 	((file1.property&FILE_TYPE_MF)||(file1.property&FILE_TYPE_DF))	   	  		 
	   	   if ((file2.identifier[0]==file1.parent_identifier[0])&&(file2.identifier[1]==file1.parent_identifier[1]))  //当前目录的父目录
	   	   	 			 return 1;  		   
	   if 	(file1.property&FILE_TYPE_EF){
	       if (GetVcardFileProperty_Uim(file1.parent_identifier, &file3)<0) 
	   	           return -1;
	   	   if ((file3.parent_identifier[0]==file2.identifier[0])&&(file3.parent_identifier[1]==file2.identifier[1]))  
	   	   	 			 return 1;    
	   }
	   
	   if (file1.property&FILE_TYPE_DF)  
	       if ((file1.identifier[0]==file2.identifier[0])&&(file1.identifier[1]==file2.identifier[1])&&(file2.property&FILE_TYPE_DF)) //当前的DF文件
	   	   	  		 return 1;
	   	   	  		 	
	   if (file2.property&FILE_TYPE_MF)                                                                       // MF文件
	   	   			   return 1;   	  		 
	   	   	  		 
	   return 0;
	   
	  
}

/**************************************************************************** 
* 函数名称 : GetFileParent
* 类       ：VcardGenerator
* 功能描述 : 获取文件父节点， 置于parent_identifier
* 参    数 : identifier ：文件标识
* 参    数 :  parent_identifier ：父节点文件标识
* 参    数 : 
* 返 回 值 : 可以 返回 1  不可以 返回 -1
* 作    者 : 王翔
* 设计日期 : 
* 修改日期		  修改人		   修改内容  
 *****************************************************************************/
int VcardGenerator::GetFileParent(unsigned char identifier[2],unsigned char (*parent_identifier)[2]){
	vcard_file_property_t file_property;
	   
   if (GetVcardFileProperty(identifier, &file_property)<0) 
	   	     return -1;
	   else
	     		 {
	     		 	(*parent_identifier)[0]=file_property.parent_identifier[0];  
	     		 	(*parent_identifier)[1]=file_property.parent_identifier[1];     
	   }       
	 return 1;   
	}
int VcardGenerator::GetFileParent_Uim(unsigned char identifier[2],unsigned char (*parent_identifier)[2]){
	vcard_file_property_t file_property;
	   
   if (GetVcardFileProperty_Uim(identifier, &file_property)<0) 
	   	     return -1;
	   else
	     		 {
	     		 	(*parent_identifier)[0]=file_property.parent_identifier[0];  
	     		 	(*parent_identifier)[1]=file_property.parent_identifier[1];     
	   }       
	 return 1;   
	}	
	
int VcardGenerator::GetFileParent_Sim(unsigned char identifier[2],unsigned char (*parent_identifier)[2]){
	vcard_file_property_t file_property;
	   
   if (GetVcardFileProperty_Sim(identifier, &file_property)<0) 
	   	     return -1;
	   else
	     		 {
	     		 	(*parent_identifier)[0]=file_property.parent_identifier[0];  
	     		 	(*parent_identifier)[1]=file_property.parent_identifier[1];     
	   }       
	 return 1;   
	}		

int VcardGenerator::GetTagLocation_inFCP(unsigned char tag,unsigned char *Buf, int length){
	   int tmplocation;
	   if (!( (*Buf== TAG_FCP_TEMPLATE)&& *(Buf+1)==(unsigned char) length))
	   	  return -1;
	   tmplocation =2;
	   while (tmplocation<length) {
	   	if ( *(Buf+tmplocation)!=tag)
	   		 tmplocation+= *(Buf+tmplocation+1)+2;
	   	else
	   		break;
	   	}
     if (tmplocation>=length)  
     	 return -1;
	 return tmplocation;   
	}
	
int VcardGenerator::GetTagLocation_inACP(unsigned char tag,unsigned char *Buf, int length){
	   int tmplocation;
	   /*if (!( (*Buf== TAG_ACP_TEMPLATE)&& *(Buf+1)==(unsigned char) length))
	   	  return -1;
	   	  */
	   if (!(*Buf== TAG_ACP_TEMPLATE))
	   	  return -1;
	   if( *(Buf + 1) > (unsigned char) length){
	   		return -1;
	   	}
	   else if(*(Buf + 1)  <  (unsigned char) length)
	   	{
			unsigned char i = 0;
			for(;i <  (unsigned char) length - *(Buf + 1);i++)
			{
				if(*(Buf + 2 + *(Buf+1) + i) != 0xFF){
					return -1;
				}
			}
	   }	  
	   tmplocation =2;
	   while (tmplocation<length) {
	   	if ( *(Buf+tmplocation)!=tag)
	   		 tmplocation+= *(Buf+tmplocation+1)+2;
	   	else
	   		break;
	   	}
     if (tmplocation>=length)  
     	 return -1;
	 return tmplocation;   
	}

unsigned short VcardGenerator::FreshLengthAndReturnValue(unsigned char *SourceArray,unsigned short addlength,unsigned short *returnlength ){
	unsigned long tempvalue;
	tempvalue= (((unsigned short) (*SourceArray))<<8)+ (*(SourceArray+1))+ addlength;
	if (tempvalue>0xffff-DEEPTH_VCARD_LENGTH){
		   std::cout<<RED<<"Warning! length overflow"<<RESET<<std::endl<<std::flush;	
	     vgs.ucStatusCode=ERROR_VCARD_OVERFLOW;
	     return -1;        
		}
	 else	{
	 	      *(SourceArray+1)=(unsigned char)tempvalue;
	 	      * SourceArray=(unsigned char)(tempvalue>>8);
	 	       *returnlength=(unsigned short)tempvalue;
	 	
	 	}
		return 1;
}


	
int VcardGenerator::ExistSameIdentifier(vcard_file_property_t *file_property_list,int file_property_list_length,unsigned char identifier[2]){
	  int iCounter;
	  for (iCounter=0;iCounter<file_property_list_length;iCounter++){
	  	 if (((file_property_list+iCounter)->identifier[0]==identifier[0])&&((file_property_list+iCounter)->identifier[1]==identifier[1]))
	  	 	   break;  	
	  	}	
	  if (iCounter<file_property_list_length){
	  	if (((file_property_list+iCounter)->property&EXIST_SAME_EF_NAME)||((file_property_list+iCounter)->property&EXIST_SAME_DF_NAME))
	  		 return 1;
	  	else 
	  		 return 0;	 
	  }
	  else
	  	return -1;
	}
	

int VcardGenerator::ValidVCardIdentifierList(vcard_file_property_t *file_property_list,int file_property_list_length,\
	alltype_vcard_identifier_t *vcardfile_identifier_list, int vcardfile_identifier_list_length){
	  int iCounter,iDentifierCounter;
	  for (iDentifierCounter=0;iDentifierCounter<vcardfile_identifier_list_length;iDentifierCounter++){ 
	  	    if ((vcardfile_identifier_list+iDentifierCounter)->length==1){  //=1时不能有同名文件
	  	    	   if (iDentifierCounter==0x3f)
	  	    	   	int e=0;
	  	   	    if (ExistSameIdentifier(file_property_list,file_property_list_length,\
	  	   		 	   (vcardfile_identifier_list+iDentifierCounter)->identifier1)!=0){
	  	   		     std::cout<<RED<<"Single identifier exists same name or non-existent,can not distinguish identifier "<<RESET<<std::endl<<std::flush;	
	  	   	  	   return -1;
	  	   		 }
	  	    }
	  	   	else if ((vcardfile_identifier_list+iDentifierCounter)->length==2){  //=2时  identifier1不能有同名文件，identifier2必须有同名文件
	  	   	     if (ExistSameIdentifier(file_property_list,file_property_list_length,\
	  	   		 	   (vcardfile_identifier_list+iDentifierCounter)->identifier2)!=1){
	  	   		     std::cout<<RED<<"Identifier2 is distinguishable  "<<RESET<<std::endl<<std::flush;	
	  	   	  	   return -1;
	  	   		   }
	  	   		   if (ExistSameIdentifier(file_property_list,file_property_list_length,\
	  	   		 	   (vcardfile_identifier_list+iDentifierCounter)->identifier1)!=0){
	  	   		     std::cout<<RED<<"identifier1 exists same name or non-existent,can not distinguish identifier "<<RESET<<std::endl<<std::flush;		  	   	  	   	
	  	   	  	   return -1;
	  	   		   }
	  	   	}
	  	   	else if ((vcardfile_identifier_list+iDentifierCounter)->length==3){  //=2时  identifier1不能有同名文件，identifier2,3必须有同名文件
	  	   	     if (ExistSameIdentifier(file_property_list,file_property_list_length,\
	  	   		 	   (vcardfile_identifier_list+iDentifierCounter)->identifier2)!=1){
	  	   		     std::cout<<RED<<"Identifier2 is distinguishable  "<<RESET<<std::endl<<std::flush;	
	  	   	  	   return -1;
	  	   		   }
	  	   		   if (ExistSameIdentifier(file_property_list,file_property_list_length,\
	  	   		 	   (vcardfile_identifier_list+iDentifierCounter)->identifier3)!=1){
	  	   		     std::cout<<RED<<"Identifier3 is distinguishable  "<<RESET<<std::endl<<std::flush;	
	  	   	  	   return -1;
	  	   		   }
	  	   		   if (ExistSameIdentifier(file_property_list,file_property_list_length,\
	  	   		 	   (vcardfile_identifier_list+iDentifierCounter)->identifier1)!=0){
	  	   		     std::cout<<RED<<"identifier1 exists same name or non-existent,can not distinguish identifier "<<RESET<<std::endl<<std::flush;		  	   	  	   	
	  	   	  	   return -1;
	  	   		   }
	  	   	}		  	   	   
	  }
	  return 1;
	}	

/**************************************************************************** 
* 函数名称 : GenOperationFileList_Sim
* 类       ：VcardGenerator
* 功能描述 : 产生Vcard 操作列表(Sim mode)，填入file_operation_list
* 参    数 : 
* 参    数 : 
* 参    数 : 
* 返 回 值 : 可以 返回 1  不可以 返回 -1
* 作    者 : 王翔
* 设计日期 : 
* 修改日期		  修改人		   修改内容  
 *****************************************************************************/
int VcardGenerator::GenOperationFileList_Sim(){  //GSM
	  int iCounter,iListCounter,tmpCounter,retvalue;
	  unsigned char tmp_identifier[2],path_identifier[SIMFILEPATHDEEPTH][2];
	 
	 // int tmpInnerConuter;  
	  unsigned char mid_identifier[2];
	  if (ValidVCardIdentifierList(vcard_file_property_list,sizeof(vcard_file_property_list)/sizeof(vcard_file_property_t),\
	     vcardfile_identifier_sim, sizeof(vcardfile_identifier_sim)/sizeof(alltype_vcard_identifier_t))!=1)
	     return -1;  
	     
	  iListCounter=0;
	  for (iCounter=0;iCounter<sizeof(vcardfile_identifier_sim)/sizeof(alltype_vcard_identifier_t);iCounter++){
	 
	  	   if (vcardfile_identifier_sim[iCounter].length==1){
	  	    	   vgs.file_operation_list[iListCounter].identifier[0]=vcardfile_identifier_sim[iCounter].identifier1[0];
	  	         vgs.file_operation_list[iListCounter].identifier[1]=vcardfile_identifier_sim[iCounter].identifier1[1];
	  	         vgs.file_operation_list[iListCounter].operation_property=OPERATION_PROPERTY_GENERATION_VCARD;
	  	          //保存内容用于生成Vcard中的identifier长度和内容
	  	         vgs.file_operation_list[iListCounter].identifier_to_vcard=vcardfile_identifier_sim[iCounter];   	        
	  	         mid_identifier[0]=vgs.file_operation_list[iListCounter].identifier[0];
	  	         mid_identifier[1]=vgs.file_operation_list[iListCounter].identifier[1];
	  	         iListCounter++;
	  	   }
	  	   else 
	  	   if (vcardfile_identifier_sim[iCounter].length==2){
	  	   	    if (!(   
	  	   	  	  	   (mid_identifier[0]==vcardfile_identifier_sim[iCounter].identifier1[0])&&
	  	   	  	  	   (mid_identifier[1]==vcardfile_identifier_sim[iCounter].identifier1[1])
	  	   	  	  	 ))  {
	  	    	               vgs.file_operation_list[iListCounter].identifier[0]=vcardfile_identifier_sim[iCounter].identifier1[0];
	  	                     vgs.file_operation_list[iListCounter].identifier[1]=vcardfile_identifier_sim[iCounter].identifier1[1];
	  	                     vgs.file_operation_list[iListCounter].operation_property=OPERATION_PROPERTY_CHANGE_DIR;
	  	                     iListCounter++;
	  	       }
	  	         vgs.file_operation_list[iListCounter].identifier[0]=vcardfile_identifier_sim[iCounter].identifier2[0];
	  	         vgs.file_operation_list[iListCounter].identifier[1]=vcardfile_identifier_sim[iCounter].identifier2[1];
	  	         vgs.file_operation_list[iListCounter].operation_property=OPERATION_PROPERTY_GENERATION_VCARD;
	  	          //保存内容用于生成Vcard中的identifier长度和内容
	  	         vgs.file_operation_list[iListCounter].identifier_to_vcard=vcardfile_identifier_sim[iCounter]; 
	  	         iListCounter++; 	
	  	         vgs.file_operation_list[iListCounter].identifier[0]=vcardfile_identifier_sim[iCounter].identifier1[0];  //回到无同名Identifier
	  	         vgs.file_operation_list[iListCounter].identifier[1]=vcardfile_identifier_sim[iCounter].identifier1[1];
	  	         vgs.file_operation_list[iListCounter].operation_property=OPERATION_PROPERTY_CHANGE_DIR;
	  	         mid_identifier[0]=vgs.file_operation_list[iListCounter].identifier[0];
	  	         mid_identifier[1]=vgs.file_operation_list[iListCounter].identifier[1];
	  	         iListCounter++;         
	  	   }	
	  	   else 
	  	   if (vcardfile_identifier_sim[iCounter].length==3){
	  	   	    if (!(   
	  	   	  	  	   (mid_identifier[0]==vcardfile_identifier_sim[iCounter].identifier1[0])&&
	  	   	  	  	   (mid_identifier[1]==vcardfile_identifier_sim[iCounter].identifier1[1])
	  	   	  	  	 ))  {
	  	               	   vgs.file_operation_list[iListCounter].identifier[0]=vcardfile_identifier_sim[iCounter].identifier1[0];
	  	                   vgs.file_operation_list[iListCounter].identifier[1]=vcardfile_identifier_sim[iCounter].identifier1[1];
	  	                   vgs.file_operation_list[iListCounter].operation_property=OPERATION_PROPERTY_CHANGE_DIR;
	  	                   iListCounter++;
	  	             }
	  	         vgs.file_operation_list[iListCounter].identifier[0]=vcardfile_identifier_sim[iCounter].identifier2[0];
	  	         vgs.file_operation_list[iListCounter].identifier[1]=vcardfile_identifier_sim[iCounter].identifier2[1];
	  	         vgs.file_operation_list[iListCounter].operation_property=OPERATION_PROPERTY_CHANGE_DIR;
	  	         iListCounter++; 	
	  	         vgs.file_operation_list[iListCounter].identifier[0]=vcardfile_identifier_sim[iCounter].identifier3[0];
	  	         vgs.file_operation_list[iListCounter].identifier[1]=vcardfile_identifier_sim[iCounter].identifier3[1];
	  	         vgs.file_operation_list[iListCounter].operation_property=OPERATION_PROPERTY_GENERATION_VCARD;
	  	         //保存内容用于生成Vcard中的identifier长度和内容
	  	         vgs.file_operation_list[iListCounter].identifier_to_vcard=vcardfile_identifier_sim[iCounter]; 	  	         
	  	         iListCounter++; 
	  	         vgs.file_operation_list[iListCounter].identifier[0]=vcardfile_identifier_sim[iCounter].identifier2[0];  //回到无同名Identifier
	  	         vgs.file_operation_list[iListCounter].identifier[1]=vcardfile_identifier_sim[iCounter].identifier2[1];
	  	         vgs.file_operation_list[iListCounter].operation_property=OPERATION_PROPERTY_CHANGE_DIR;
	  	         iListCounter++;   
	  	         vgs.file_operation_list[iListCounter].identifier[0]=vcardfile_identifier_sim[iCounter].identifier1[0];  //回到无同名Identifier
	  	         vgs.file_operation_list[iListCounter].identifier[1]=vcardfile_identifier_sim[iCounter].identifier1[1];
	  	         vgs.file_operation_list[iListCounter].operation_property=OPERATION_PROPERTY_CHANGE_DIR;
	  	         mid_identifier[0]=vgs.file_operation_list[iListCounter].identifier[0];
	  	         mid_identifier[1]=vgs.file_operation_list[iListCounter].identifier[1];
	  	         iListCounter++;       
	  	   }	
	  	
	  	    
	  	    if( iCounter<sizeof(vcardfile_identifier_sim)/sizeof(alltype_vcard_identifier_t)-1){
	  	    	  if (!((mid_identifier[0]==vcardfile_identifier_sim[iCounter+1].identifier1[0])&&\
	  	    	   	    (mid_identifier[1]==vcardfile_identifier_sim[iCounter+1].identifier1[1])))
    		   	       if ((retvalue=CheckNextFileThrough_Sim(mid_identifier, vcardfile_identifier_sim[iCounter+1].identifier1))==0){	 	 
    		   	 	              vgs.ucStatusCode=STATUS_NEXTFILENOTHROUGH; 	  		     	 		     	 	 	     	                        
                            tmp_identifier[0] = vcardfile_identifier_sim[iCounter+1].identifier1[0];
                            tmp_identifier[1] = vcardfile_identifier_sim[iCounter+1].identifier1[1];   
                            for (tmpCounter=0;tmpCounter<SIMFILEPATHDEEPTH;tmpCounter++){
                          	    if (GetFileParent_Sim(tmp_identifier,&(path_identifier[tmpCounter]))==1){
                          	    	    if ((retvalue=CheckNextFileThrough_Sim(mid_identifier,  path_identifier[tmpCounter]))==1)
                          	                  break;
                          	           else {
                          	           	        if (retvalue<0){
                          	           	        	   std::cout<<YELLOW<<"Warning! CheckNextFileThroughSim fail1"<<RESET<<std::endl<<std::flush;	
                            	                       return -1;	
                          	           	        	}
                          	           }       	                          	                
                            	  }
                            	  else  {                          	  	    
                            	  	    	 std::cout<<YELLOW<<"Warning! GetFileParent fail"<<RESET<<std::endl<<std::flush;	
                            	  	    	 return -1;	 
                            	  }	
                            	  tmp_identifier[0]=	path_identifier[tmpCounter][0]; 
                            	  tmp_identifier[1]=	path_identifier[tmpCounter][1]; 
                          }
                          if (tmpCounter==SIMFILEPATHDEEPTH){    // 没有找到2个文件的转换路径
                          	    std::cout<<YELLOW<<"Warning! Can not find PATH File A -> File B"<<RESET<<std::endl<<std::flush;	
                          	    vgs.ucStatusCode=ERROR_NOPATHTONEXTFILE;
                            	  return -1;	 
                          }	
                          else	{  	                             
                                    do{
  
    		     	 	 	    	                vgs.file_operation_list[iListCounter].identifier[0]=path_identifier[tmpCounter][0];
    	                                  vgs.file_operation_list[iListCounter].identifier[1]=path_identifier[tmpCounter][1];
    	                                  vgs.file_operation_list[iListCounter].operation_property=OPERATION_PROPERTY_CHANGE_DIR;	  		     	 	 	    	               
    	                                  iListCounter++;
    	                                  tmpCounter--;
    		     	 	 	    	            }	while (tmpCounter>=0);
                          }	                          	    	    
                   }  		     	 	 
              		 else {  		     	 	 	       
     	 	 	        	      if (retvalue<0){ 	  		     	 	 	           
                               std::cout<<YELLOW<<"Warning! CheckNextFileThroughSim fail"<<RESET<<std::endl<<std::flush;	
                     	        return -1;	
                     	    } 
                   }		 	  		     	 		  		
          }	  	
	 } 
	 //vgs.file_operation_list[iListCounter].identifier[0] = MF_IDENTIFIER;        //读完Sim Card 后 将Card 文件指针设到初值
     vgs.file_operation_list[iListCounter].identifier[0] = 0x3F;
     vgs.file_operation_list[iListCounter].identifier[1] = 0x00;
	 vgs.file_operation_list[iListCounter].operation_property=OPERATION_PROPERTY_CHANGE_DIR;	
	return 1;
	}

/**************************************************************************** 
* 函数名称 : GenOperationFileList_Uim
* 类       ：VcardGenerator
* 功能描述 : 产生Vcard 操作列表(Uim mode)，填入file_operation_list
* 参    数 : 
* 参    数 : 
* 参    数 : 
* 返 回 值 : 可以 返回 1  不可以 返回 -1
* 作    者 : 王翔
* 设计日期 : 
* 修改日期		  修改人		   修改内容  
 *****************************************************************************/
int VcardGenerator::GenOperationFileList_Uim(){  //CDMA
	  int iCounter,iListCounter,tmpCounter,retvalue;
	  unsigned char tmp_identifier[2],path_identifier[SIMFILEPATHDEEPTH][2];
	 
	 // int tmpInnerConuter;  
	  unsigned char mid_identifier[2]=MF_IDENTIFIER;
	  if (ValidVCardIdentifierList(vcard_file_property_list_Uim,sizeof(vcard_file_property_list_Uim)/sizeof(vcard_file_property_t),\
	     vcardfile_identifier_uim, sizeof(vcardfile_identifier_uim)/sizeof(alltype_vcard_identifier_t))!=1)
	     return -1;  
	     
	  iListCounter=0;
	  for (iCounter=0;iCounter<sizeof(vcardfile_identifier_uim)/sizeof(alltype_vcard_identifier_t);iCounter++){
	  	 //   for (tmpInnerConuter=0;tmpInnerConuter<vcardfile_identifier_uim[iCounter].length-1;tmpInnerConuter++){
	  	   if (vcardfile_identifier_uim[iCounter].length==1){
	  	    	   vgs.file_operation_list[iListCounter].identifier[0]=vcardfile_identifier_uim[iCounter].identifier1[0];
	  	         vgs.file_operation_list[iListCounter].identifier[1]=vcardfile_identifier_uim[iCounter].identifier1[1];
	  	         vgs.file_operation_list[iListCounter].operation_property=OPERATION_PROPERTY_GENERATION_VCARD;
	  	          //保存内容用于生成Vcard中的identifier长度和内容
	  	         vgs.file_operation_list[iListCounter].identifier_to_vcard=vcardfile_identifier_uim[iCounter];   	        
	  	         mid_identifier[0]=vgs.file_operation_list[iListCounter].identifier[0];
	  	         mid_identifier[1]=vgs.file_operation_list[iListCounter].identifier[1];
	  	         iListCounter++;
	  	   }
	  	   else 
	  	   if (vcardfile_identifier_uim[iCounter].length==2){
	  	   	  
	  	   	  	  if (!(   
	  	   	  	  	   (mid_identifier[0]==vcardfile_identifier_uim[iCounter].identifier1[0])&&
	  	   	  	  	   (mid_identifier[1]==vcardfile_identifier_uim[iCounter].identifier1[1])
	  	   	  	  	 ))  {
	  	   	  	
	  	   	  	 
	  	                	   vgs.file_operation_list[iListCounter].identifier[0]=vcardfile_identifier_uim[iCounter].identifier1[0];
	  	                     vgs.file_operation_list[iListCounter].identifier[1]=vcardfile_identifier_uim[iCounter].identifier1[1];
	  	                     vgs.file_operation_list[iListCounter].operation_property=OPERATION_PROPERTY_CHANGE_DIR;
	  	                     iListCounter++;
	  	                 }
	  	         vgs.file_operation_list[iListCounter].identifier[0]=vcardfile_identifier_uim[iCounter].identifier2[0];
	  	         vgs.file_operation_list[iListCounter].identifier[1]=vcardfile_identifier_uim[iCounter].identifier2[1];
	  	         vgs.file_operation_list[iListCounter].operation_property=OPERATION_PROPERTY_GENERATION_VCARD;
	  	          //保存内容用于生成Vcard中的identifier长度和内容
	  	         vgs.file_operation_list[iListCounter].identifier_to_vcard=vcardfile_identifier_uim[iCounter]; 
	  	         iListCounter++; 	
	  	         vgs.file_operation_list[iListCounter].identifier[0]=vcardfile_identifier_uim[iCounter].identifier1[0];  //回到无同名Identifier
	  	         vgs.file_operation_list[iListCounter].identifier[1]=vcardfile_identifier_uim[iCounter].identifier1[1];
	  	         vgs.file_operation_list[iListCounter].operation_property=OPERATION_PROPERTY_CHANGE_DIR;
	  	         mid_identifier[0]=vgs.file_operation_list[iListCounter].identifier[0];
	  	         mid_identifier[1]=vgs.file_operation_list[iListCounter].identifier[1];
	  	         iListCounter++;         
	  	   }	
	  	   else 
	  	   if (vcardfile_identifier_uim[iCounter].length==3){
	  	   	   if (!(   
	  	   	  	  	   (mid_identifier[0]==vcardfile_identifier_uim[iCounter].identifier1[0])&&
	  	   	  	  	   (mid_identifier[1]==vcardfile_identifier_uim[iCounter].identifier1[1])
	  	   	  	  	 ))  {
	  	                	   vgs.file_operation_list[iListCounter].identifier[0]=vcardfile_identifier_uim[iCounter].identifier1[0];
	  	                     vgs.file_operation_list[iListCounter].identifier[1]=vcardfile_identifier_uim[iCounter].identifier1[1];
	  	                     vgs.file_operation_list[iListCounter].operation_property=OPERATION_PROPERTY_CHANGE_DIR;
	  	                     iListCounter++;
	  	              }
	  	         vgs.file_operation_list[iListCounter].identifier[0]=vcardfile_identifier_uim[iCounter].identifier2[0];
	  	         vgs.file_operation_list[iListCounter].identifier[1]=vcardfile_identifier_uim[iCounter].identifier2[1];
	  	         vgs.file_operation_list[iListCounter].operation_property=OPERATION_PROPERTY_CHANGE_DIR;
	  	         iListCounter++; 	
	  	         vgs.file_operation_list[iListCounter].identifier[0]=vcardfile_identifier_uim[iCounter].identifier3[0];
	  	         vgs.file_operation_list[iListCounter].identifier[1]=vcardfile_identifier_uim[iCounter].identifier3[1];
	  	         vgs.file_operation_list[iListCounter].operation_property=OPERATION_PROPERTY_GENERATION_VCARD;
	  	         //保存内容用于生成Vcard中的identifier长度和内容
	  	         vgs.file_operation_list[iListCounter].identifier_to_vcard=vcardfile_identifier_uim[iCounter]; 	  	         
	  	         iListCounter++; 
	  	         vgs.file_operation_list[iListCounter].identifier[0]=vcardfile_identifier_uim[iCounter].identifier2[0];  //回到无同名Identifier
	  	         vgs.file_operation_list[iListCounter].identifier[1]=vcardfile_identifier_uim[iCounter].identifier2[1];
	  	         vgs.file_operation_list[iListCounter].operation_property=OPERATION_PROPERTY_CHANGE_DIR;
	  	         iListCounter++;   
	  	         vgs.file_operation_list[iListCounter].identifier[0]=vcardfile_identifier_uim[iCounter].identifier1[0];  //回到无同名Identifier
	  	         vgs.file_operation_list[iListCounter].identifier[1]=vcardfile_identifier_uim[iCounter].identifier1[1];
	  	         vgs.file_operation_list[iListCounter].operation_property=OPERATION_PROPERTY_CHANGE_DIR;
	  	         mid_identifier[0]=vgs.file_operation_list[iListCounter].identifier[0];
	  	         mid_identifier[1]=vgs.file_operation_list[iListCounter].identifier[1];
	  	         iListCounter++;       
	  	   }	
	  	  
	  	    if( iCounter<sizeof(vcardfile_identifier_uim)/sizeof(alltype_vcard_identifier_t)-1){
	  	    	  if (!((mid_identifier[0]==vcardfile_identifier_uim[iCounter+1].identifier1[0])&&\
	  	    	   	    (mid_identifier[1]==vcardfile_identifier_uim[iCounter+1].identifier1[1])))
    		   	     //  if ((retvalue=CheckNextFileThrough_Uim(vcardfile_identifier_uim[iCounter], vcardfile_identifier_uim[iCounter+1]))==0){	
    		   	       if ((retvalue=CheckNextFileThrough_Uim(mid_identifier, vcardfile_identifier_uim[iCounter+1].identifier1))==0){	 	 
    		   	 	              vgs.ucStatusCode=STATUS_NEXTFILENOTHROUGH; 	  		     	 		     	 	 	     	                        
                            tmp_identifier[0] = vcardfile_identifier_uim[iCounter+1].identifier1[0];
                            tmp_identifier[1] = vcardfile_identifier_uim[iCounter+1].identifier1[1];   
                            for (tmpCounter=0;tmpCounter<SIMFILEPATHDEEPTH;tmpCounter++){
                          	    if (GetFileParent_Uim(tmp_identifier,&(path_identifier[tmpCounter]))==1){
                          	    	    // if ((retvalue=CheckNextFileThrough_Uim(vcardfile_identifier_uim[iCounter],  path_identifier[tmpCounter]))==1)
                          	    	    if ((retvalue=CheckNextFileThrough_Uim(mid_identifier,  path_identifier[tmpCounter]))==1)
                          	                  break;
                          	           else {
                          	           	        if (retvalue<0){
                          	           	        	   std::cout<<YELLOW<<"Warning! CheckNextFileThroughUim fail1"<<RESET<<std::endl<<std::flush;	
                            	                       return -1;	
                          	           	        	}
                          	           }       	                          	                
                            	  }
                            	  else  {                          	  	    
                            	  	    	 std::cout<<YELLOW<<"Warning! GetFileParent fail"<<RESET<<std::endl<<std::flush;	
                            	  	    	 return -1;	 
                            	  }	
                            	  tmp_identifier[0]=	path_identifier[tmpCounter][0]; 
                            	  tmp_identifier[1]=	path_identifier[tmpCounter][1]; 
                          }
                          if (tmpCounter==SIMFILEPATHDEEPTH){    // 没有找到2个文件的转换路径
                          	    std::cout<<YELLOW<<"Warning! Can not find PATH File A -> File B"<<RESET<<std::endl<<std::flush;	
                          	    vgs.ucStatusCode=ERROR_NOPATHTONEXTFILE;
                            	  return -1;	 
                          }	
                          else	{  	                             
                                    do{
  
    		     	 	 	    	                vgs.file_operation_list[iListCounter].identifier[0]=path_identifier[tmpCounter][0];
    	                                  vgs.file_operation_list[iListCounter].identifier[1]=path_identifier[tmpCounter][1];
    	                                  vgs.file_operation_list[iListCounter].operation_property=OPERATION_PROPERTY_CHANGE_DIR;	  		     	 	 	    	               
    	                                  iListCounter++;
    	                                  tmpCounter--;
    		     	 	 	    	            }	while (tmpCounter>=0);
                          }	                          	    	    
                   }  		     	 	 
          		     else {  		     	 	 	       
      	 	 	        	    if (retvalue<0){ 	  		     	 	 	           
                                std::cout<<YELLOW<<"Warning! CheckNextFileThroughUim fail"<<RESET<<std::endl<<std::flush;	
                      	        return -1;	
                      	  } 
                   }		 	  		     	 		  		
       }	  	
	 } 
	 //vgs.file_operation_list[iListCounter].identifier=MF_IDENTIFIER;        //读完Sim Card 后 将Card 文件指针设到初值
     vgs.file_operation_list[iListCounter].identifier[0] = 0x3F;                                                                                                            
     vgs.file_operation_list[iListCounter].identifier[1] = 0x00;
	 vgs.file_operation_list[iListCounter].operation_property=OPERATION_PROPERTY_CHANGE_DIR;	
	return 1;
}

/**************************************************************************** 
* 函数名称 : GenOperationFileList_Usim
* 类       ：VcardGenerator
* 功能描述 : 产生Vcard 操作列表(Usim mode)，填入file_operation_list
* 参    数 : 
* 参    数 : 
* 参    数 : 
* 返 回 值 : 可以 返回 1  不可以 返回 -1
* 作    者 : 王翔
* 设计日期 : 
* 修改日期		  修改人		   修改内容  
 *****************************************************************************/
int VcardGenerator::GenOperationFileList_USim(){    //采用带路径访问模式，不需要转换路径
	
	  int iCounter,iListCounter,tmpCounter,retvalue;
	  unsigned char tmp_identifier[2],path_identifier[SIMFILEPATHDEEPTH][2];
	  	    
	  iListCounter=0;
//	  for (iCounter=0;iCounter<sizeof(usim_vcard_identifier)/sizeof(alltype_vcard_identifier_t);iCounter++){
	   for (iListCounter=0;iListCounter<sizeof(usim_vcard_identifier)/sizeof(alltype_vcard_identifier_t);iListCounter++){	
	  	    vgs.Usim_file_operation_list[iListCounter].length=(usim_vcard_identifier[iListCounter].length)*2;
	  	   
	  	    if (vgs.Usim_file_operation_list[iListCounter].length>6){
	  	    	     std::cout<<YELLOW<<"Warning! vgs.Usim_file_operation_list length overflow"<<RESET<<std::endl<<std::flush;	
	               vgs.ucStatusCode=ERROR_SIM_FILE_OPERATION_LIST_LENGTH_OVERFLOW;
	               return -1;	 
	  	    }	  	    	
	  	    vgs.Usim_file_operation_list[iListCounter].identifier[0]=usim_vcard_identifier[iListCounter].identifier1[0];
	  	    vgs.Usim_file_operation_list[iListCounter].identifier[1]=usim_vcard_identifier[iListCounter].identifier1[1];
	  	   
	  	    if (vgs.Usim_file_operation_list[iListCounter].length==4){
	  	    	   vgs.Usim_file_operation_list[iListCounter].identifier[2]=usim_vcard_identifier[iListCounter].identifier2[0];
	  	         vgs.Usim_file_operation_list[iListCounter].identifier[3]=usim_vcard_identifier[iListCounter].identifier2[1];
	  	    	
	  	    }
	  	    
	  	    if (vgs.Usim_file_operation_list[iListCounter].length==6){
	  	    	   vgs.Usim_file_operation_list[iListCounter].identifier[2]=usim_vcard_identifier[iListCounter].identifier2[0];
	  	         vgs.Usim_file_operation_list[iListCounter].identifier[3]=usim_vcard_identifier[iListCounter].identifier2[1];
	  	         vgs.Usim_file_operation_list[iListCounter].identifier[4]=usim_vcard_identifier[iListCounter].identifier3[0];
	  	         vgs.Usim_file_operation_list[iListCounter].identifier[5]=usim_vcard_identifier[iListCounter].identifier3[1];
	  	    	
	  	    	}	
	  	   //20180706  增加 ridtype
	  	    	   vgs.Usim_file_operation_list[iListCounter].ridtype=usim_vcard_identifier[iListCounter].ridtype;
	  	    	       	
	  	    vgs.Usim_file_operation_list[iListCounter].operation_property=OPERATION_PROPERTY_GENERATION_VCARD;
	  	    if ((vgs.Usim_file_operation_list[iListCounter].identifier[0]==0x3F)&&\
	  	    	(vgs.Usim_file_operation_list[iListCounter].identifier[1]==0x0)){
	  	        if (vgs.Usim_file_operation_list[iListCounter].length>2){
	  	        	std::cout<<YELLOW<<"Warning! Usim_file_operation_list should not include MF"<<RESET<<std::endl<<std::flush;	
	               vgs.ucStatusCode=ERROR_SIM_FILE_OPERATION_LIST_MF_EXPLICIT;
	               return -1;	 
	  	        	
	  	        	}
	  	        else{
	  	        	  memcpy(vgs.Usim_file_operation_list[iListCounter].select_command,usimselect_pathByFidReturnFcp,4);
	  	        	 
                 
	  	        	}	  	        	  	          	
	  	    }
	  	    else{
	  	    	    memcpy(vgs.Usim_file_operation_list[iListCounter].select_command,usimselect_pathfromMfReturnFcp,4);
	  	    	    
	  	    	}
	  	     vgs.Usim_file_operation_list[iListCounter].select_command[4]=vgs.Usim_file_operation_list[iListCounter].length;
	  	   
	  	  //  iListCounter++;	  	    	  	   	 
	 } 
	 vgs.Usim_file_operation_list[iListCounter].identifier[0]=0x3F;        //读完Sim Card 后 将Card 文件指针设到初值
	 vgs.Usim_file_operation_list[iListCounter].identifier[1]=0x0;        //读完Sim Card 后 将Card 文件指针设到初值 
	 vgs.Usim_file_operation_list[iListCounter].length=2;
	 memcpy(vgs.Usim_file_operation_list[iListCounter].select_command,usimselect_pathByFidReturnFcp,4);
	 vgs.Usim_file_operation_list[iListCounter].select_command[4]=2;
	 vgs.Usim_file_operation_list[iListCounter].operation_property=OPERATION_PROPERTY_CHANGE_DIR;	
	 //20180706 赋值nextridtype ，为不同AID 同名文件选择
	 if (sizeof(usim_vcard_identifier)/sizeof(alltype_vcard_identifier_t)>1)
	     for (iListCounter=0;iListCounter<sizeof(usim_vcard_identifier)/sizeof(alltype_vcard_identifier_t)-1;iListCounter++){	
	     	   vgs.Usim_file_operation_list[iListCounter].nextridtype= vgs.Usim_file_operation_list[iListCounter+1].ridtype;
	      }
	  vgs.Usim_file_operation_list[iListCounter].nextridtype= RIDTYPE_NONEEDAID;
	 
	return 1;
	
}
//GenOperationFileList 根据generatevcardmode 产生Vcard 操作列表
/*
int VcardGenerator::GenOperationFileList(unsigned char generatevcardmode){	
	
       if (generatevcardmode & GENERATE_VCARD_MODE_UIM){   //暂时CDMA 只支持GSM11.11兼容命令
				    std::cout<<GREEN<<"GenOperationFileList --------UIM"<<RESET<<std::endl<<std::flush;	 
				  	if (GenOperationFileList_Uim()==-1)
				  		  return -1;       	 
				  		  
				   		
				  	   memcpy(vgs.ucApduSendBuf,command_select,5);	
        	      vgs.usApduSendLength=5;	
         	     vgs.ucCurrentApduOperation=APDU_SELECT_COMMAND;			 
               vgs.ucWaitGetInteractiveStartTime=GetTickCount();	           
             	 vgs.ucCurrentHandleCardMode=CARDMODE_UIM;	
             		  		  
	     }
	     else {  
				  if (generatevcardmode & GENERATE_VCARD_MODE_USIM){
				    std::cout<<GREEN<<"GenOperationFileList --------USIM"<<RESET<<std::endl<<std::flush;	 
				  	if (GenOperationFileList_USim()==-1)
				  		  return -1; 
				    
				    memcpy(vgs.ucApduSendBuf,vgs.Usim_file_operation_list[0].select_command,5);	
				 	   vgs.usApduSendLength=5;	
         	   vgs.ucCurrentApduOperation=APDU_SELECT_COMMAND;			 
             vgs.ucWaitGetInteractiveStartTime=GetTickCount();	 	
             vgs.ucCurrentHandleCardMode=CARDMODE_USIM;	
             vgs.ucHandleMode|=CARDMODE_USIM;	 
				  		  	   
				  }
				 if (generatevcardmode & GENERATE_VCARD_MODE_SIM){
				     std::cout<<GREEN<<"GenOperationFileList --------Sim"<<RESET<<std::endl<<std::flush;
				  	if (GenOperationFileList_Sim()==-1)
				  		  return -1;  
				  		  
				  	 vgs.ucHandleMode|=CARDMODE_SIM;	
				  	 	  
				  	 if (!(vgs.ucHandleMode&CARDMODE_USIM)) { // 如果模式不支持 USIM ，则直接将当前模式设为Sim      		
				  	   memcpy(vgs.ucApduSendBuf,command_select,5);	
        	      vgs.usApduSendLength=5;	
         	     vgs.ucCurrentApduOperation=APDU_SELECT_COMMAND;			 
               vgs.ucWaitGetInteractiveStartTime=GetTickCount();	           
             	 vgs.ucCurrentHandleCardMode=CARDMODE_SIM;	
             	} 	  
				  
	        }
	     }
return 1;   
}
*/
int VcardGenerator::GenOperationFileList(unsigned char generatevcardmode){	
	
       
	   
				  if (generatevcardmode & GENERATE_VCARD_MODE_USIM){
				    std::cout<<GREEN<<"GenOperationFileList --------USIM"<<RESET<<std::endl<<std::flush;	 
				  	if (GenOperationFileList_USim()==-1)
				  		  return -1; 
				    
				    memcpy(vgs.ucApduSendBuf,vgs.Usim_file_operation_list[0].select_command,5);	
				 	   vgs.usApduSendLength=5;	
         	   vgs.ucCurrentApduOperation=APDU_SELECT_COMMAND;			 
             vgs.ucWaitGetInteractiveStartTime=GetTickCount();	 	
             vgs.ucCurrentHandleCardMode=CARDMODE_USIM;	
             vgs.ucHandleMode|=CARDMODE_USIM;	 
				  		  	   
				  }
				 if (generatevcardmode & GENERATE_VCARD_MODE_SIM){
				     std::cout<<GREEN<<"GenOperationFileList --------Sim"<<RESET<<std::endl<<std::flush;
				  	if (GenOperationFileList_Sim()==-1)
				  		  return -1;  
				  		  
				  	 vgs.ucHandleMode|=CARDMODE_SIM;	
				  	 	  
				  	 if (!(vgs.ucHandleMode&CARDMODE_USIM)) { // 如果模式不支持 USIM ，则直接将当前模式设为Sim      		
				  	   memcpy(vgs.ucApduSendBuf,command_select,5);	
        	      vgs.usApduSendLength=5;	
         	     vgs.ucCurrentApduOperation=APDU_SELECT_COMMAND;			 
               vgs.ucWaitGetInteractiveStartTime=GetTickCount();	           
             	 vgs.ucCurrentHandleCardMode=CARDMODE_SIM;	
             	} 	  
				  
	        }
	        else {  
	          if (generatevcardmode & GENERATE_VCARD_MODE_UIM){   
				         std::cout<<GREEN<<"GenOperationFileList --------UIM"<<RESET<<std::endl<<std::flush;	 
				  	if (GenOperationFileList_Uim()==-1)
				  		  return -1;       	 
				  	vgs.ucHandleMode|=CARDMODE_UIM;	
				  	  
				   	if (!(vgs.ucHandleMode&CARDMODE_USIM)) { // 如果模式不支持 USIM ，则直接将当前模式设为Uim 	
				  	   memcpy(vgs.ucApduSendBuf,command_select,5);	
        	      vgs.usApduSendLength=5;	
         	     vgs.ucCurrentApduOperation=APDU_SELECT_COMMAND;			 
               vgs.ucWaitGetInteractiveStartTime=GetTickCount();	           
             	 vgs.ucCurrentHandleCardMode=CARDMODE_UIM;	
            } 		  		  
	        }
	        
	       }
return 1;   
}
/**************************************************************************** 
* 函数名称 : VcardGeneratorInit
* 类       ：VcardGenerator
* 功能描述 : 初始化 ：VcardGenerator
* 参    数 : vcardsource ：Vcard 内容源 （Card /数据库）
* 参    数 : transmissionprotocol 传输协议（ T=0 ，T=1）
* 参    数 : generatevcardmode 卡生成模式：UIM／SIM／USIM（UIM只支持独立模式）
* 参    数 : 
* 返 回 值 : 成功 返回 1  不成功 返回 -1
* 作    者 : 王翔
* 设计日期 : 
* 修改日期		  修改人		   修改内容  
 *****************************************************************************/

int VcardGenerator::VcardGeneratorInit(unsigned char vcardsource,unsigned char transmissionprotocol, unsigned char generatevcardmode){ 
     
   	 int a;
   	 unsigned short tmpoffset;
     memset(&vgs, 0, sizeof(vcard_generator_t));
    // if (!GenOperationFileList())
 
     if (transmissionprotocol==SIMCARD_TRANSMISSION_PROTOCOL_T1){
     	    vgs.ucSimcardTransmissionProtocol=SIMCARD_TRANSMISSION_PROTOCOL_T1;
     	    vgs.ucVcardGeneratorStatus=VCARD_GENERATOR_STATUS_UNSUITABLE;
     	    std::cout<<YELLOW<<"Warning! Can not suitble for T=1 TransmissionProtocol "<<RESET<<std::endl<<std::flush;	    
     }
     else{    	     
     	      if (vcardsource==VCARD_SOURCE_DISK){
     	      	   vgs.ucVcardSource=VCARD_SOURCE_DISK;
     	      	   vgs.ucVcardGeneratorStatus=VCARD_GENERATOR_STATUS_FROM_DISK_PROCESSING;
     	      	   std::cout<<GREEN<<" Source from Disk! "<<RESET<<std::endl<<std::flush;	
     	      	}
     	      else{
     	      	 
     	      	   if (GenOperationFileList(generatevcardmode)==-1)
    	   		         return -1;  
     	      	   
                 //初始化VCard 固定部分
                 vgs.ucVcardBuf[OFFSET_VCARD_MAINTAIN_INFORMATION_VERSION]=VG_VERSION_MAINTAIN; //VG 版本
                 if (vgs.ucHandleMode&CARDMODE_USIM)
                         vgs.ucVcardBuf[OFFSET_VCARD_MAINTAIN_INFORMATION]|=VG_HANDLEICC_USIMMODE_MAINTAIN;
                 if (vgs.ucHandleMode&CARDMODE_SIM)          
                         vgs.ucVcardBuf[OFFSET_VCARD_MAINTAIN_INFORMATION]|=VG_HANDLEICC_SIMMODE_MAINTAIN;

                 if (vgs.ucHandleMode&CARDMODE_UIM)          
                         vgs.ucVcardBuf[OFFSET_VCARD_MAINTAIN_INFORMATION]|=VG_HANDLEICC_UIMMODE_MAINTAIN; 
                 vgs.ucVcardBuf[1]=DEEPTH_VCARD_MAINTAIN_INFORMATION;  
                 
                  //TODO 加入ATR部分 ，并修改Vcard 长度字节组 
                
                 // 取出Vcard 长度
                 if (FreshLengthAndReturnValue(vgs.ucVcardBuf,0, &tmpoffset)==-1)
                   	return -1;
                   	
                 if (vgs.ucCurrentHandleCardMode&CARDMODE_USIM){
                          vgs.ulOffset_VcardCurrentUsimGroupTag =tmpoffset+2; //2 为Vcard长度所占字节数
                          vgs.ucVcardBuf[vgs.ulOffset_VcardCurrentUsimGroupTag] =TAG_VCARDCURRENTUSIMGROUP;
                 }
                 else{
                 	      if (vgs.ucCurrentHandleCardMode&CARDMODE_SIM){
                 	         vgs.ulOffset_VcardCurrentSimGroupTag =tmpoffset+2; //2 为Vcard长度所占字节数
                 	         vgs.ucVcardBuf[vgs.ulOffset_VcardCurrentSimGroupTag] =TAG_VCARDCURRENTSIMGROUP;
                 	      }
                 	      else{
                 	      	
                 	      	   if (vgs.ucCurrentHandleCardMode&CARDMODE_UIM){                 	    
                 	               vgs.ulOffset_VcardCurrentSimGroupTag =tmpoffset+2; //2 为Vcard长度所占字节数
                 	               vgs.ucVcardBuf[vgs.ulOffset_VcardCurrentSimGroupTag] =TAG_VCARDCURRENTUIMGROUP;
                 	           }
                 	      	
                 	      } 
                 	       
                 }
                 	
                 	// 更新Vcard 长度
                 if (FreshLengthAndReturnValue(vgs.ucVcardBuf,3, &tmpoffset)==-1)
                   	return -1;
                 	
                  
     	      }    	
     }   
     return 1;	 
     
}



int VcardGenerator::ProcessVcardGenerationT1(){
	//TODO
	return 1;
	}
int VcardGenerator::ProcessVcardGenerationT0FromDisk(){
	//TODO
	return 1;
	}		

/**************************************************************************** 
* 函数名称 : VerifyResponse
* 类       ：VcardGenerator
* 功能描述 : 检查响应是否正确，（在向Sim card 发送命令后，检查得到的响应）
* 参    数 : 
* 参    数 : 
* 参    数 : 
* 返 回 值 : 正确 返回 1  不正确 返回 -1
* 作    者 : 王翔
* 设计日期 : 
* 修改日期		  修改人		   修改内容  
 *****************************************************************************/
int VcardGenerator::VerifyResponse_Sim(){	
unsigned long tmpTimeCounter;		
vcard_file_property_t file1;	
     tmpTimeCounter=GetTickCount();
     if (tmpTimeCounter<vgs.ucWaitGetInteractiveStartTime)
     	       tmpTimeCounter+=0xFFFFFFFF-vgs.ucWaitGetInteractiveStartTime;
     	   else
     	   	   tmpTimeCounter=tmpTimeCounter-vgs.ucWaitGetInteractiveStartTime;
     if(tmpTimeCounter>GETIATIMEOUT){
     	  //  vgs.ucApduInteractiveStatus=AIAS_IDLE;
     	    std::cout<<RED<<"Warning! GET APDU TImeout"<<RESET<<std::endl<<std::flush;	
     	    vgs.ucStatusCode=ERROR_APDUTIMEOUT;
     	    return -1;
     	}
     	
		 switch(vgs.ucCurrentApduOperation)
  				{
  					
  		      case APDU_SELECT_COMMAND: 
  						             if ((vgs.ucApduReceiveBuf[0]==vgs.ucApduSendBuf[1])&&(vgs.usApduReceiveLength==1))
  						             	    return 1;				             
  		                     break;
  		      
  		      case APDU_SELECT_DATA: 
  						            if ((vgs.ucApduReceiveBuf[0]==SW1_9F)&&(!(vgs.ucApduReceiveBuf[1]==0))&&(vgs.usApduReceiveLength==2))  //response 9fxx
  						             	    return 1;
  						            else{
  						                if ((vgs.ucApduReceiveBuf[0]==SW1_94)&&(vgs.ucApduReceiveBuf[1]==SW2_04)&&(vgs.usApduReceiveLength==2))  //response 9404
  						                	//  if (GetVcardFileProperty(vgs.ucApduSendBuf, &file1))
  						                	 //20200330 处理Invaild card (MANDATORY 不存在）   if (GetVcardFileProperty(vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier, &file1)==1) 	
  						                	if (GetVcardFilePropertyWithPath_Sim(vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard, &file1)==1)
	   	                               	 {
	   	                               	     if (file1.property&FILE_OPTIONAl)
	   	                               	    	  std::cout<<YELLOW<<"Warning! Idntifier can not find"<<RESET<<std::endl<<std::flush;
	   	                               	     else 
	   	                               	        if (file1.property&FILE_MANDATORY){   //20200330 处理Invaild card
	   	                               	    	    std::cout<<RED<<"Note! MANDATORY Idntifier can not find"<<RESET<<std::endl<<std::flush;	
	   	                               	    	   // vgs.ucCurrentCardValid |=CARD_INVALID_SIM_MANDATORY_NOEXIST;
	   	                               	    	    vgs.ucVcardBuf[OFFSET_VCARD_MAINTAIN_INFORMATION]&= ~(VG_HANDLEICC_SIMMODE_MAINTAIN); 
	   	                               	    	    
	   	                               	    	  } 
	   	                               	     return 1;
	   	                               	 }
  						            }
  		                     break;
  		                      		                            
  		       case APDU_GET_RESPONSE: 
  						             if ((vgs.ucApduReceiveBuf[0]==0XC0)&&
  						             	   (((vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-2]==SW1_90)&&(vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-1]==SW2_00))||
  						             	   ((vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-2]==SW1_91)&&(!(vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-1]==0))))
  						             	   &&(vgs.usApduReceiveLength==vgs.ucCurrentFileHeaderLength+3))
  						             	   	return 1;
  						             break;
 
						case APDU_READ: 
  						             if ((vgs.ucApduReceiveBuf[0]==0XB0)&&
  						             	   (((vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-2]==SW1_90)&&(vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-1]==SW2_00))||
  						             	   ((vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-2]==SW1_91)&&(!(vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-1]==0))))
  						             	   &&(vgs.usApduReceiveLength==vgs.usCurrentFileBodyLength+3))
  						             	   	return 1;
 						             break;
						case APDU_READ_RECORD: 
  						             if ((vgs.ucApduReceiveBuf[0]==0XB2)&&
  						             	   (((vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-2]==SW1_90)&&(vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-1]==SW2_00))||
  						             	   ((vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-2]==SW1_91)&&(!(vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-1]==0))))
  						             	   &&(vgs.usApduReceiveLength==vgs.ucCurrentRecordLength+3))
  						             	   	return 1;
						             break;
  		    
            default:
            	           break;  
          }  
	  vgs.ucStatusCode=ERROR_UNRECOGNIZEDAPDUOPERATION;
	  return -1;
	}

int VcardGenerator::VerifyResponse_Uim(){	
unsigned long tmpTimeCounter;		
vcard_file_property_t file1;	
                           tmpTimeCounter=GetTickCount();
  						             if (tmpTimeCounter<vgs.ucWaitGetInteractiveStartTime)
  						             	       tmpTimeCounter+=0xFFFFFFFF-vgs.ucWaitGetInteractiveStartTime;
  						             	   else
  						             	   	   tmpTimeCounter=tmpTimeCounter-vgs.ucWaitGetInteractiveStartTime;
  						             if(tmpTimeCounter>GETIATIMEOUT){
  						             	  //  vgs.ucApduInteractiveStatus=AIAS_IDLE;
  						             	    std::cout<<RED<<"Warning! GET APDU TImeout"<<RESET<<std::endl<<std::flush;	
  						             	    vgs.ucStatusCode=ERROR_APDUTIMEOUT;
  						             	    return -1;
  						             	}
  						             	
		 switch(vgs.ucCurrentApduOperation)
  				{
  					
  		      case APDU_SELECT_COMMAND: 
  						             if ((vgs.ucApduReceiveBuf[0]==vgs.ucApduSendBuf[1])&&(vgs.usApduReceiveLength==1))
  						             	    return 1;				             
  		                     break;
  		      
  		      case APDU_SELECT_DATA: 
  						            if ((vgs.ucApduReceiveBuf[0]==SW1_9F)&&(!(vgs.ucApduReceiveBuf[1]==0))&&(vgs.usApduReceiveLength==2))  //response 9fxx
  						             	    return 1;
  						            else{
  						                  if ((vgs.ucApduReceiveBuf[0]==SW1_94)&&(vgs.ucApduReceiveBuf[1]==SW2_04)&&(vgs.usApduReceiveLength==2))  //response 9404
  						                	     if (GetVcardFilePropertyWithPath_Uim(vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard, &file1)==1)  						                	     	                                    
	   	                               	 {
	   	                               	     if (file1.property&FILE_OPTIONAl)
	   	                               	    	  std::cout<<YELLOW<<"Warning! Idntifier can not find"<<RESET<<std::endl<<std::flush;	
	   	                               	      else  
	   	                               	       if (file1.property&FILE_MANDATORY){    //20200330 处理Invaild card
	   	                               	    	    std::cout<<RED<<"Note! MANDATORY Idntifier can not find"<<RESET<<std::endl<<std::flush;	
	   	                               	    	   // vgs.ucCurrentCardValid |=CARD_INVALID_UIM_MANDATORY_NOEXIST;
	   	                               	    	    vgs.ucVcardBuf[OFFSET_VCARD_MAINTAIN_INFORMATION]&= ~(VG_HANDLEICC_UIMMODE_MAINTAIN);
	   	                               	    	  }
	   	                               	    	  return 1;
	   	                               	    	}
  						            }
  		                     break;
  		                      		                            
  		       case APDU_GET_RESPONSE: 
  						             if ((vgs.ucApduReceiveBuf[0]==0XC0)&&
  						             	   (((vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-2]==SW1_90)&&(vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-1]==SW2_00))||
  						             	   ((vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-2]==SW1_91)&&(!(vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-1]==0))))
  						             	   &&(vgs.usApduReceiveLength==vgs.ucCurrentFileHeaderLength+3))
  						             	   	return 1;
  						             break;
 
						case APDU_READ: 
  						             if ((vgs.ucApduReceiveBuf[0]==0XB0)&&
  						             	   (((vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-2]==SW1_90)&&(vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-1]==SW2_00))||
  						             	   ((vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-2]==SW1_91)&&(!(vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-1]==0))))
  						             	   &&(vgs.usApduReceiveLength==vgs.usCurrentFileBodyLength+3))
  						             	   	return 1;
 						             break;
						case APDU_READ_RECORD: 
  						             if ((vgs.ucApduReceiveBuf[0]==0XB2)&&
  						             	   (((vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-2]==SW1_90)&&(vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-1]==SW2_00))||
  						             	   ((vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-2]==SW1_91)&&(!(vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-1]==0))))
  						             	   &&(vgs.usApduReceiveLength==vgs.ucCurrentRecordLength+3))
  						             	   	return 1;
						             break;
  		    
            default:
            	           break;  
          }  
	  vgs.ucStatusCode=ERROR_UNRECOGNIZEDAPDUOPERATION;
	  return -1;
	}

int VcardGenerator::VerifyResponse_USim(){	
unsigned long tmpTimeCounter;		
vcard_file_property_t file1;	
                           tmpTimeCounter=GetTickCount();
  						             if (tmpTimeCounter<vgs.ucWaitGetInteractiveStartTime)
  						             	       tmpTimeCounter+=0xFFFFFFFF-vgs.ucWaitGetInteractiveStartTime;
  						             	   else
  						             	   	   tmpTimeCounter=tmpTimeCounter-vgs.ucWaitGetInteractiveStartTime;
  						             if(tmpTimeCounter>GETIATIMEOUT){
  						             	  //  vgs.ucApduInteractiveStatus=AIAS_IDLE;
  						             	    std::cout<<RED<<"Warning! GET APDU TImeout"<<RESET<<std::endl<<std::flush;	
  						             	    vgs.ucStatusCode=ERROR_APDUTIMEOUT;
  						             	    return -1;
  						             	}
  						             	
		 switch(vgs.ucCurrentApduOperation)
  				{
  					
  		      case APDU_SELECT_COMMAND: 
  						             if ((vgs.ucApduReceiveBuf[0]==vgs.ucApduSendBuf[1])&&(vgs.usApduReceiveLength==1))
  						             	    return 1;				             
  		                     break;
  		      
  		      case APDU_SELECT_DATA:      //TS102.221  '61' procedure byte
  						            if ((vgs.ucApduReceiveBuf[0]==SW1_61)&&(!(vgs.ucApduReceiveBuf[1]==0))&&(vgs.usApduReceiveLength==2))   { //response 61xx
									if (vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].ridtype==RIDTYPE_3GPP)
										vgs.ucCurrentUsimMode_Invalid|=USIMMODE_3GPP_FILE_EXIST;
									else if (vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].ridtype==RIDTYPE_3GPP2)
										vgs.ucCurrentUsimMode_Invalid|=USIMMODE_3GPP2_FILE_EXIST; 
									return 1;
  						             	  }
  						            else{        //TS102.221 section 10.2.1 Status conditions     
  						                if ((vgs.ucApduReceiveBuf[0]==SW1_6A)&&(vgs.ucApduReceiveBuf[1]==SW2_82)&&(vgs.usApduReceiveLength==2)){  //response 6a82
  						                	//  if (GetVcardFileProperty(vgs.ucApduSendBuf, &file1))
  						                	
  						                	    //20180708
  						                	    if (GetVcardFileProperty_WithUsimRidType(vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].length,\
  						                	    	 vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].identifier,\
  						                	    	  vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].ridtype,\
  						                	    	 &file1)==1) 
  						                	    {
	   	                               	    	 if (file1.property&FILE_OPTIONAl)
	   	                               	    	  std::cout<<YELLOW<<"Warning! Idntifier can not find"<<RESET<<std::endl<<std::flush;
	   	                               	    	  else
	   	                               	         if (file1.property&FILE_MANDATORY){    //20200330 处理Invaild card
	   	                               	    	       if (vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].ridtype==RIDTYPE_3GPP)
	   	                               	    	          vgs.ucCurrentUsimMode_Invalid|=USIMMODE_INVALID_3GPP;
	   	                               	    	       else 
	   	                               	    	       	 if (vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].ridtype==RIDTYPE_3GPP2)
	   	                               	    	          vgs.ucCurrentUsimMode_Invalid|=USIMMODE_INVALID_3GPP2; 
	   	                               	    	           
	   	                               	    	       std::cout<<RED<<"Note! MANDATORY Idntifier can not find"<<RESET<<std::endl<<std::flush;	
	   	                               	    	  }
	   	                               	     return 1;
	   	                               	 }
	   	                         }
	   	                         else
	   	                         	 	std::cout<<RED<<"Warning! Response is uncommon "<<RESET<<std::endl<<std::flush;						             	    
  						            } 	    	 						             	    
  		                     break;
  		                      		                            
  		       case APDU_GET_RESPONSE: 
  						             if ((vgs.ucApduReceiveBuf[0]==0XC0)&&
  						             	   (((vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-2]==SW1_90)&&(vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-1]==SW2_00))||
  						             	   ((vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-2]==SW1_91)&&(!(vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-1]==0))))
  						             	   &&(vgs.usApduReceiveLength==vgs.ucCurrentFileHeaderLength+3))
  						             	   	return 1;
  						             break;
 
						case APDU_READ: 
  						             if ((vgs.ucApduReceiveBuf[0]==0XB0)&&
  						             	   (((vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-2]==SW1_90)&&(vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-1]==SW2_00))||
  						             	   ((vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-2]==SW1_91)&&(!(vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-1]==0))))
  						             	   &&(vgs.usApduReceiveLength==vgs.usCurrentFileBodyLength+3))
  						             	   	return 1;
 						             break;
						case APDU_READ_RECORD: 
  						             if ((vgs.ucApduReceiveBuf[0]==0XB2)&&
  						             	   (((vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-2]==SW1_90)&&(vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-1]==SW2_00))||
  						             	   ((vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-2]==SW1_91)&&(!(vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-1]==0))))
  						             	   &&(vgs.usApduReceiveLength==vgs.ucCurrentRecordLength+3))
  						             	   	return 1;
						             break;
  		    
            default:
            	           break;  
          }  
	  vgs.ucStatusCode=ERROR_UNRECOGNIZEDAPDUOPERATION;
	  return -1;
	}		
	
int VcardGenerator::VerifyResponse(){	
  if (vgs.ucCurrentHandleCardMode&CARDMODE_USIM){
  	 if (VerifyResponse_USim()==1)
  	 	  return 1;
   }
   else{
     if (vgs.ucCurrentHandleCardMode&CARDMODE_SIM){
  	    if (VerifyResponse_Sim()==1)
  	 	      return 1;
  	 }
  	 else{
  	 	      if (vgs.ucCurrentHandleCardMode&CARDMODE_UIM){
  	         if (VerifyResponse_Uim()==1)
  	 	      return 1;
  	 }
  	 	
  	 	}
   }
  return -1;	 	
  	
	}	

//access condition not fulfilled;unsuccessful CHV verification, at least one attempt left;unsuccessful UNBLOCK CHV verification, at least one attempt
// left;authentication failed
int  VcardGenerator::IsUnsucessfulVerifyOrAuth_Fail_SimAndUim(unsigned short reopnselength, unsigned char* response ){
	  if (reopnselength!=2)
	  	return 0;
	  if ((*response==SW1_98)&&(*(response+1)==SW2_04))
	  	return 1;
	  else
	  	return 0;	
}

int  VcardGenerator::IsUnsucessfulVerifyOrAuth_Fail_Usim(unsigned short reopnselength ,unsigned char* response ){
	  if (reopnselength!=2)
	  	return 0;
	  if ((*response==SW1_69)&&(*(response+1)==SW2_82))
	  	return 1;
	  else
	  	return 0;	
}

//比较数组前n个字节是否相同， 相同 返回0  //AID 比较工具， AID中含数字0， 不能使用strncmp比较	
int VcardGenerator::char_arrayncmp(unsigned char * array1 ,unsigned char * array2 ,unsigned char length){
unsigned char tmplength;	
	for (tmplength=0;tmplength<length;tmplength++)
	   if (*(array1+tmplength)!=* (array2+tmplength))
	   	 return -1;
	if (tmplength==length)
		return 0;
}	

int  VcardGenerator::GetRidTypeFromAid(unsigned char * aid_buf ,unsigned char aid_length){
  // aid 中 含数字0 ，不能用 strncmp比较
  if 	(aid_length>0x10)
  	return -1;    	
  if (!char_arrayncmp (   aid_buf,   aid_rid_3gpp, 5 ))
  	return RIDTYPE_3GPP;
  else{
  	  if (!char_arrayncmp (  aid_buf,   aid_rid_3gpp2, 5 ))
  	       return RIDTYPE_3GPP2;
  	    else{
  	    	if (!char_arrayncmp (  aid_buf,  aid_rid_etsi, 5 ))
  	           return RIDTYPE_ETSI;
  	    	} 	
  	}	
  return  RIDTYPE_UNRECOGNIZED;
}

/**************************************************************************** 
* 函数名称 : ProcessResponse_Sim
* 类       ：VcardGenerator
* 功能描述 : 处理响应，（在向Sim Card 发送命令后，根据得到的响应生成Vcard 的内容） 
* 参    数 : 
* 参    数 : 
* 参    数 : 
* 返 回 值 : 正确 返回 1  不正确 返回 -1
* 作    者 : 王翔
* 设计日期 : 
* 修改日期		  修改人		   修改内容  
 *****************************************************************************/
int VcardGenerator::ProcessResponse_Sim(){
	  return SubProcessResponse_UimOrSim(CARDMODE_SIM); 
	}	

int VcardGenerator::ProcessResponse_Uim(){
	  return SubProcessResponse_UimOrSim(CARDMODE_UIM);
	}	
int VcardGenerator::SubProcessResponse_UimOrSim(unsigned char cardmode){
vcard_file_property_t file1;
int tmprecordcontextcounter=0;
unsigned char tmpidentifier[2];
unsigned short tmpoffset;
unsigned short tmpzerostartmark;
int tmpgetfilepropertywithpath;
	 switch(vgs.ucCurrentApduOperation)
  				{
  					
  		      case APDU_SELECT_COMMAND:  		      	            
  						             memcpy(vgs.ucApduSendBuf,vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier,2);	
  						             vgs.usApduSendLength=2;	
  						             vgs.ucCurrentApduOperation=APDU_SELECT_DATA;	          
  		                     break;
  		      
  		      case APDU_SELECT_DATA: 
  		      	             if(vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].operation_property==OPERATION_PROPERTY_GENERATION_VCARD){
  		      	             	      //取出目前的文件总长（不含Vcard总长项的2字节）
                                if (FreshLengthAndReturnValue(vgs.ucVcardBuf,0, &tmpoffset)==-1)
                               	      return -1;
                               // 	      
   		      	             	    vgs.ulOffset_VcardCurrentFileLength=tmpoffset+2;       		      	             	      
  		      	             	    if ((vgs.ucApduReceiveBuf[0]==SW1_94)&&(vgs.ucApduReceiveBuf[1]==SW2_04)){  	             	    	     
  		      	             	    	      //2byte filelength,1byte fid length 1 byte access flag, n byte FID  ;4+n
  		      	             	    	      if ( vgs.ulOffset_VcardCurrentFileLength+4+\  
  		      	             	    	    	vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard.length*2<VCARD_MAX_LENGTH){   		      	             	    	
  		      	             	    	     
  		      	             	    	      //先更新固定偏置的项
  		      	             	    	      vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_FID_LENGTH]=\
  		      	             	    	        vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard.length*2;
  		      	             	    	        if (vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_FID_LENGTH]==2){
  		      	             	    	        	  vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_IDENTIFIER]=\
  		      	             	    	        	  vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard.identifier1[0];
  		      	             	    	        	  vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_IDENTIFIER+1]=\
  		      	             	    	        	  vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard.identifier1[1];
  		      	             	    	        }
  		      	             	    	        else 
  		      	             	    	        if (vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_FID_LENGTH]==4){
  		      	             	    	        	  vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_IDENTIFIER]=\
  		      	             	    	        	  vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard.identifier1[0];
  		      	             	    	        	  vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_IDENTIFIER+1]=\
  		      	             	    	        	  vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard.identifier1[1];
  		      	             	    	        	  vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_IDENTIFIER+2]=\
  		      	             	    	        	  vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard.identifier2[0];
  		      	             	    	        	  vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_IDENTIFIER+3]=\
  		      	             	    	        	  vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard.identifier2[1];
  		      	             	    	        }
  		      	             	    	        else
  		      	             	    	        if (vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_FID_LENGTH]==6){
  		      	             	    	        	  vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_IDENTIFIER]=\
  		      	             	    	        	  vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard.identifier1[0];
  		      	             	    	        	  vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_IDENTIFIER+1]=\
  		      	             	    	        	  vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard.identifier1[1];
  		      	             	    	        	  vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_IDENTIFIER+2]=\
  		      	             	    	        	  vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard.identifier2[0];
  		      	             	    	        	  vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_IDENTIFIER+3]=\
  		      	             	    	        	  vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard.identifier2[1];
  		      	             	    	        	  vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_IDENTIFIER+4]=\
  		      	             	    	        	  vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard.identifier3[0];
  		      	             	    	        	  vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_IDENTIFIER+5]=\
  		      	             	    	        	  vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard.identifier3[1];
  		      	             	    	        }
  		      	             	    	        else{
  		      	             	    	        	    return -1; 		      	             	    	        	   
  		      	             	    	        	}	
  		      	             	    	        	 		      	             	    	  
                               	           //更新当前文件总长(含自身)
                               	                                        	              
  		      	             	    	        if (FreshLengthAndReturnValue(&vgs.ucVcardBuf[vgs.ulOffset_VcardCurrentFileLength],\
  		      	             	    	         4+ vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard.length*2,\
  		      	             	    	         &tmpoffset)==-1)
                               	              return -1;   
                               	                
                               	           //更新USim文件群总长
  		      	             	    	        if (FreshLengthAndReturnValue(&vgs.ucVcardBuf[vgs.OFFSET_VCARDCURRENTSIMGROUPTAG_LENGTH],\
  		      	             	    	          4+ vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard.length*2,\
  		      	             	    	          &tmpoffset)==-1)
                               	              return -1; 
                               	                
  		      	             	    	                 
  		      	             	    	        //修改Vcard文件总长
  		      	             	    	        if (FreshLengthAndReturnValue(vgs.ucVcardBuf,\
  		      	             	    	          4+ vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard.length*2,\
  		      	             	    	          &tmpoffset)==-1)
                               	              return -1; 
                               	                		      	             	    	       		      	             	    	    
		      	             	    	           vgs.ucCurrentApduOperation=APDU_IDLE;
		      	             	    	        }		      	             	    	          
		      	             	    	        else{ 		      	             	    	          	   
            	             												vgs.ucStatusCode=ERROR_VCARD_OVERFLOW;
            	            											  return -1; 
		      	             	    	        }		      	             	    	          	 		      	             	    	          
  		      	             	    	   }       	  		      	             	    	     		      	             	    	    	 		      	             	    	    	  		      	             	  	 
  		      	             	  	else{
  		      	             	  		    
  						             				   vgs.ucCurrentFileHeaderLength=vgs.ucApduReceiveBuf[1];
  						            					 memcpy(vgs.ucApduSendBuf,command_get_reponse,4);	
  						             			     vgs.ucApduSendBuf[4]=vgs.ucApduReceiveBuf[1];
  						             			     vgs.usApduSendLength=5;	
  						             			     vgs.ucCurrentApduOperation=APDU_GET_RESPONSE;	
  						             	  	}
  						             }
  						             else
  						             		  vgs.ucCurrentApduOperation=APDU_IDLE;				 						             	    
  		                     break;
  		                      		                            
  		     case APDU_GET_RESPONSE: 
  		    	               memcpy(vgs.ucCurrentFileHeader,&vgs.ucApduReceiveBuf[1],vgs.ucCurrentFileHeaderLength);
  						             vgs.ucCurrentFileHeaderReponse[0]=vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-2];
  						             vgs.ucCurrentFileHeaderReponse[1]=vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-1];
  						             // 获得 当前文件的 类型
  						          //   if (vgs.ucCurrentFileHeader[7]==0x4)&&(vgs.ucCurrentFileHeader[7]==0x4)
  						            //  if (vgs.ucCurrentFileHeader[6-1]==0x7d)
  						           //   	int eep=0;
  						             if (vgs.ucCurrentFileHeader[7-1]==0x4) //EF Type
  						                   
  						               switch  ((vgs.ucCurrentFileHeader[14-1])){
  						            	    case 0:
  						            	        vgs.ucCurrentEFType=FILE_TYPE_EF|EF_STRUCTURE_TRANSPARENT;
                                    break;
  						            	    case 1:
  						            	        vgs.ucCurrentEFType=FILE_TYPE_EF|EF_STRUCTURE_LINEARFIXED;
  						            	         break;
  						            	    case 3:
  						            	        vgs.ucCurrentEFType=FILE_TYPE_EF|EF_STRUCTURE_CYCLIC;
  						            	         break;
  						            	    default:
  						            	 	      vgs.ucCurrentEFType=0;
  						            	         break;
  						            	 }
                            //取出目前的文件总长（不含Vcard总长项的2字节）
                           if (FreshLengthAndReturnValue(vgs.ucVcardBuf,0, &tmpoffset)==-1)
                               	      return -1;
   		      	             vgs.ulOffset_VcardCurrentFileLength=tmpoffset+2;     
  		      	          //将文件长度，文件地址 文件头长度，文件头响应字，文件头内容 存入Vcard
  		      	          //2byte filelength,1byte fid length 1 byte access flag, n byte FID ,1 byte fh length ,2byte fd response; 7+n
  		      	             if ( vgs.ulOffset_VcardCurrentFileLength+7+\  
  		      	             	    vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard.length*2<VCARD_MAX_LENGTH){
  		      	                            
  		      	                          vgs.ulOffset_VcardCurrentFileHeaderLength=vgs.ulOffset_VcardCurrentFileLength+4+\
  		      	                                          vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard.length*2;
  		      	         ////                   vgs.ulOffset_VcardCurrentFileHeaderLength=vgs.ulOffset_VcardCurrentFileLength+6;
  		      	                                         
  		      	             	    	      //先更新固定偏置的项
  		      	             	    	      vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_FID_LENGTH]=\
  		      	             	    	      vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard.length*2;
  		      	             	    	      if (vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_FID_LENGTH]==2){
  		      	             	    	        	  vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_IDENTIFIER]=\
  		      	             	    	        	  vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard.identifier1[0];
  		      	             	    	        	  vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_IDENTIFIER+1]=\
  		      	             	    	        	  vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard.identifier1[1];
  		      	             	    	      }
  		      	             	    	      else 
  		      	             	    	      if (vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_FID_LENGTH]==4){
  		      	             	    	        	  vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_IDENTIFIER]=\
  		      	             	    	        	  vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard.identifier1[0];
  		      	             	    	        	  vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_IDENTIFIER+1]=\
  		      	             	    	        	  vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard.identifier1[1];
  		      	             	    	        	  vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_IDENTIFIER+2]=\
  		      	             	    	        	  vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard.identifier2[0];
  		      	             	    	        	  vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_IDENTIFIER+3]=\
  		      	             	    	        	  vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard.identifier2[1];
  		      	             	    	      }
  		      	             	    	      else
  		      	             	    	      if (vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_FID_LENGTH]==6){
  		      	             	    	        	  vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_IDENTIFIER]=\
  		      	             	    	        	  vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard.identifier1[0];
  		      	             	    	        	  vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_IDENTIFIER+1]=\
  		      	             	    	        	  vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard.identifier1[1];
  		      	             	    	        	  vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_IDENTIFIER+2]=\
  		      	             	    	        	  vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard.identifier2[0];
  		      	             	    	        	  vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_IDENTIFIER+3]=\
  		      	             	    	        	  vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard.identifier2[1];
  		      	             	    	        	  vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_IDENTIFIER+4]=\
  		      	             	    	        	  vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard.identifier3[0];
  		      	             	    	        	  vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_IDENTIFIER+5]=\
  		      	             	    	        	  vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard.identifier3[1];
  		      	             	    	      }
  		      	             	    	      else{
  		      	             	    	        	    return -1; 		      	             	    	        	   
  		      	             	    	     	}	 
  		      	             	    	      
  		      	             	    	         //更新当前文件总长(含自身)
  		      	             	    	      if (FreshLengthAndReturnValue(&vgs.ucVcardBuf[vgs.ulOffset_VcardCurrentFileLength],\
  		      	             	    	                      7+vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard.length*2\
  		      	             	    	                                     +vgs.ucCurrentFileHeaderLength,&tmpoffset)==-1)
                               	              return -1;
  		      	             	    	        
                               	             //更新Sim文件群总长
                               	        if (FreshLengthAndReturnValue(&vgs.ucVcardBuf[vgs.OFFSET_VCARDCURRENTSIMGROUPTAG_LENGTH],\
  		      	             	    	                       7+vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard.length*2\
  		      	             	    	                                     +vgs.ucCurrentFileHeaderLength,&tmpoffset)==-1)		      	             	
                               	              return -1;
  		      	                       
  		      	                          vgs.ucVcardBuf[vgs.ulOffset_VcardCurrentFileHeaderLength]=vgs.ucCurrentFileHeaderLength;  		      	               
  		      	                          vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_HEADER_RESPONSE]=vgs.ucCurrentFileHeaderReponse[0];
  		      	                          vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_HEADER_RESPONSE+1]=vgs.ucCurrentFileHeaderReponse[1];
  		      	                          memcpy(&vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_HEADER],&vgs.ucApduReceiveBuf[1],vgs.ucCurrentFileHeaderLength);
  		      	             		      	             	    	             		      	             	    	          
  		      	                    //更新Vcard文件总长
  		      	                         if (FreshLengthAndReturnValue(vgs.ucVcardBuf,\
  		      	             	    	                   7+vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard.length*2\
  		      	             	    	                                     +vgs.ucCurrentFileHeaderLength,&tmpoffset)==-1)		      	             	
                               	              return -1;  
  		      	                   	              
  		    	               }
  		    	               else{ 		      	             	    	          	   
            	             			 vgs.ucStatusCode=ERROR_VCARD_OVERFLOW;
            	            			 return -1; 
		      	             	 }
		      	             	 if (cardmode==CARDMODE_UIM)
		      	             	 	  tmpgetfilepropertywithpath=GetVcardFilePropertyWithPath_Uim(vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard, &file1);
		      	             	 else
		      	             	 if (cardmode==CARDMODE_SIM)
		      	             	 	  tmpgetfilepropertywithpath=GetVcardFilePropertyWithPath_Sim(vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard, &file1);
		      	             	 if (tmpgetfilepropertywithpath==1){
		      	             	 	    if ((file1.property&FILE_TYPE_EF)&&(file1.property&EF_READ_HEADER_ONLY)){
		      	                  	       vgs.ucCurrentApduOperation=APDU_IDLE;
		      	                    }
		      	                    else 
      						              {
      						                 if (file1.property&GET_EF_TYPE_FROM_HEADER) 
		      	                  	         file1.property|=vgs.ucCurrentEFType; 
      						                 vgs.CurrentOperationFileProperty=file1;	   						                 
      						                 if ((file1.property&FILE_TYPE_EF)&&(file1.property&EF_STRUCTURE_TRANSPARENT)){					                 	    
      						                       vgs.usCurrentFileBodyLength=((unsigned short)vgs.ucApduReceiveBuf[3]<<8)+(unsigned short)vgs.ucApduReceiveBuf[4];
      						                       memcpy(vgs.ucApduSendBuf,command_read,4);	  						             			    
      						             			     vgs.usApduSendLength=5;	
      						             		 	    
      						                       if ( vgs.usCurrentFileBodyLength>=0x100)   //TODO 超过0xff 长度
      						                       	  vgs.usCurrentFileBodyEndOffset2ReadBinary=0xff;
      						                       else	
      						                       	 vgs.usCurrentFileBodyEndOffset2ReadBinary=vgs.usCurrentFileBodyLength; 
      						                       	  
      						                       vgs.usCurrentFileBodyStartOffset2ReadBinary= 0;
      						                       
      						                       vgs.ucApduSendBuf[4]= vgs.usCurrentFileBodyEndOffset2ReadBinary; 
      						            					 vgs.ucCurrentApduOperation=APDU_READ;	 						             
      						                  }
      						                 if ((file1.property&FILE_TYPE_EF)&&(file1.property&(EF_STRUCTURE_LINEARFIXED|EF_STRUCTURE_CYCLIC))){
      						                    	 vgs.usCurrentFileBodyLength=((unsigned short)vgs.ucApduReceiveBuf[3]<<8)+(unsigned short)vgs.ucApduReceiveBuf[4];
      						                   	   if(!vgs.ucCurrentRecordSerialNumber)
      						                   	   	    vgs.ucCurrentRecordLength=vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-3];
      						            					 memcpy(vgs.ucApduSendBuf,command_read_record,4);	
      						            					 vgs.ucApduSendBuf[2]=(unsigned char)vgs.ucCurrentRecordSerialNumber+1; 
      						             			     vgs.ucApduSendBuf[4]=(unsigned char)vgs.ucCurrentRecordLength;
      						             			     vgs.usApduSendLength=5;	
      						             			     vgs.ucCurrentApduOperation=APDU_READ_RECORD;	 					             
      						                  }
      						                 if ((file1.property&FILE_TYPE_MF)|(file1.property&FILE_TYPE_DF))
      						                 	     vgs.ucCurrentApduOperation=APDU_IDLE;
      						              }    
  						             }
  						             break;
  				case APDU_VERIFY_CHV:
  					          
          	              if (vgs.ucCurrentChvAndUnblockOperation==CHVANDUNBLOCK_CHECK_GLOBLE_CHV_REQUEST_PIN){
          	              	 if (vgs.usApduReceiveLength>8)  //validate pin length
          	              	 	  return -1;
          	              	 vgs.ucCurrentPinLength=8;
          	              	 memset(vgs.ucCurrentPinBuf,0xff,vgs.ucCurrentPinLength);	 
          	              	 memcpy(vgs.ucCurrentPinBuf,vgs.ucApduReceiveBuf,vgs.usApduReceiveLength);	
          	              	 
          	              	 memcpy(vgs.ucApduSendBuf,sim_uim_verify_chv1_globe,4);		  
          	              	 memcpy(&(vgs.ucApduSendBuf[4]),&vgs.ucCurrentPinLength,1);	   	                     
  						               vgs.usApduSendLength=5;	
						              	 vgs.ucCurrentChvAndUnblockOperation=CHVANDUNBLOCK_CHECK_GLOBLE_CHV_COMMAND;  	            	              	
          	              }		
          	              else
          	              if (vgs.ucCurrentChvAndUnblockOperation==CHVANDUNBLOCK_CHECK_GLOBLE_CHV_COMMAND){
          	              	 if ((vgs.usApduReceiveLength==1)&&(vgs.ucApduReceiveBuf[0]==0x20)) {//Check chv 
          	              	              memcpy(vgs.ucApduSendBuf,vgs.ucCurrentPinBuf,8);		            	              	 	   	 	                          
  						                            vgs.usApduSendLength=8;	
						              	              vgs.ucCurrentChvAndUnblockOperation=CHVANDUNBLOCK_CHECK_GLOBLE_CHV_ARGU;  
          	              	 }
          	              	 else{
          	              	 	      	    std::cout<<RED<<"Unrecognized process byte!"<<RESET<<std::endl<<std::flush;	
          	              	 	      	    
          	              	 	      	    return -1;
          	              	 	      	}
          	              	 	  
          	              }		
          	              else
          	              if (vgs.ucCurrentChvAndUnblockOperation==CHVANDUNBLOCK_CHECK_GLOBLE_CHV_ARGU){
          	              	 
          	              	 if (vgs.usApduReceiveLength==2){
          	              	 	   // CHV Pin 正确
          	              	 	  if (   
          	              	 	  	   ((vgs.ucApduReceiveBuf[0]==SW1_90)&&(vgs.ucApduReceiveBuf[1]==SW2_00))\
          	              	 	  	   ||(vgs.ucApduReceiveBuf[0]==SW1_91)
          	              	 	  	 ){
          	              	 	  	         memcpy(vgs.ucApduSendBuf,vgs.ucEarlyApduSendBuf,vgs.usEarlyApduSendLength);
  						                             vgs.usApduSendLength=vgs.usEarlyApduSendLength;							              	             
						              	              vgs.ucCurrentChvAndUnblockOperation=CHVANDUNBLOCK_CHECK_OK; 
						              	              vgs.ucCurrentApduOperation=vgs.EarlyApduOperation;  
						              	                	              	 	     
          	              	 	     }
          	              	 	  else{
          	              	 	  	     std::cout<<RED<<"CHV FAIL!"<<RESET<<std::endl<<std::flush;	
          	              	 	  	     vgs.ucCurrentPinLength=0; 
          	              	 	  	     vgs.ucStatusCode=ERROR_ERROR_CHV_PIN;
          	              	 	  	     return -1;
          	              	 	  	}         	              	 	  	
          	                 } 
          	                 else{
          	              	 	  	     std::cout<<RED<<"CHV FAIL ,response length invalid!"<<RESET<<std::endl<<std::flush;	
          	              	 	  	     vgs.ucCurrentPinLength=0; 
          	              	 	  	     return -1;
          	              	 }  
          	              }
          	            
          	              break;		             		             
 
					case APDU_READ: 
						               if  (IsUnsucessfulVerifyOrAuth_Fail_SimAndUim(vgs.usApduReceiveLength,vgs.ucApduReceiveBuf)){  
         						            if (vgs.ucCurrentChvAndUnblockOperation!=CHVANDUNBLOCK_CHECK_OK){	
         						              	   vgs.EarlyApduOperation=APDU_READ;
         						              	   vgs.usEarlyApduSendLength=5;         						              	   
         						              	   memcpy(vgs.ucEarlyApduSendBuf,vgs.ucApduSendBuf,5);	
         						              	   
         						              	   if(vgs.ucCurrentPinLength==8) { //表示 Pin值已经在以前某个时间输入
          	              	 	   	 	      memcpy(vgs.ucApduSendBuf,sim_uim_verify_chv1_globe,4);		  
          	              	 	   	 	      memcpy(&(vgs.ucApduSendBuf[4]),&vgs.ucCurrentPinLength,1);	   	                     
  						                            vgs.usApduSendLength=5;	
						              	              vgs.ucCurrentChvAndUnblockOperation=CHVANDUNBLOCK_CHECK_GLOBLE_CHV_COMMAND;  
          	              	 	   	 	   }
          	              	 	   	 	   else
          	              	 	   	 	    if(vgs.ucCurrentPinLength==0)	
          	              	 	   	 	   	  {  //没有Pin码输入或错误的pin
          	              	 	   	 	   	  
          	              	 	   	 	   	   vgs.ucCurrentChvAndUnblockOperation=CHVANDUNBLOCK_CHECK_GLOBLE_CHV_REQUEST_PIN;  
          	              	 	   	 	   	  
          	              	 	   	 	   	  }
          	              	 	   	 	   	
         						              	   vgs.ucCurrentApduOperation=APDU_VERIFY_CHV; 
         						              	  
          						                 break;
						              	    }
						               }
						               
						               memcpy(&vgs.ucCurrentFileBody[vgs.usCurrentFileBodyStartOffset2ReadBinary],\
						               &vgs.ucApduReceiveBuf[1],vgs.usCurrentFileBodyEndOffset2ReadBinary-vgs.usCurrentFileBodyStartOffset2ReadBinary);
						               if (vgs.usCurrentFileBodyEndOffset2ReadBinary<vgs.usCurrentFileBodyLength){
						               	    vgs.usCurrentFileBodyStartOffset2ReadBinary=vgs.usCurrentFileBodyEndOffset2ReadBinary;
						               	    memcpy(vgs.ucApduSendBuf,command_read,2);	 
						               	    vgs.ucApduSendBuf[2]=(unsigned char) ((vgs.usCurrentFileBodyStartOffset2ReadBinary)>>8);
						               	    vgs.ucApduSendBuf[3]=(unsigned char) vgs.usCurrentFileBodyStartOffset2ReadBinary;		
						               	    if ((vgs.usCurrentFileBodyLength-vgs.usCurrentFileBodyEndOffset2ReadBinary)>=0x100){						               	    	   
						               	    	   vgs.usCurrentFileBodyEndOffset2ReadBinary=vgs.usCurrentFileBodyEndOffset2ReadBinary+0xff;						               	    	   						               	    	    
						               	    	   vgs.ucApduSendBuf[4]=0xff;			             			    						             			      		               	    	  
						               	    }
						               	    else
						               	    {						               	    	   
						               	    	   vgs.usCurrentFileBodyEndOffset2ReadBinary=vgs.usCurrentFileBodyLength;						               	    	   						               	    	    						               	    	  
						               	    	   vgs.ucApduSendBuf[4]=vgs.usCurrentFileBodyEndOffset2ReadBinary-vgs.usCurrentFileBodyStartOffset2ReadBinary;  						           			     				               	    	  
						               	    }
						               	    vgs.usApduSendLength=5;			
						               	    break;						               	    	
						               	}
						               	
						               	if (vgs.usCurrentFileBodyLength>0x100)						          						                 
  						                 if (vgs.CurrentOperationFileProperty.property&LONG_TRANSPARENT_EF_CUT_TAIL_DEFAULT_0){	
  						                 	 for ( tmpzerostartmark=vgs.usCurrentFileBodyLength;tmpzerostartmark>0;tmpzerostartmark--)  //从后找第1个不为0的位置
  						                 	     if 	(vgs.ucCurrentFileBody[tmpzerostartmark-1]!=0)
  						                 	        break;
  						                   vgs.usCurrentFileBodyLength=	tmpzerostartmark;     	
  						                 } 	      
						                   						             
  						             vgs.ucCurrentFileBodyReponse[0]=vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-2];
  						             vgs.ucCurrentFileBodyReponse[1]=vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-1];  
						                
						               //取出目前的文件总长（不含Vcard总长项的2字节）
                           if (FreshLengthAndReturnValue(vgs.ucVcardBuf,0, &tmpoffset)==-1)
                               	      return -1;
                           //更新当前文件体长度
   		      	             vgs.ulOffset_VcardCurrentFileBodyLength=tmpoffset+2;     		      	               
  						           
 						                 
  						             if  ( vgs.ulOffset_VcardCurrentFileBodyLength+4+vgs.usCurrentFileBodyLength<VCARD_MAX_LENGTH){
  						             	  //更新文件体长度内容
  						             if (FreshLengthAndReturnValue(&vgs.ucVcardBuf[vgs.ulOffset_VcardCurrentFileBodyLength],\
  						                	vgs.usCurrentFileBodyLength, &tmpoffset)==-1)
                               	      return -1;	
                               	        
  						                 
  						             vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_BODY_RESPONSE]=vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-2];
  						             vgs.ucVcardBuf[(vgs.OFFSET_VCARD_CURRENT_FILE_BODY_RESPONSE)+1]=vgs.ucApduReceiveBuf[(vgs.usApduReceiveLength)-1]; 
  						               						            
  						             memcpy(&vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_BODY],vgs.ucCurrentFileBody,vgs.usCurrentFileBodyLength);
  						             
  						              //更新文件长度内容
  						             if (FreshLengthAndReturnValue(&vgs.ucVcardBuf[vgs.ulOffset_VcardCurrentFileLength],\
  						                	vgs.usCurrentFileBodyLength+4,&tmpoffset)==-1)
                               	      return -1;
                               	
  						                 //更新Sim文件群总长
  		      	             if (FreshLengthAndReturnValue(&vgs.ucVcardBuf[vgs.OFFSET_VCARDCURRENTSIMGROUPTAG_LENGTH],\
  		      	             	    	              vgs.usCurrentFileBodyLength+4 ,&tmpoffset)==-1)
                               	    return -1;     
                              //更新Vcard文件总长
                                if (FreshLengthAndReturnValue(vgs.ucVcardBuf,\
  		      	             	    	              vgs.usCurrentFileBodyLength+4 ,&tmpoffset)==-1)
                               	    return -1;
                               		      	            
  		      	             }
  		      	             else{ 		      	             	    	          	   
            	             			 vgs.ucStatusCode=ERROR_VCARD_OVERFLOW;
            	            			 return -1; 
		      	             	 }    	             
 													 vgs.ucCurrentApduOperation=APDU_IDLE;  					             
 						               break;
					case APDU_READ_RECORD: 
						               if  (IsUnsucessfulVerifyOrAuth_Fail_SimAndUim(vgs.usApduReceiveLength,vgs.ucApduReceiveBuf)){  
         						            if (vgs.ucCurrentChvAndUnblockOperation!=CHVANDUNBLOCK_CHECK_OK){	
         						              	   vgs.EarlyApduOperation=APDU_READ_RECORD;
         						              	   vgs.usEarlyApduSendLength=5;         						              	   
         						              	   memcpy(vgs.ucEarlyApduSendBuf,vgs.ucApduSendBuf,5);	
         						              	   
         						              	   if(vgs.ucCurrentPinLength==8) { //表示 Pin值已经在以前某个时间输入
          	              	 	   	 	      memcpy(vgs.ucApduSendBuf,sim_uim_verify_chv1_globe,4);		  
          	              	 	   	 	      memcpy(&(vgs.ucApduSendBuf[4]),&vgs.ucCurrentPinLength,1);	   	                     
  						                            vgs.usApduSendLength=5;	
						              	              vgs.ucCurrentChvAndUnblockOperation=CHVANDUNBLOCK_CHECK_GLOBLE_CHV_COMMAND;  
          	              	 	   	 	   }
          	              	 	   	 	   else
          	              	 	   	 	    if(vgs.ucCurrentPinLength==0)	
          	              	 	   	 	   	  {  //没有Pin码输入或错误的pin
          	              	 	   	 	   	  
          	              	 	   	 	   	   vgs.ucCurrentChvAndUnblockOperation=CHVANDUNBLOCK_CHECK_GLOBLE_CHV_REQUEST_PIN;  
          	              	 	   	 	   	  
          	              	 	   	 	   	  }
          	              	 	   	 	   	
         						              	   vgs.ucCurrentApduOperation=APDU_VERIFY_CHV; 
         						              	  
          						                 break;
						              	    }
						               }
						            
						               if(!vgs.ucCurrentRecordSerialNumber){
						               	    //取出目前的文件总长（不含Vcard总长项的2字节）
                                 if (FreshLengthAndReturnValue(vgs.ucVcardBuf,0, &tmpoffset)==-1)
                               	      return -1;
                               	 
                               	 if (tmpoffset+2+ 2<VCARD_MAX_LENGTH){  // 后面的2 指记录响应状态字长度						               							             
						                    	   vgs.ucVcardBuf[tmpoffset+2]=vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-2]; //保存记录读状态字
						               	         vgs.ucVcardBuf[tmpoffset+2+1]=vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-1];
						                    	   
						      						          
						      						         //更新文件长度内容
  						                   if (FreshLengthAndReturnValue(&vgs.ucVcardBuf[vgs.ulOffset_VcardCurrentFileLength],\
  						                     	2,&tmpoffset)==-1)
						      						            return -1;				
						      						        
                                 //更新Sim文件群总长
  		      	                   if (FreshLengthAndReturnValue(&vgs.ucVcardBuf[vgs.OFFSET_VCARDCURRENTSIMGROUPTAG_LENGTH],\
  		      	             	    	              2 ,&tmpoffset)==-1)
                               	    return -1; 
                               	 //更新Vcard文件总长
                                 if (FreshLengthAndReturnValue(vgs.ucVcardBuf,\
  		      	             	    	              2 ,&tmpoffset)==-1)
                               	    return -1;             
                               	      					                   
  						                   }
  						                   else{ 		      	             	    	          	   
            	             								vgs.ucStatusCode=ERROR_VCARD_OVERFLOW;
            	            								 return -1; 
		      	             	    	 }	
  						             } 
  						             if (cardmode==CARDMODE_UIM)
		      	             	 	  tmpgetfilepropertywithpath=GetVcardFilePropertyWithPath_Uim(vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard, &file1);
		      	             	 else
		      	             	 if (cardmode==CARDMODE_SIM)
		      	             	 	  tmpgetfilepropertywithpath=GetVcardFilePropertyWithPath_Sim(vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard, &file1);
		      	             	 if (tmpgetfilepropertywithpath==1){ 
		      	             	 	 						            
  						            // if (GetVcardFilePropertyWithPath_Uim(vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier_to_vcard, &file1)==1){							             	    
  						             	     if (file1.property&SPARE_MODE_LINEARFIXED_CYCLIC){   //优化Vcard中线性定长/循环文件，如果记录为缺省值，则不保存记录 
  						             	     	     if (file1.property&STARTBYTE_1_LINEARFIXED_CYCLIC)
  						             	     	     	      tmprecordcontextcounter=1;
  						             	     	     else {
  						             	     	     	if (file1.property&STARTBYTE_2_LINEARFIXED_CYCLIC)
  						             	     	     	      tmprecordcontextcounter=2;
  						             	     	         else 
  						             	     	     	      tmprecordcontextcounter=0;
  						             	     	     }	      
  						             	     	     if (file1.property&DEFAULT_FF_LINEARFIXED_CYCLIC)
  						             	     	     	    	for (;tmprecordcontextcounter<vgs.ucCurrentRecordLength;tmprecordcontextcounter++){ 
  						             	                        if (vgs.ucApduReceiveBuf[tmprecordcontextcounter+1]!=0xFF)
  						             	      	                     break;
  						                                } 
  						                         if (file1.property&DEFAULT_0_LINEARFIXED_CYCLIC)
  						             	     	     	    	for (;tmprecordcontextcounter<vgs.ucCurrentRecordLength;tmprecordcontextcounter++){ 
  						             	                        if (vgs.ucApduReceiveBuf[tmprecordcontextcounter+1]!=0)
  						             	      	                     break;
  						                                }            
  						             	     	     	      
  						             	     }	     	      
  						             } 						               
  						             if (tmprecordcontextcounter<vgs.ucCurrentRecordLength){
  						             	     //取出目前的文件总长（不含Vcard总长项的2字节）
                                 if (FreshLengthAndReturnValue(vgs.ucVcardBuf,0, &tmpoffset)==-1)
                               	      return -1;
                               	  //更新当前记录序列号偏置
   		      	                  vgs.ulOffset_VcardCurrentRecordSerialNumber=tmpoffset+2;    						             	  						             	   
  						             	    if  ( vgs.ulOffset_VcardCurrentRecordSerialNumber+2+vgs.ucCurrentRecordLength<VCARD_MAX_LENGTH){ //2 记录m 的记录号和记录m的长度占用字节数
  						             	    			vgs.ucVcardBuf[vgs.ulOffset_VcardCurrentRecordSerialNumber]=vgs.ucCurrentRecordSerialNumber+1;
  						             	    			vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_RECORD_LENGTH]=vgs.ucCurrentRecordLength;
  						             	    			memcpy(&vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_RECORD],&vgs.ucApduReceiveBuf[1],vgs.ucCurrentRecordLength);
  						             	    
  						             	     //更新文件长度内容
  						                  if (FreshLengthAndReturnValue(&vgs.ucVcardBuf[vgs.ulOffset_VcardCurrentFileLength],\
  						                     	2+vgs.ucCurrentRecordLength,&tmpoffset)==-1)
                               	      return -1;
                               	     
  		      	                   //更新Sim文件群总长
  		      	                if (FreshLengthAndReturnValue(&vgs.ucVcardBuf[vgs.OFFSET_VCARDCURRENTSIMGROUPTAG_LENGTH],\
  		      	             	    	              2+vgs.ucCurrentRecordLength ,&tmpoffset)==-1)
                               	    return -1; 
                                //更新Vcard文件总长
                                if (FreshLengthAndReturnValue(vgs.ucVcardBuf,\
  		      	             	    	              2+vgs.ucCurrentRecordLength ,&tmpoffset)==-1)
                               	    return -1;  
                               	    
  						                  }
  						                  else{ 		      	             	    	          	   
            	             			 vgs.ucStatusCode=ERROR_VCARD_OVERFLOW;
            	            			 return -1; 
		      	             	      }   						                    
  						             	}
  						              vgs.ucCurrentRecordSerialNumber++;
  						              if (vgs.ucCurrentRecordLength==0)   //增加 判断以免除以0 
  						              	   return -1; 
  						              else{	   
  						                  if (vgs.ucCurrentRecordSerialNumber<vgs.usCurrentFileBodyLength/(unsigned short)vgs.ucCurrentRecordLength) 						             	         
  						            					 vgs.ucApduSendBuf[2]=(unsigned char)vgs.ucCurrentRecordSerialNumber+1; 
  						             			else  {  
  						             				   vgs.ucCurrentRecordSerialNumber=0; 
  						             	         vgs.ucCurrentApduOperation=APDU_IDLE;
  						             	    }
  						             	 }   
						                 break;
  		    
            default:            	         
            	              vgs.ucStatusCode=ERROR_UNRECOGNIZEDAPDUOPERATION;
            	              return -1;
            	              break;  
          } 
	  if (vgs.ucCurrentApduOperation==APDU_IDLE){
	  	     vgs.ucCurrentFileSerialNumber++;
	  	     if(!(( vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier[0]==0)&&( vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier[1]==0))){
	  	   	          memcpy(vgs.ucApduSendBuf,command_select,5);	
  						      vgs.usApduSendLength=5;	
  						      vgs.ucCurrentApduOperation=APDU_SELECT_COMMAND;	
  			   }
  			   else {
  			   	      if (vgs.ucHandleMode&CARDMODE_USIM) {     //等待复位将Card 恢复到未激活任何Session的状态
  			   	    	
  			   	    	 vgs.ucVcardGeneratorStatus=VCARD_GENERATOR_STATUS_WAITING_FAST_RESET_FOR_CARD_INITIAL_STATUS;
  			   	    	 vgs.ucApduInteractiveStatus=AIAS_STOP;	
  			   	    }
  			   	    else{
  			   	    vgs.ucVcardGeneratorStatus=VCARD_GENERATOR_STATUS_SUCCESS;  			    
  			   	     }
  			   	     AddPin2Vcard();
  			   	     if (cardmode==CARDMODE_UIM)
		      	        vgs.ucVcardBuf[OFFSET_VCARD_MAINTAIN_INFORMATION]|=VC_DATA_UIMMODE_MAINTAIN;	     	 	 
		      	     else
		      	     if (cardmode==CARDMODE_SIM)
		      	         vgs.ucVcardBuf[OFFSET_VCARD_MAINTAIN_INFORMATION]|=VC_DATA_SIMMODE_MAINTAIN;	      	 	 		      	             
  			   	    return 1; 
  			   	  }           
  			   
	  }
	   if (vgs.ucCurrentChvAndUnblockOperation==CHVANDUNBLOCK_CHECK_GLOBLE_CHV_REQUEST_PIN)
	  	vgs.ucApduInteractiveStatus=AIAS_WAIT_PIN_INPUT;	
	   else
	  	
	     vgs.ucApduInteractiveStatus=AIAS_SENDDATAISREADY;	
	  vgs.ucWaitGetInteractiveStartTime=GetTickCount();
	  return 1; 
	    
	}			
int VcardGenerator::ProcessResponse_USim(){
vcard_file_property_t file1;
int tmprecordcontextcounter=0;
int trccff=0;
int trcc0=0;
int tmpt,compcnt,tmpaidcnt,tmpreval,tmpaid_itemnbr;
unsigned short tmpoffset;
unsigned char tmpidentifier[2];
unsigned short tmpzerostartmark;
int tmpPinCnter;
	 switch(vgs.ucCurrentApduOperation)
  				{                    
  					
  					
  		      case APDU_SELECT_COMMAND:  
  		      	  		      	         		  		      	            
  		      		           if ( vgs.ucUsimSessionActiveStatus==USIMSESSIONACTIVESTATUS_EXPECT_OPEN_AID){  		      	             	       	             	  	
  		      	             	  if (vgs.ucCurrentAidNumber<APPICAITON_NUMBER_MAX){
  		      	             	  	 memcpy(vgs.ucApduSendBuf,vgs.aid_list[vgs.ucCurrentAidNumber].aid,vgs.aid_list[vgs.ucCurrentAidNumber].length);  						   
  						                   vgs.usApduSendLength=vgs.aid_list[vgs.ucCurrentAidNumber].length;	  		      	             	  	
  		      	             	  	}
  		      	             }	
  		      	        /*
  		      	             if ( vgs.ucUsimSessionActiveStatus==USIMSESSIONACTIVESTATUS_SELECT_WITH_3GPP_AID){
  		      	             	  for (tmpaidcnt=0;tmpaidcnt<APPICAITON_NUMBER_MAX;tmpaidcnt++)
  		      	             	  	  if (vgs.aid_list[tmpaidcnt].length!=0)
  		      	             	  	  	break; 		      	             	  	
  		      	             	  if (tmpaidcnt<APPICAITON_NUMBER_MAX){
  		      	             	  	 memcpy(vgs.ucApduSendBuf,vgs.aid_list[tmpaidcnt].aid,vgs.aid_list[tmpaidcnt].length);  						   
  						                   vgs.usApduSendLength=vgs.aid_list[tmpaidcnt].length;	  		      	             	  	
  		      	             	  	}

  		      	             }*/	
  		      	             else{      	            
  						                memcpy(vgs.ucApduSendBuf,vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].identifier,\
  						                vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].length);	
  						                vgs.usApduSendLength=vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].length;	
  						             }
  						             vgs.ucCurrentApduOperation=APDU_SELECT_DATA;	          
  		                     break;
  		      
  		      case APDU_SELECT_DATA: 
  		      	             if(vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].operation_property==\
  		      	             	                                                   OPERATION_PROPERTY_GENERATION_VCARD){  		      	             	 
                               //取出目前的文件总长（不含Vcard总长项的2字节）
                               if (FreshLengthAndReturnValue(vgs.ucVcardBuf,0, &tmpoffset)==-1)
                               	      return -1;
                               // 	      
   		      	             	   vgs.ulOffset_VcardCurrentFileLength=tmpoffset+2;        
  		      	             	                 
  		      	             	    if ((vgs.ucApduReceiveBuf[0]==SW1_6A)&&(vgs.ucApduReceiveBuf[1]==SW2_82)){
  		      	             	    	      //2byte filelength,1byte fid length 1 byte access flag, n byte FID 
  		      	             	    	    if ( vgs.ulOffset_VcardCurrentFileLength+4+\  
  		      	             	    	    	vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].length<VCARD_MAX_LENGTH){   		      	             	    	   
  		      	             	    	    
  		      	             	    	        //先更新固定偏置的项
  		      	             	    	        //2018.7.8 将 RID类型放置在Vcard ACCESS_STATUS字节（<<5）
  		      	             	    	        vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_ACCESS_STATUS]=\
  		      	             	    	        (vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].ridtype)<<5;
  		      	             	    	        
  		      	             	    	        vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_FID_LENGTH]=\
  		      	             	    	        vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].length;
  		      	             	    	        
  		      	             	    	        for (int i=0;i< vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].length;i++)
  		      	             	    	              vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_IDENTIFIER+i]=\
  		      	             	    	                 vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].identifier[i];
  		      	             	    	       
                               	           //更新当前文件总长
  		      	             	    	        if (FreshLengthAndReturnValue(&vgs.ucVcardBuf[vgs.ulOffset_VcardCurrentFileLength],\
  		      	             	    	        4+ vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].length,\
  		      	             	    	        	 &tmpoffset)==-1)
                               	              return -1;   
                               	                
                               	           //更新USim文件群总长
  		      	             	    	        if (FreshLengthAndReturnValue(&vgs.ucVcardBuf[vgs.OFFSET_VCARDCURRENTUSIMGROUPTAG_LENGTH],\
  		      	             	    	        4+ vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].length,\
  		      	             	    	        	 &tmpoffset)==-1)
                               	              return -1; 
                               	                  
  		      	             	    	                 
  		      	             	    	        //修改Vcard文件总长
  		      	             	    	        if (FreshLengthAndReturnValue(vgs.ucVcardBuf,\
  		      	             	    	        4+ vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].length,\
  		      	             	    	        	 &tmpoffset)==-1)
                               	              return -1; 
                               	                                             	            		      	             	    	         		      	             	    	         
		      	             	    	          vgs.ucCurrentApduOperation=APDU_IDLE;
		      	             	    	        }		      	             	    	          
		      	             	    	        else{ 		      	             	    	          	   
            	             												vgs.ucStatusCode=ERROR_VCARD_OVERFLOW;
            	            											  return -1; 
		      	             	    	        }		      	             	    	          	 		      	             	    	          
  		      	             	    }       	  		      	             	    	     		      	             	    	    	 		      	             	    	    	  		      	             	  	 
  		      	             	  	else{
  		      	             	  		   
  		      	             	  		     						        
  		      	             	  		    
  		      	             	  		    if (
  		      	             	  		    	( vgs.ucUsimSessionActiveStatus==USIMSESSIONACTIVESTATUS_EXPECT_OPEN_AID)
  		      	             	  		    	&&
  		      	             	  		    	((vgs.ucApduReceiveBuf[0]==SW1_90)&&(vgs.ucApduReceiveBuf[1]==SW2_00))
  		      	             	  		    	){ 		      	             	  		    	
  		      	             	  		    	    vgs.ucUsimSessionActiveStatus=USIMSESSIONACTIVESTATUS_CAN_OPEN_AID;
  		      	             	  		    	   // vgs.ucUsimSessionActiveStatus=USIMSESSIONACTIVESTATUS_NEEDTOREADAID;
  		      	             	  		    	      	
  		      	             	  		    	    vgs.ucCurrentApduOperation=APDU_IDLE;	
  		      	             	  		    	    vgs.ucCurrentRidType=vgs.ucExpectRidType;
  		      	             	  		    }
  		      	             	  		    else{
  						             				          vgs.ucCurrentFileHeaderLength=vgs.ucApduReceiveBuf[1];
  						            					        memcpy(vgs.ucApduSendBuf,usimcommand_get_reponse,4);	
  						             			            vgs.ucApduSendBuf[4]=vgs.ucApduReceiveBuf[1];
  						             			            vgs.usApduSendLength=5;	
  						             			            vgs.ucCurrentApduOperation=APDU_GET_RESPONSE;	
  						             			   }
  						             	  	}
  						             }
  						             else
  						             		  vgs.ucCurrentApduOperation=APDU_IDLE;				 						             	    
  		                     break;
  		                      		                            
  		     case APDU_GET_RESPONSE: 
  		     	            if ((vgs.ucApduReceiveBuf[9]==0x6f)&(vgs.ucApduReceiveBuf[10]==0x13))
  		     	            	 int tmpee=1;
  		    	            memcpy(vgs.ucCurrentFileHeader,&vgs.ucApduReceiveBuf[1],vgs.ucCurrentFileHeaderLength);
  						          vgs.ucCurrentFileHeaderReponse[0]=vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-2];
  						          vgs.ucCurrentFileHeaderReponse[1]=vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-1];
  						          // 获得 当前文件的 类型
  						           tmpt= GetTagLocation_inFCP(TAG_FILE_DESCRIPTOR_WITH_TEMPLATE,vgs.ucCurrentFileHeader, (int )vgs.ucCurrentFileHeader[1]);
  						            if (tmpt==-1)
  						                  return -1;        
  						            switch  ((vgs.ucCurrentFileHeader[tmpt+2])&0x7){
  						            	 case 1:
  						            	        vgs.ucCurrentEFType=FILE_TYPE_EF|EF_STRUCTURE_TRANSPARENT;
                                    break;
  						            	 case 2:
  						            	        vgs.ucCurrentEFType=FILE_TYPE_EF|EF_STRUCTURE_LINEARFIXED;
  						            	         break;
  						            	 case 6:
  						            	        vgs.ucCurrentEFType=FILE_TYPE_EF|EF_STRUCTURE_CYCLIC;
  						            	         break;
  						            	 default:
  						            	 	      vgs.ucCurrentEFType=0;
  						            	         break;
  						            	}
  						            
                            //取出目前的文件总长（不含Vcard总长项的2字节）
                        if (FreshLengthAndReturnValue(vgs.ucVcardBuf,0, &tmpoffset)==-1)
                               	      return -1;
   		      	          vgs.ulOffset_VcardCurrentFileLength=tmpoffset+2;     
                          //2byte filelength,1byte fid length, 1 byte access flag, 1 byte file header length,2 byte file header response
                          //    n byte FID  						           						              						       		      	             	    	         		      	             	    	            		      	             	    	           
  		      	          //将文件长度，文件地址 文件头长度，文件头响应字，文件头内容 存入Vcard
  		      	          // Filelength+identifier+access_status+fileheaderlength+fileheaderresponse=8
  		      	          if ( vgs.ulOffset_VcardCurrentFileLength+7+\  
  		      	             	    	    	vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].length\
  		      	             	    	    	+vgs.ucCurrentFileHeaderLength\
  		      	             	    	    	<VCARD_MAX_LENGTH){   		      	         
  		      	               vgs.ulOffset_VcardCurrentFileHeaderLength=vgs.ulOffset_VcardCurrentFileLength+4+\  
  		      	                                         vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].length;
  		      	                
  		      	                     //先更新固定偏置的项
  		      	                     
  		      	                      //2018.7.8 将 RID类型放置在Vcard ACCESS_STATUS字节（<<5）
  		      	             	    	        vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_ACCESS_STATUS]=\
  		      	             	    	        (vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].ridtype)<<5;
  		      	                     
  		      	             	 vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_FID_LENGTH]=\
  		      	             	    	        vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].length;
  		      	             	    	        
  		      	             	 for (int i=0;i< vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].length;i++)
  		      	             	    	              vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_IDENTIFIER+i]=\
  		      	             	    	                 vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].identifier[i];
  		      	         
  		      	                   //更新当前文件长度项 （含自身）
                             if (FreshLengthAndReturnValue(&(vgs.ucVcardBuf[vgs.ulOffset_VcardCurrentFileLength]),\
                           	                 7+vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].length\
                           	                  +vgs.ucCurrentFileHeaderLength\
                           	 , &tmpoffset)==-1)
                               	    return -1;
                               	    
                          //更新USim文件群总长
  		      	               if (FreshLengthAndReturnValue(&vgs.ucVcardBuf[vgs.OFFSET_VCARDCURRENTUSIMGROUPTAG_LENGTH],\
  		      	             	    	           7+ vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].length\
  		      	             	    	           +vgs.ucCurrentFileHeaderLength\
  		      	             	 ,&tmpoffset)==-1)
                               	    return -1;       	    
                         			
  		      	             			
  		      	               vgs.ucVcardBuf[vgs.ulOffset_VcardCurrentFileHeaderLength]=vgs.ucCurrentFileHeaderLength;  		      	                     		      	                 
  		      	               vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_HEADER_RESPONSE]=vgs.ucCurrentFileHeaderReponse[0];
  		      	               vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_HEADER_RESPONSE+1]=vgs.ucCurrentFileHeaderReponse[1];
  		      	               memcpy(&vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_HEADER],&vgs.ucApduReceiveBuf[1],vgs.ucCurrentFileHeaderLength);
  		      	             		  
  		      	             		        	    
                             //更新Vcard文件总长
  		      	               if (FreshLengthAndReturnValue(vgs.ucVcardBuf,\
  		      	             	    	           7+ vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].length\
  		      	             	    	           +vgs.ucCurrentFileHeaderLength\
  		      	             	 ,&tmpoffset)==-1)
                               	    return -1;  	             	    	             		      	             	    	          
  		      	                   
  		      	                   
  		    	               }
  		    	               else{ 		      	             	    	          	   
            	             			 vgs.ucStatusCode=ERROR_VCARD_OVERFLOW;
            	            			 return -1; 
		      	             	 }	
		      	           //20180708
		      	           //  if (vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].identifier[3]==0xb7)
		      	           //  	    int i=0;
		      	           if (
		      	           	(vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].length==6)&& \
		      	           	(vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].identifier[4]==0x4f)&& \
		      	           	(vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].identifier[5]==0x23)
		      	           	)
		      	           	 int i=0;
		      	            
		      	            if (GetVcardFileProperty_WithUsimRidType(vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].length\
		      	                        ,vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].identifier	, \
		      	                        vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].ridtype	,&file1)==1){ 
		      	                     vgs.CurrentOperationFileProperty=file1;	 
		      	                  // 20180928 增加只读EF文件头操作
		      	                  if ((file1.property&FILE_TYPE_EF)&&(file1.property&EF_READ_HEADER_ONLY)){
		      	                  	 vgs.ucCurrentApduOperation=APDU_IDLE;
		      	                  }
		      	                  else{	
		      	                   if (file1.property&GET_EF_TYPE_FROM_HEADER) 
		      	                  	    file1.property|=vgs.ucCurrentEFType;
  						                 if ((file1.property&FILE_TYPE_EF)&&(file1.property&EF_STRUCTURE_TRANSPARENT)){
  						                    tmpt= GetTagLocation_inFCP(TAG_EF_FILE_SIZE_WITH_TEMPLATE_WITH_TEMPLATE,vgs.ucCurrentFileHeader, (int )vgs.ucCurrentFileHeader[1]);
  						                    if (tmpt==-1)
  						                       	 return -1;
  						                       	 
  						                     memcpy(vgs.ucApduSendBuf,usimcommand_read,4);	
  						                       	 
  						                    if (vgs.ucCurrentFileHeader[tmpt+1]==1){
  						                    	  vgs.usCurrentFileBodyLength=(unsigned short)vgs.ucCurrentFileHeader[tmpt+2];	
  						                    	  vgs.ucApduSendBuf[4]=	vgs.usCurrentFileBodyLength;
  						                    	   vgs.usCurrentFileBodyEndOffset2ReadBinary=vgs.usCurrentFileBodyLength; 	
  						                    	                    	 
  						                    	}
  						                    	   
  						                    else{
  						                    	    if ((vgs.ucCurrentFileHeader[tmpt+1]==2) &&(vgs.ucCurrentFileHeader[tmpt+2]==0x40)&&(vgs.ucCurrentFileHeader[tmpt+3]==0x0)&&(vgs.ucCurrentFileHeader[tmpt+6]==0x70))
  						                    	    	 int i=0;
  						                    	    if (vgs.ucCurrentFileHeader[tmpt+1]==2){  //FCP中透明文件长度会大于0xff
  						                    	       if (vgs.ucCurrentFileHeader[tmpt+2]==0){
  						                    	       	  vgs.usCurrentFileBodyLength=(unsigned short)vgs.ucCurrentFileHeader[tmpt+3];	
  						                    	          vgs.ucApduSendBuf[4]=	vgs.usCurrentFileBodyLength;
  						                    	          vgs.usCurrentFileBodyEndOffset2ReadBinary=vgs.usCurrentFileBodyLength; 					
  						                    	       	}
  						                    	       	else
  						                    	     
  						                    	       {
  						                       	          vgs.usCurrentFileBodyEndOffset2ReadBinary=0xff;  
  						                       	  
  						                                //  vgs.usCurrentFileBodyStartOffset2ReadBinary= 0;
  						                                  vgs.usCurrentFileBodyLength=((unsigned short) ((vgs.ucCurrentFileHeader[tmpt+2]<<8)+vgs.ucCurrentFileHeader[tmpt+3])); 
  						                                 vgs.ucApduSendBuf[4]= vgs.usCurrentFileBodyEndOffset2ReadBinary; 
  						            					    		}			                
  						                    	    }
  						                    	    
  						                    	    else
  						                    	    	return -1;   
  						                    	    	  	   
  						                    	}
  						                    		    						               
  						             			     vgs.usCurrentFileBodyStartOffset2ReadBinary= 0;			 
  						             			     vgs.usApduSendLength=5;	
  						             		 	     vgs.ucCurrentApduOperation=APDU_READ;	 						             
  						                  }
  						                 if ((file1.property&FILE_TYPE_EF)&&(file1.property&(EF_STRUCTURE_LINEARFIXED|EF_STRUCTURE_CYCLIC))){
  						                 	   tmpt= GetTagLocation_inFCP(TAG_FILE_DESCRIPTOR_WITH_TEMPLATE,vgs.ucCurrentFileHeader, (int )vgs.ucCurrentFileHeader[1]);
  						                      if (tmpt==-1)
  						                       	  return -1;
  						                 	    if (vgs.ucCurrentFileHeader[tmpt+1]!=5) //FILE_DESCRIPTOR_lengh=5 while no tranparent EF
  						                 	 	      return -1;
  						                 	 	
  						                 	 	  vgs.usCurrentFileBodyLength=(((unsigned short)(vgs.ucCurrentFileHeader[tmpt+4])<<8)+\
  						                 	 	     (unsigned short)(vgs.ucCurrentFileHeader[tmpt+5]))*\
  						                 	 	      (unsigned short)(vgs.ucCurrentFileHeader[tmpt+6]);
  						                 	 	       
  						                   
  						                   	  if(!vgs.ucCurrentRecordSerialNumber)  						                   
  						                   	   	 vgs.ucCurrentRecordLength=(((unsigned short)(vgs.ucCurrentFileHeader[tmpt+4])<<8)+\
  						                 	 	     (unsigned short)(vgs.ucCurrentFileHeader[tmpt+5]));
  						            					memcpy(vgs.ucApduSendBuf,usimcommand_read_record,4);	
  						            					vgs.ucApduSendBuf[2]=(unsigned char)vgs.ucCurrentRecordSerialNumber+1; 
  						             			    vgs.ucApduSendBuf[4]=(unsigned char)vgs.ucCurrentRecordLength;
  						             			    vgs.usApduSendLength=5;	
  						             			    vgs.ucCurrentLCEFReordDefault=LCEFREORDDEAULT_UNKNOWN;
  						             			    vgs.ucCurrentApduOperation=APDU_READ_RECORD;	 		
  						             			     
  						             			      // 判断是否为EFDIR  						            
  						                      if (vgs.ucUsimSessionActiveStatus==USIMSESSIONACTIVESTATUS_NOACTIVE)
  						            	          if ( 
  						            	 	             (vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].identifier\
  						            	 	             [vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].length-2]==0x2f)\
  						            	 	              &&
  						            	 	             (vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].identifier\
  						            	 	             [vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].length-1]==0x0)
  						            	 	           )
  						            	 	   	           vgs.ucUsimSessionActiveStatus=USIMSESSIONACTIVESTATUS_NEEDTOREADAID;						            	 	   	
  						            	 	          ;		 
  						             			     			             
  						                  }
  						                  //TODO 对不读文件体内容的文件， 进行Open AID
                               /*  
  						                 if ((file1.property&FILE_TYPE_MF)|(file1.property&FILE_TYPE_DF))
  						                 	     vgs.ucCurrentApduOperation=APDU_IDLE;
  						                 	*/
  						                  if ((file1.property&FILE_TYPE_MF)|(file1.property&FILE_TYPE_DF)){
  						                 	  //  if ( vgs.ucUsimSessionActiveStatus==USIMSESSIONACTIVESTATUS_NEEDTOREADAID){		
  						                 	      if ( vgs.ucUsimSessionActiveStatus==USIMSESSIONACTIVESTATUS_CAN_OPEN_AID){	
  						                 	   	             
  						             				     if(
  						             				            	  	  (vgs.ucCurrentRidType==vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].nextridtype)||\
  						             				            	  	  (vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].ridtype==vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].nextridtype)||\
  						             				            	  	  ( vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].nextridtype==RIDTYPE_NONEEDAID)
  						             				            	  )
  						             				            	  	vgs.ucCurrentApduOperation=APDU_IDLE;
  						             				            	  else{
  						             				            	  	   // memcpy(vgs.ucApduSendBuf,usimselect_ByDFName_NoDataReturn,4);	
  						             				            	  	    for (tmpaidcnt=0;tmpaidcnt<APPICAITON_NUMBER_MAX;tmpaidcnt++)
  		      	             	  	                          if ((vgs.aid_list[tmpaidcnt].length!=0)&&\
  		      	             	  	                          	  (vgs.aid_list[tmpaidcnt].ridtype==vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].nextridtype)
  		      	             	  	                          )
  		      	             	  	                        	   break; 
  		      	             	  	                        if (tmpaidcnt<APPICAITON_NUMBER_MAX){    	  
  		      	             	  	                          vgs.ucApduSendBuf[4]=vgs.aid_list[tmpaidcnt].length;	
  						                                            vgs.usApduSendLength=5;	
  						             				           	            vgs.ucCurrentApduOperation=APDU_SELECT_COMMAND; 
  						             				           	            vgs.ucExpectRidType=vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].nextridtype;
  						             				           	            vgs.ucUsimSessionActiveStatus=USIMSESSIONACTIVESTATUS_EXPECT_OPEN_AID;
  						             				           	            vgs.ucCurrentAidNumber=tmpaidcnt;
  						             				           	            memcpy(vgs.ucApduSendBuf,usimselect_ByDFName_NoDataReturn,4);	
  		      	             	  	                        } 
  		      	             	  	                        else	 
  		      	             	  	                        	vgs.ucCurrentApduOperation=APDU_IDLE;    
  						             				            	  	}   						             				            	
  						             	        } 
  						             	        else		
  						             		       vgs.ucCurrentApduOperation=APDU_IDLE;        						                 	  
  						                 	}
  						                }    
  						             }
  						             break;
          case APDU_VERIFY_CHV:
          	              if (vgs.ucCurrentChvAndUnblockOperation==CHVANDUNBLOCK_CHECK_CHV_RETRYTIMES){          	              
          	              	 if (     //globle,specific chv times 是联动的
          	              	 	   (vgs.usApduReceiveLength==2)&&(vgs.ucApduReceiveBuf[0]==SW1_63)&&((vgs.ucApduReceiveBuf[1]>>4)==0xc)  //63Cx x 表示retrytimes
          	              	 	   )
          	              	 	   	 
          	              	 	   	 if (vgs.ucApduReceiveBuf[1]&0xf) { //Pin retry times >0
          	              	 	   	 	   if(vgs.ucCurrentPinLength==8) { //表示 Pin值已经在以前某个时间输入
          	              	 	   	 	      memcpy(vgs.ucApduSendBuf,usim_verify_chv1_globe,4);		  
          	              	 	   	 	      memcpy(&(vgs.ucApduSendBuf[4]),&vgs.ucCurrentPinLength,1);	   	                     
  						                            vgs.usApduSendLength=5;	
						              	              vgs.ucCurrentChvAndUnblockOperation=CHVANDUNBLOCK_CHECK_GLOBLE_CHV_COMMAND;  
          	              	 	   	 	   }
          	              	 	   	 	   else
          	              	 	   	 	    if(vgs.ucCurrentPinLength==0)	
          	              	 	   	 	   	{  //没有Pin码输入或错误的pin
          	              	 	   	 	   	  
          	              	 	   	 	   	   vgs.ucCurrentChvAndUnblockOperation=CHVANDUNBLOCK_CHECK_GLOBLE_CHV_REQUEST_PIN;            	              	 	   	 	   	  
          	              	 	   	 	   	}
          	              	 	   	 	     
          	              	 	      }
          	              	 	      else{
          	              	 	      	    std::cout<<RED<<"PIN IS DISABLE!"<<RESET<<std::endl<<std::flush;	
          	              	 	      	    return -1;
          	              	 	      	}
          	              	 	      	   	              	              	 	   	
          	              }
          	              else
          	              if (vgs.ucCurrentChvAndUnblockOperation==CHVANDUNBLOCK_CHECK_GLOBLE_CHV_REQUEST_PIN){
          	              	 if (vgs.usApduReceiveLength>8)  //valid pin length
          	              	 	  return -1;
          	              	 vgs.ucCurrentPinLength=8;
          	              	 memset(vgs.ucCurrentPinBuf,0xff,vgs.ucCurrentPinLength);	 
          	              	 memcpy(vgs.ucCurrentPinBuf,vgs.ucApduReceiveBuf,vgs.usApduReceiveLength);	
          	              	 
          	              	 memcpy(vgs.ucApduSendBuf,usim_verify_chv1_globe,4);		  
          	              	 memcpy(&(vgs.ucApduSendBuf[4]),&vgs.ucCurrentPinLength,1);	   	                     
  						               vgs.usApduSendLength=5;	
						              	 vgs.ucCurrentChvAndUnblockOperation=CHVANDUNBLOCK_CHECK_GLOBLE_CHV_COMMAND;  	            	              	
          	              }		
          	              else
          	              if (vgs.ucCurrentChvAndUnblockOperation==CHVANDUNBLOCK_CHECK_GLOBLE_CHV_COMMAND){
          	              	 if ((vgs.usApduReceiveLength==1)&&(vgs.ucApduReceiveBuf[0]==0x20)) {//Check chv 
          	              	              memcpy(vgs.ucApduSendBuf,vgs.ucCurrentPinBuf,8);		            	              	 	   	 	                          
  						                            vgs.usApduSendLength=8;	
						              	              vgs.ucCurrentChvAndUnblockOperation=CHVANDUNBLOCK_CHECK_GLOBLE_CHV_ARGU;  
          	              	 }
          	              	 else{
          	              	 	      	    std::cout<<RED<<"Unrecognized process byte!"<<RESET<<std::endl<<std::flush;	
          	              	 	      	    return -1;
          	              	 	      	}
          	              	 	  
          	              }		
          	              else
          	              if (vgs.ucCurrentChvAndUnblockOperation==CHVANDUNBLOCK_CHECK_GLOBLE_CHV_ARGU){
          	              	 
          	              	 if (vgs.usApduReceiveLength==2){
          	              	 	   // CHV Pin 正确
          	              	 	  if (   
          	              	 	  	   ((vgs.ucApduReceiveBuf[0]==SW1_90)&&(vgs.ucApduReceiveBuf[1]==SW2_00))\
          	              	 	  	   ||(vgs.ucApduReceiveBuf[0]==SW1_91)
          	              	 	  	 ){
          	              	 	  	        memcpy(vgs.ucApduSendBuf,vgs.ucEarlyApduSendBuf,vgs.usEarlyApduSendLength);                     
  						                            vgs.usApduSendLength=vgs.usEarlyApduSendLength;	
						              	              vgs.ucCurrentChvAndUnblockOperation=CHVANDUNBLOCK_CHECK_OK; 
						              	              vgs.ucCurrentApduOperation=vgs.EarlyApduOperation;  
						              	                	              	 	     
          	              	 	     }
          	              	 	  else{
          	              	 	  	     std::cout<<RED<<"CHV FAIL!"<<RESET<<std::endl<<std::flush;	
          	              	 	  	     vgs.ucCurrentPinLength=0; 
          	              	 	  	     vgs.ucStatusCode=ERROR_ERROR_CHV_PIN;
          	              	 	  	     return -1;
          	              	 	  	}         	              	 	  	
          	                 } 
          	                 else{
          	              	 	  	     std::cout<<RED<<"CHV FAIL ,response length invalid!"<<RESET<<std::endl<<std::flush;	
          	              	 	  	     vgs.ucCurrentPinLength=0; 
          	              	 	  	     return -1;
          	              	 }  
          	              }
          	            
          	              break;
					case APDU_READ: 
						               
						               if  (IsUnsucessfulVerifyOrAuth_Fail_Usim(vgs.usApduReceiveLength,vgs.ucApduReceiveBuf)){  
         						            if (vgs.ucCurrentChvAndUnblockOperation!=CHVANDUNBLOCK_CHECK_OK){	
         						              	   vgs.EarlyApduOperation=APDU_READ;
         						              	   vgs.usEarlyApduSendLength=5;
         						              	   memcpy(vgs.ucEarlyApduSendBuf,vgs.ucApduSendBuf,5);	
         						              	   memcpy(vgs.ucApduSendBuf,usim_verify_chv1_globe_check_times,5);		  	   	                     
           						                 vgs.usApduSendLength=5;	
         						              	   vgs.ucCurrentApduOperation=APDU_VERIFY_CHV; 
         						              	   vgs.ucCurrentChvAndUnblockOperation=CHVANDUNBLOCK_CHECK_CHV_RETRYTIMES;   					             
          						                 break;
						              	    }
						               }
						               
						          
						               memcpy(&vgs.ucCurrentFileBody[vgs.usCurrentFileBodyStartOffset2ReadBinary],\
						               &vgs.ucApduReceiveBuf[1],vgs.usCurrentFileBodyEndOffset2ReadBinary-vgs.usCurrentFileBodyStartOffset2ReadBinary);
						               if (vgs.usCurrentFileBodyEndOffset2ReadBinary<vgs.usCurrentFileBodyLength){
						               	    vgs.usCurrentFileBodyStartOffset2ReadBinary=vgs.usCurrentFileBodyEndOffset2ReadBinary;
						               	    memcpy(vgs.ucApduSendBuf,usimcommand_read,2);	 
						               	  //  memcpy(vgs.ucApduSendBuf,usimcommand_read,4);	
						               	    vgs.ucApduSendBuf[2]=(unsigned char) ((vgs.usCurrentFileBodyStartOffset2ReadBinary)>>8);
						               	    vgs.ucApduSendBuf[3]=(unsigned char) vgs.usCurrentFileBodyStartOffset2ReadBinary;		
						               	    if ((vgs.usCurrentFileBodyLength-vgs.usCurrentFileBodyEndOffset2ReadBinary)>=0x100){						               	    	   
						               	    	   vgs.usCurrentFileBodyEndOffset2ReadBinary=vgs.usCurrentFileBodyEndOffset2ReadBinary+0xff;						               	    	   						               	    	    
						               	    	   vgs.ucApduSendBuf[4]=0xff;			             			    						             			      		               	    	  
						               	    }
						               	    else
						               	    {						               	    	   
						               	    	   vgs.usCurrentFileBodyEndOffset2ReadBinary=vgs.usCurrentFileBodyLength;						               	    	   						               	    	    						               	    	  
						               	    	   vgs.ucApduSendBuf[4]=vgs.usCurrentFileBodyEndOffset2ReadBinary-vgs.usCurrentFileBodyStartOffset2ReadBinary;  						           			     				               	    	  
						               	    }
						               	    vgs.usApduSendLength=5;			
						               	    break;						               	    	
						               	}
						               	if((vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].identifier[2]==0x6f)&&\
						               		 (vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].identifier[3]==0x30)
						               		 )
						               		 vgs.usApduSendLength= vgs.usApduSendLength ;
						               	if (vgs.usCurrentFileBodyLength>0x100)						          						                 
  						                 if (vgs.CurrentOperationFileProperty.property&LONG_TRANSPARENT_EF_CUT_TAIL_DEFAULT_0){	
  						                 	 for ( tmpzerostartmark=vgs.usCurrentFileBodyLength;tmpzerostartmark>0;tmpzerostartmark--)  //从后找第1个不为0的位置
  						                 	     if 	(vgs.ucCurrentFileBody[tmpzerostartmark-1]!=0)
  						                 	        break;
  						                   vgs.usCurrentFileBodyLength=	tmpzerostartmark;     	
  						                 } 	      
						                   						            
  						             vgs.ucCurrentFileBodyReponse[0]=vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-2];
  						             vgs.ucCurrentFileBodyReponse[1]=vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-1];  
  						             						               						               						               						          
						               //取出目前的文件总长（不含Vcard总长项的2字节）
                           if (FreshLengthAndReturnValue(vgs.ucVcardBuf,0, &tmpoffset)==-1)
                               	      return -1;
                           //更新当前文件体长度
   		      	             vgs.ulOffset_VcardCurrentFileBodyLength=tmpoffset+2;      		      	                 						          
  						             if  ( vgs.ulOffset_VcardCurrentFileBodyLength+4+vgs.usCurrentFileBodyLength<VCARD_MAX_LENGTH){
  						             	   //更新文件体长度内容
  						                if (FreshLengthAndReturnValue(&vgs.ucVcardBuf[vgs.ulOffset_VcardCurrentFileBodyLength],\
  						                	vgs.usCurrentFileBodyLength, &tmpoffset)==-1)
                               	      return -1;
  						                vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_BODY_RESPONSE]=vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-2];
  						             		vgs.ucVcardBuf[(vgs.OFFSET_VCARD_CURRENT_FILE_BODY_RESPONSE)+1]=vgs.ucApduReceiveBuf[(vgs.usApduReceiveLength)-1]; 
 					                   memcpy(&vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_BODY],vgs.ucCurrentFileBody,vgs.usCurrentFileBodyLength);
                               //更新文件长度内容
  						                if (FreshLengthAndReturnValue(&vgs.ucVcardBuf[vgs.ulOffset_VcardCurrentFileLength],\
  						                	vgs.usCurrentFileBodyLength+4,&tmpoffset)==-1)
                               	      return -1;
                               
  						                //更新USim文件群总长
  		      	                if (FreshLengthAndReturnValue(&vgs.ucVcardBuf[vgs.OFFSET_VCARDCURRENTUSIMGROUPTAG_LENGTH],\
  		      	             	    	              vgs.usCurrentFileBodyLength+4 ,&tmpoffset)==-1)
                               	    return -1;   
                               
                               //更新Vcard文件总长
                                if (FreshLengthAndReturnValue(vgs.ucVcardBuf,\
  		      	             	    	              vgs.usCurrentFileBodyLength+4 ,&tmpoffset)==-1)
                               	    return -1;  
                               
  		      	             }
  		      	             else{ 		      	             	    	          	   
            	             			 vgs.ucStatusCode=ERROR_VCARD_OVERFLOW;
            	            			 return -1; 
		      	             	 }
		      	             	  if ( vgs.ucUsimSessionActiveStatus==USIMSESSIONACTIVESTATUS_CAN_OPEN_AID){
		      	                //  if ( vgs.ucUsimSessionActiveStatus==USIMSESSIONACTIVESTATUS_NEEDTOREADAID){		      	             
  						             				if(
  						             				            	  	  (vgs.ucCurrentRidType==vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].nextridtype)||\
  						             				            	  	  (vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].ridtype==vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].nextridtype)||\
  						             				            	  	  ( vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].nextridtype==RIDTYPE_NONEEDAID)
  						             				            	  )
  						             				            	  	vgs.ucCurrentApduOperation=APDU_IDLE;
  						             				            	  else{
  						             				            	  	   // memcpy(vgs.ucApduSendBuf,usimselect_ByDFName_NoDataReturn,4);	
  						             				            	  	    for (tmpaidcnt=0;tmpaidcnt<APPICAITON_NUMBER_MAX;tmpaidcnt++)
  		      	             	  	                          if ((vgs.aid_list[tmpaidcnt].length!=0)&&\
  		      	             	  	                          	  (vgs.aid_list[tmpaidcnt].ridtype==vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].nextridtype)
  		      	             	  	                          )
  		      	             	  	                        	   break; 
  		      	             	  	                        if (tmpaidcnt<APPICAITON_NUMBER_MAX){    	  
  		      	             	  	                          vgs.ucApduSendBuf[4]=vgs.aid_list[tmpaidcnt].length;	
  						                                            vgs.usApduSendLength=5;	
  						             				           	            vgs.ucCurrentApduOperation=APDU_SELECT_COMMAND; 
  						             				           	            vgs.ucExpectRidType=vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].nextridtype;
  						             				           	            vgs.ucUsimSessionActiveStatus=USIMSESSIONACTIVESTATUS_EXPECT_OPEN_AID;
  						             				           	            vgs.ucCurrentAidNumber=tmpaidcnt;
  						             				           	            memcpy(vgs.ucApduSendBuf,usimselect_ByDFName_NoDataReturn,4);	
  		      	             	  	                        }
  		      	             	  	                        else		
  						             		                              vgs.ucCurrentApduOperation=APDU_IDLE;  	   
  						             				            	  	}   						             				            	
  						             	} 
  						             	else		
  						             		vgs.ucCurrentApduOperation=APDU_IDLE;              	   	             
 													 //vgs.ucCurrentApduOperation=APDU_IDLE;  					             
 						               break;
					case APDU_READ_RECORD: 
						               if  (IsUnsucessfulVerifyOrAuth_Fail_Usim(vgs.usApduReceiveLength,vgs.ucApduReceiveBuf)){  
         						            if (vgs.ucCurrentChvAndUnblockOperation!=CHVANDUNBLOCK_CHECK_OK){	
         						              	   vgs.EarlyApduOperation=APDU_READ_RECORD;
         						              	   vgs.usEarlyApduSendLength=5;
         						              	   memcpy(vgs.ucEarlyApduSendBuf,vgs.ucApduSendBuf,5);	
         						              	   memcpy(vgs.ucApduSendBuf,usim_verify_chv1_globe_check_times,5);		  	   	                     
           						                 vgs.usApduSendLength=5;	
         						              	   vgs.ucCurrentApduOperation=APDU_VERIFY_CHV; 
         						              	   vgs.ucCurrentChvAndUnblockOperation=CHVANDUNBLOCK_CHECK_CHV_RETRYTIMES;   					             
          						                 break;
						              	    }
						               }
						
						               if(!vgs.ucCurrentRecordSerialNumber){
						               	     //取出目前的文件总长（不含Vcard总长项的2字节）
                                 if (FreshLengthAndReturnValue(vgs.ucVcardBuf,0, &tmpoffset)==-1)
                               	      return -1;
                               	 
                               	 if (tmpoffset+2+ 2<VCARD_MAX_LENGTH){  // 后面的2 指记录响应状态字长度
						               	         vgs.ucVcardBuf[tmpoffset+2]=vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-2]; //保存记录读状态字
						               	         vgs.ucVcardBuf[tmpoffset+2+1]=vgs.ucApduReceiveBuf[vgs.usApduReceiveLength-1];						               	         
						      						         //更新文件长度内容
  						                  if (FreshLengthAndReturnValue(&vgs.ucVcardBuf[vgs.ulOffset_VcardCurrentFileLength],\
  						                     	2,&tmpoffset)==-1)
                               	      return -1;						      						      
                                      //更新USim文件群总长
  		      	                if (FreshLengthAndReturnValue(&vgs.ucVcardBuf[vgs.OFFSET_VCARDCURRENTUSIMGROUPTAG_LENGTH],\
  		      	             	    	              2 ,&tmpoffset)==-1)
                               	    return -1; 
                               	    
                               	  //更新Vcard文件总长
                                if (FreshLengthAndReturnValue(vgs.ucVcardBuf,\
  		      	             	    	              2 ,&tmpoffset)==-1)
                               	    return -1;                                                                    
  						                   }
  						                   else{ 		      	             	    	          	   
            	             								vgs.ucStatusCode=ERROR_VCARD_OVERFLOW;
            	            								 return -1; 
		      	             	    	 }	
  						             }
  						             //...............  						            
  						             //20180708
  						             if (GetVcardFileProperty_WithUsimRidType(vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].length\
		      	                        ,vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].identifier	, \
		      	                        vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].ridtype	,&file1)==1){ 
  						        //     if (GetVcardFileProperty(vgs.file_operation_list[vgs.ucCurrentFileSerialNumber].identifier, &file1)==1){  						             	    
  						             	
  						             	     if (file1.property&SPARE_MODE_LINEARFIXED_CYCLIC){   
  						             	     	//优化Vcard中线性定长/循环文件，如果记录为缺省值，则不保存记录 
  						             	     	     if (file1.property&STARTBYTE_1_LINEARFIXED_CYCLIC)
  						             	     	     	      tmprecordcontextcounter=1;
  						             	     	     	else {     
  						             	     	       if (file1.property&STARTBYTE_2_LINEARFIXED_CYCLIC)
  						             	     	     	      tmprecordcontextcounter=2;
  						             	     	         else 
  						             	     	      
  						             	     	     	      tmprecordcontextcounter=0;
  						             	     	     	 }
  						             	     	     if (file1.property&DEFAULT_FF_LINEARFIXED_CYCLIC)
  						             	     	     	    	for (;tmprecordcontextcounter<vgs.ucCurrentRecordLength;tmprecordcontextcounter++){ 
  						             	                        if (vgs.ucApduReceiveBuf[tmprecordcontextcounter+1]!=0xFF)
  						             	      	                     break;
  						                                }
  						                         else        
  						                         if (file1.property&DEFAULT_0_LINEARFIXED_CYCLIC)
  						             	     	     	    	for (;tmprecordcontextcounter<vgs.ucCurrentRecordLength;tmprecordcontextcounter++){ 
  						             	                        if (vgs.ucApduReceiveBuf[tmprecordcontextcounter+1]!=0)
  						             	      	                     break;
  						                                }  						                                
  						                         else     
  						                         if (file1.property&DEFAULT_UNKOWN_LINEARFIXED_CYCLIC)
  						                         	   if  (vgs.ucCurrentLCEFReordDefault==LCEFREORDDEAULT_UNKNOWN){ 
  						                         	   	  trccff=tmprecordcontextcounter;
  						                         	   	  trcc0=tmprecordcontextcounter;
  						             	     	     	    	for (;trcc0<vgs.ucCurrentRecordLength;trcc0++){ 
  						             	                        if (vgs.ucApduReceiveBuf[trcc0+1]!=0)
  						             	      	                     break;
  						                                }
  						                                for (;trccff<vgs.ucCurrentRecordLength;trccff++){ 
  						             	                        if (vgs.ucApduReceiveBuf[trccff+1]!=0xff)
  						             	      	                     break;
  						                                }
  						                                tmprecordcontextcounter=(trccff>trcc0)?trccff:trcc0;
  						                             }   
  						                           
  						             	     }	     	      
  						             } 						               
  						             if (tmprecordcontextcounter<vgs.ucCurrentRecordLength){
  						             	    //取出目前的文件总长（不含Vcard总长项的2字节）
                                 if (FreshLengthAndReturnValue(vgs.ucVcardBuf,0, &tmpoffset)==-1)
                               	      return -1;
                               	  //更新当前记录序列号偏置
   		      	                  vgs.ulOffset_VcardCurrentRecordSerialNumber=tmpoffset+2;       
  						             	    //vgs.ulOffset_VcardCurrentRecordSerialNumber=((unsigned long)vgs.ucVcardBuf[0]<<16)+((unsigned long)vgs.ucVcardBuf[1]<<8)+(unsigned long)vgs.ucVcardBuf[2];
  						             	    if  ( vgs.ulOffset_VcardCurrentRecordSerialNumber+2+vgs.ucCurrentRecordLength<VCARD_MAX_LENGTH){ //2 记录m 的记录号和记录m的长度占用字节数
  						             	    			vgs.ucVcardBuf[vgs.ulOffset_VcardCurrentRecordSerialNumber]=vgs.ucCurrentRecordSerialNumber+1;
  						             	    			vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_RECORD_LENGTH]=vgs.ucCurrentRecordLength;
  						             	    			memcpy(&vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_RECORD],&vgs.ucApduReceiveBuf[1],vgs.ucCurrentRecordLength);
  						             	     //更新文件长度内容
  						                  if (FreshLengthAndReturnValue(&vgs.ucVcardBuf[vgs.ulOffset_VcardCurrentFileLength],\
  						                     	2+vgs.ucCurrentRecordLength,&tmpoffset)==-1)
                               	      return -1;
  						             	    /*
  						             	    			vgs.ucVcardBuf[vgs.ulOffset_VcardCurrentFileLength]= (((unsigned short)vgs.ucVcardBuf[vgs.ulOffset_VcardCurrentFileLength]<<8)+
  		      	                  			(unsigned short)vgs.ucVcardBuf[vgs.ulOffset_VcardCurrentFileLength+1]+2+(unsigned short) vgs.ucCurrentRecordLength)>>8;
  		      	                  			vgs.ucVcardBuf[vgs.ulOffset_VcardCurrentFileLength+1]= ((((unsigned short)vgs.ucVcardBuf[vgs.ulOffset_VcardCurrentFileLength]<<8)+
  		      	                  			(unsigned short)vgs.ucVcardBuf[vgs.ulOffset_VcardCurrentFileLength+1]+2+(unsigned short) vgs.ucCurrentRecordLength)<<8)>>8;
  		      	                     */ 
  		      	                     //更新USim文件群总长
  		      	                if (FreshLengthAndReturnValue(&vgs.ucVcardBuf[vgs.OFFSET_VCARDCURRENTUSIMGROUPTAG_LENGTH],\
  		      	             	    	              2+vgs.ucCurrentRecordLength ,&tmpoffset)==-1)
                               	    return -1;
                               	    
                               	     //更新Vcard文件总长
                                if (FreshLengthAndReturnValue(vgs.ucVcardBuf,\
  		      	             	    	              2+vgs.ucCurrentRecordLength ,&tmpoffset)==-1)
                               	    return -1;  
                               	    
                               	    /*
  						             	    			vgs.ucVcardBuf[0]= (((unsigned long)vgs.ucVcardBuf[0]<<16)+((unsigned long)vgs.ucVcardBuf[1]<<8)+(unsigned long)vgs.ucVcardBuf[2]+2+(unsigned long) vgs.ucCurrentRecordLength)>>16; //修改Vcard文件总长
  		      	                  			vgs.ucVcardBuf[1]= ((((unsigned long)vgs.ucVcardBuf[0]<<16)+((unsigned long)vgs.ucVcardBuf[1]<<8)+(unsigned long)vgs.ucVcardBuf[2]+2+(unsigned long) vgs.ucCurrentRecordLength)<<8)>>16; 
  		      	                  			vgs.ucVcardBuf[2]= ((((unsigned long)vgs.ucVcardBuf[0]<<16)+((unsigned long)vgs.ucVcardBuf[1]<<8)+(unsigned long)vgs.ucVcardBuf[2]+2+(unsigned long) vgs.ucCurrentRecordLength)<<16)>>16; 
  						                       */
  						                        //分析数据内容，取出AID 
  						                   if(vgs.ucUsimSessionActiveStatus==USIMSESSIONACTIVESTATUS_NEEDTOREADAID){  						                        	  						                        
  						                        tmpt= GetTagLocation_inACP(TAG_AID,&vgs.ucApduReceiveBuf[1], (int )vgs.ucCurrentRecordLength-2);
  						                        if (tmpt==-1)
  						                           	std::cout<<RED<<" Can not find AID at record Number "<< (unsigned short)vgs.ucCurrentRecordSerialNumber<<" in EFdir"<<std::endl<<std::flush;	
  						                       	   //   return -1;
  						                       	   else{
  						                       	   	    if (vgs.ucApduReceiveBuf[1+tmpt+1]>0x10){  //AID Length
          						                             std::cout<<RED<<" AID Length Error"<<std::endl<<std::flush;	
          						                       	     return -1;
          						                       	}
  						                       	 tmpreval=GetRidTypeFromAid(&(vgs.ucApduReceiveBuf[1+tmpt+1+1]),vgs.ucApduReceiveBuf[1+tmpt+1]);
          						                 if ((tmpreval==-1)||(tmpreval==RIDTYPE_UNRECOGNIZED)||(tmpreval==RIDTYPE_NONEEDAID)){  //如果RID 不在标准 TS 101.220中 
          						                        std::cout<<RED<<" CheckRid error"<<std::endl<<std::flush;	         						                       	                                          
          						                  }
          						                 else {
                                              //查找tmpaiditem 中已经存在同样的RID
                                             for (tmpaid_itemnbr=0;tmpaid_itemnbr<APPICAITON_NUMBER_MAX;tmpaid_itemnbr++){
                                         	     if  (!char_arrayncmp (&(vgs.ucApduReceiveBuf[1+tmpt+1+1]) ,&(vgs.aid_list[tmpaid_itemnbr].aid[0]), 5 ))
                                         	  	    break;
                                         	   }
                                         	     //如果未找到同样RID，则将AID加入tmpaid_itemnbr 
                                         	   if (tmpaid_itemnbr==APPICAITON_NUMBER_MAX){
                                         		     memcpy(&(vgs.aid_list[vgs.ucCurrentProcessAidNumber].aid),&(vgs.ucApduReceiveBuf[1+tmpt+1+1]),vgs.ucApduReceiveBuf[1+tmpt+1]);
                                         		     vgs.aid_list[vgs.ucCurrentProcessAidNumber].length=vgs.ucApduReceiveBuf[1+tmpt+1];
                                         		 
                                                 vgs.aid_list[vgs.ucCurrentProcessAidNumber].ridtype=tmpreval;
                                         		      vgs.ucCurrentProcessAidNumber++;
                                         		    //  vgs.ucUsimSessionActiveStatus=USIMSESSIONACTIVESTATUS_CAN_OPEN_AID;
                                         	   }
                                         }	                     	        						                 	         					                  	  						                  	
  						                           }	
  						                     }      				                   						                   						                  
  						                  }
  						                  else{ 		      	             	    	          	   
            	             			 vgs.ucStatusCode=ERROR_VCARD_OVERFLOW;
            	            			 return -1; 
		      	             	      }   						                    
  						             	}
  						             	else{
  						             		    if  (vgs.ucCurrentLCEFReordDefault==LCEFREORDDEAULT_UNKNOWN){
  						             		    	 if (trccff==vgs.ucCurrentRecordLength)
  						             		    	 	  vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_ACCESS_STATUS]|=VCARD_FLAG_LCEFREORDDEAULT_FF;
  						             		    	 else
  						             		    	 if (trcc0==vgs.ucCurrentRecordLength)
  						             		    	 	  vgs.ucVcardBuf[vgs.OFFSET_VCARD_CURRENT_FILE_ACCESS_STATUS]|=VCARD_FLAG_LCEFREORDDEAULT_0;
  						             		    	 vgs.ucCurrentLCEFReordDefault==LCEFREORDDEAULT_KNOWN;
  						             		    }	 	
  						             		}
	             	
  						              vgs.ucCurrentRecordSerialNumber++;
  						              if (vgs.ucCurrentRecordLength==0)   //增加 判断以免除以0 
  						              	   return -1; 
  						              else{	   
  						                  if (vgs.ucCurrentRecordSerialNumber<vgs.usCurrentFileBodyLength/(unsigned short)vgs.ucCurrentRecordLength) 						             	         
  						            					 vgs.ucApduSendBuf[2]=(unsigned char)vgs.ucCurrentRecordSerialNumber+1; 
  						             			else  {  
  						             				            
  						             				            vgs.ucCurrentRecordSerialNumber=0; 
  						             				            vgs.ucCurrentLCEFReordDefault=LCEFREORDDEAULT_UNKNOWN;
  						             				            if ( vgs.ucUsimSessionActiveStatus==USIMSESSIONACTIVESTATUS_NEEDTOREADAID){
  						             				            	  vgs.ucUsimSessionActiveStatus=USIMSESSIONACTIVESTATUS_CAN_OPEN_AID;
  						             				        //    if ( vgs.ucUsimSessionActiveStatus==USIMSESSIONACTIVESTATUS_CAN_OPEN_AID){
  						             				            	  if(
  						             				            	  	  (vgs.ucCurrentRidType==vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].nextridtype)||\
  						             				            	  	  (vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].ridtype==vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].nextridtype)||\
  						             				            	  	  ( vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].nextridtype==RIDTYPE_NONEEDAID)
  						             				            	  ){
  						             				            	  	vgs.ucCurrentApduOperation=APDU_IDLE;
  						             				            	  }
  						             				            	  else{
  						             				            	  	 //  memcpy(vgs.ucApduSendBuf,usimselect_ByDFName_NoDataReturn,4);	
  						             				            	  	    for (tmpaidcnt=0;tmpaidcnt<APPICAITON_NUMBER_MAX;tmpaidcnt++)
  		      	             	  	                          if ((vgs.aid_list[tmpaidcnt].length!=0)&&\
  		      	             	  	                          	  (vgs.aid_list[tmpaidcnt].ridtype==vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].nextridtype)
  		      	             	  	                          )
  		      	             	  	                        	   break; 
  		      	             	  	                        if (tmpaidcnt<APPICAITON_NUMBER_MAX){    	  
  		      	             	  	                          vgs.ucApduSendBuf[4]=vgs.aid_list[tmpaidcnt].length;	
  						                                            vgs.usApduSendLength=5;	
  						             				           	            vgs.ucCurrentApduOperation=APDU_SELECT_COMMAND; 
  						             				           	            vgs.ucExpectRidType=vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].nextridtype;
  						             				           	            vgs.ucUsimSessionActiveStatus=USIMSESSIONACTIVESTATUS_EXPECT_OPEN_AID;
  						             				           	            vgs.ucCurrentAidNumber=tmpaidcnt;
  						             				           	            memcpy(vgs.ucApduSendBuf,usimselect_ByDFName_NoDataReturn,4);	
  		      	             	  	                        } 
  		      	             	  	                        else  
  						             	                                 vgs.ucCurrentApduOperation=APDU_IDLE;	   
  						             				            	  	}   						             				            	
  						             				            	}
  						             				            	else  
  						             	                     vgs.ucCurrentApduOperation=APDU_IDLE;
  						             				           
  						             	                     
  						             	    }
  						             	 }   
						                 break;
  		    
            default:            	        
            	              vgs.ucStatusCode=ERROR_UNRECOGNIZEDAPDUOPERATION;
            	              return -1;
            	              break;  
          } 
	  if (vgs.ucCurrentApduOperation==APDU_IDLE){
	  	       vgs.ucCurrentUsimFileSerialNumber++; 
	               	//如果属于AID下的文件， 但文件未被该卡的AID支持， 则跳到下一个,直到找到合法的文件或到文件尾
	            while (!(( vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].identifier[0]==0)&&\
	  	     	               ( vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].identifier[1]==0))){    	
	         	       if (vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].ridtype!=RIDTYPE_NONEEDAID){	  		
	  	                    for (tmpaidcnt=0;tmpaidcnt<APPICAITON_NUMBER_MAX;tmpaidcnt++)
  		      	                if ((vgs.aid_list[tmpaidcnt].length!=0)&&\
  		      	                   (vgs.aid_list[tmpaidcnt].ridtype==vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].ridtype)
  		      	                   )
  		      	                  break; 
  		                    if (tmpaidcnt==APPICAITON_NUMBER_MAX)
  		      		                 vgs.ucCurrentUsimFileSerialNumber++;
  		      		          else
  		      		          	 break;
	  	             }
	  	             else
	  	             	  break;
	  	         }
	  	     if(!(( vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].identifier[0]==0)&&\
	  	     	( vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].identifier[1]==0))){
	  	   	          memcpy(vgs.ucApduSendBuf,vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].select_command,4);	
	  	   	          vgs.ucApduSendBuf[4]=vgs.Usim_file_operation_list[vgs.ucCurrentUsimFileSerialNumber].length;
  						      vgs.usApduSendLength=5;	
  						      vgs.ucCurrentApduOperation=APDU_SELECT_COMMAND;	
  			   }
  			   else {
  			   	
  			   	//2018.06.13
  			   	    if (
  			   	    	  (vgs.ucHandleMode&CARDMODE_UIM) ||
  			   	    	(vgs.ucHandleMode&CARDMODE_SIM)
  			   	    	) {     //等待复位切换到Uim,Sim mode 操作
  			   	    	
  			   	    	 vgs.ucVcardGeneratorStatus=VCARD_GENERATOR_STATUS_WAITING_FAST_RESET_FOR_SWITCH2SIM;
  			   	    	 vgs.ucApduInteractiveStatus=AIAS_STOP;	
  			   	    }
  			   	    else{  			   	 
  			   	           //20200330
  			   	           //if ((vgs.ucCurrentUsimMode_Invalid &USIMMODE_INVALID_3GPP) && (vgs.ucCurrentUsimMode_Invalid &USIMMODE_INVALID_3GPP2)){
  			   	           if (
  			   	           	((vgs.ucCurrentUsimMode_Invalid &USIMMODE_INVALID_3GPP) && (!(vgs.ucCurrentUsimMode_Invalid &USIMMODE_3GPP2_FILE_EXIST)))||\
  			   	         	  ((vgs.ucCurrentUsimMode_Invalid &USIMMODE_INVALID_3GPP2) && (!(vgs.ucCurrentUsimMode_Invalid &USIMMODE_3GPP_FILE_EXIST)))||\
  			   	         	  ((vgs.ucCurrentUsimMode_Invalid &USIMMODE_INVALID_3GPP2) && ((vgs.ucCurrentUsimMode_Invalid &USIMMODE_INVALID_3GPP)))
  			   	         	    ){
	   	                          std::cout<<RED<<"Note! Usim mode do not support"<<RESET<<std::endl<<std::flush;	
	   	                          vgs.ucVcardBuf[OFFSET_VCARD_MAINTAIN_INFORMATION] &=~(VG_HANDLEICC_USIMMODE_MAINTAIN);
	   	                      }         	    	   
  			   	           
  			   	           vgs.ucVcardGeneratorStatus=VCARD_GENERATOR_STATUS_SUCCESS;
  			   	           AddPin2Vcard();
  			   	    
  			   	    }
  			   	    vgs.ucVcardBuf[OFFSET_VCARD_MAINTAIN_INFORMATION]|=VC_DATA_USIMMODE_MAINTAIN;	
  			   	    return 1;            
  			   }
	  }
	  if (vgs.ucCurrentChvAndUnblockOperation==CHVANDUNBLOCK_CHECK_GLOBLE_CHV_REQUEST_PIN)
	  	vgs.ucApduInteractiveStatus=AIAS_WAIT_PIN_INPUT;	
	  else
	  		
	  vgs.ucApduInteractiveStatus=AIAS_SENDDATAISREADY;	
	  vgs.ucWaitGetInteractiveStartTime=GetTickCount();
	  return 1; 
	}
//};
int VcardGenerator::AddPin2Vcard(){

 unsigned short tmpoffset;
 unsigned long ulOffset_VcardPinTag;
	if (vgs.ucCurrentPinLength==0)
		return 0;
	
	if (vgs.ucCurrentPinLength>8)
		return -1;
	  //取出目前的文件总长（不含Vcard总长项的2字节）
 
  if (FreshLengthAndReturnValue(vgs.ucVcardBuf,0, &tmpoffset)==-1)
      return -1;	
	
	ulOffset_VcardPinTag =tmpoffset+2; //2 为Vcard长度所占字节数
                 	// 更新Vcard 长度
  if (FreshLengthAndReturnValue(vgs.ucVcardBuf,1+2+vgs.ucCurrentPinLength, &tmpoffset)==-1)  // 1 unsigned char TAG_PIN+  2 unsigned char PIN Length,+ PIN 
     return -1;
  	
	
  vgs.ucVcardBuf[ulOffset_VcardPinTag] =TAG_PIN; 
  vgs.ucVcardBuf[ulOffset_VcardPinTag+1]=0;
  vgs.ucVcardBuf[ulOffset_VcardPinTag+2]=vgs.ucCurrentPinLength;
	memcpy(&(vgs.ucVcardBuf[ulOffset_VcardPinTag+3]),vgs.ucCurrentPinBuf,vgs.ucCurrentPinLength);
	return 1;
	
}	

int VcardGenerator::ProcessResponse(){	
  if (vgs.ucCurrentHandleCardMode&CARDMODE_USIM){
  	// if (ProcessResponse_USim()) 
  	//2018.1.15  
  	 if (ProcessResponse_USim()==1)	
  	 	  return 1;
  }
  else{
        if (vgs.ucCurrentHandleCardMode&CARDMODE_SIM){
        	//2018.1.15  
  	       //if (ProcessResponse_Sim())
  	       if (ProcessResponse_Sim()==1)	
  	 	        return 1;
  	 	  }
        else{ 
        	    if (vgs.ucCurrentHandleCardMode&CARDMODE_UIM)
        	    	//2018.1.15  
  	            // if (ProcessResponse_Uim())
  	            if (ProcessResponse_Uim()==1)
  	 	              return 1;
        	
  	 	  }
  	 	 } 
   
 // return -1;	
 //2018.1.15  	 	 
 return 0;	  	
	}			

/**************************************************************************** 
* 函数名称 : ProcessVcardGenerationT0FromSimcard
* 类       ：VcardGenerator
* 功能描述 : 生成Vcard （T=0， SourceFrom：SimCard） 
* 参    数 : 
* 参    数 : 
* 参    数 : 
* 返 回 值 : 正确 返回 1  不正确 返回 -1
* 作    者 : 王翔
* 设计日期 : 
* 修改日期		  修改人		   修改内容  
 *****************************************************************************/
int VcardGenerator::ProcessVcardGenerationT0FromSimcard(){
unsigned short tmpoffset;
	//if (vgs.ucVcardGeneratorStatus==VCARD_GENERATOR_STATUS_PROCESSING){	 	
	 if ((vgs.ucVcardGeneratorStatus==VCARD_GENERATOR_STATUS_PROCESSING)||(vgs.ucVcardGeneratorStatus==VCARD_GENERATOR_STATUS_PROCESSING_REQUEST_PIN)){	     
	 	    if (vgs.ucApduInteractiveStatus==AIAS_GETDATAISREADY){
	 	         	if (VerifyResponse()){
	 	         		   if (!ProcessResponse()){
	 	         		       vgs.ucVcardGeneratorStatus=VCARD_GENERATOR_STATUS_ERROR;
	 	         		       return -1;
	 	         		  }
	 	         		}
	 	         	else{
	 	         		    vgs.ucVcardGeneratorStatus=VCARD_GENERATOR_STATUS_ERROR;
	 	         		    return -1;
	 	         		}	 	        		
	 	    }
	 	    else	{
		              vgs.ucVcardGeneratorStatus=VCARD_GENERATOR_STATUS_ERROR;
		      	      return -1;
	      }
	 	    	 	     	     		 	          	 	
	}
	else	{
		      if (vgs.ucVcardGeneratorStatus==VCARD_GENERATOR_STATUS_WAITING_FAST_RESET_FOR_SWITCH2SIM){	 
		         if (vgs.ucApduInteractiveStatus==AIAS_RESET_CARD_COMPLETED){
		         	   vgs.ucCurrentChvAndUnblockOperation=CHVANDUNBLOCK_CHECK_CHV_NO;
		         	   vgs.ucVcardGeneratorStatus=VCARD_GENERATOR_STATUS_PROCESSING;
		         	   //VG 假设只能有Sim， Uim互斥。 （Uim 中如果需要GSM目录下的内容，在vcardfile_identifier_uim 中包含）
		         	   if (vgs.ucHandleMode&CARDMODE_SIM)
		         	      vgs.ucCurrentHandleCardMode=CARDMODE_SIM;
		         	   else  {
		         	   	    if (vgs.ucHandleMode&CARDMODE_UIM)
		         	           vgs.ucCurrentHandleCardMode=CARDMODE_UIM;		         	   	
		         	   	}
		         	   
		         	    // 取出Vcard 长度
                 if (FreshLengthAndReturnValue(vgs.ucVcardBuf,0, &tmpoffset)==-1)
                   	return -1;
                   	
                 vgs.ulOffset_VcardCurrentSimGroupTag =tmpoffset+2; //2 为Vcard长度所占字节数 
                 if (vgs.ucHandleMode&CARDMODE_SIM)
                      vgs.ucVcardBuf[vgs.ulOffset_VcardCurrentSimGroupTag] =TAG_VCARDCURRENTSIMGROUP; 
                  else  {
		         	   	    if (vgs.ucHandleMode&CARDMODE_UIM)
		         	            vgs.ucVcardBuf[vgs.ulOffset_VcardCurrentSimGroupTag] =TAG_VCARDCURRENTUIMGROUP; 	         	   	
		         	   	}	

                 	// 更新Vcard 长度
                 if (FreshLengthAndReturnValue(vgs.ucVcardBuf,3, &tmpoffset)==-1)
                   	return -1;
                   	
                  memcpy(vgs.ucApduSendBuf,command_select,5);	
  	              vgs.usApduSendLength=5;	
   	             vgs.ucCurrentApduOperation=APDU_SELECT_COMMAND;			 
                 vgs.ucWaitGetInteractiveStartTime=GetTickCount();	           
                 vgs.ucApduInteractiveStatus=AIAS_SENDDATAISREADY;
		         	   
		         }
		      }
		      else {
		         	if (vgs.ucVcardGeneratorStatus==VCARD_GENERATOR_STATUS_WAITING_FAST_RESET_FOR_CARD_INITIAL_STATUS){	 
		              if (vgs.ucApduInteractiveStatus==AIAS_RESET_CARD_COMPLETED){
		              	 vgs.ucCurrentChvAndUnblockOperation=CHVANDUNBLOCK_CHECK_CHV_NO;
		              	 //20200330
  			   	       //    if ((vgs.ucCurrentUsimMode_Invalid &USIMMODE_INVALID_3GPP) && (vgs.ucCurrentUsimMode_Invalid &USIMMODE_INVALID_3GPP2)){
  			   	       if (
  			   	           	((vgs.ucCurrentUsimMode_Invalid &USIMMODE_INVALID_3GPP) && (!(vgs.ucCurrentUsimMode_Invalid &USIMMODE_3GPP2_FILE_EXIST)))||\
  			   	         	  ((vgs.ucCurrentUsimMode_Invalid &USIMMODE_INVALID_3GPP2) && (!(vgs.ucCurrentUsimMode_Invalid &USIMMODE_3GPP_FILE_EXIST)))||\
  			   	         	  ((vgs.ucCurrentUsimMode_Invalid &USIMMODE_INVALID_3GPP2) && ((vgs.ucCurrentUsimMode_Invalid &USIMMODE_INVALID_3GPP)))
  			   	         	    ){
	   	                          std::cout<<RED<<"Note! Usim mode do not support!"<<RESET<<std::endl<<std::flush;	
	   	                          vgs.ucVcardBuf[OFFSET_VCARD_MAINTAIN_INFORMATION] &=~(VG_HANDLEICC_USIMMODE_MAINTAIN);
	   	                      }    
	   	                      
		         	       vgs.ucVcardGeneratorStatus=VCARD_GENERATOR_STATUS_SUCCESS;
		         	       vgs.ucCurrentHandleCardMode=CARDMODE_UNKOWN;		         	   	         	   
		              }
		          }
		      else{
		          if (vgs.ucVcardGeneratorStatus==VCARD_GENERATOR_STATUS_ERROR)
		      	      return -1;
		      }	
		    }      
	}
	return 1;
}		

/**************************************************************************** 
* 函数名称 : ProcessVcardGeneration
* 类       ：VcardGenerator
* 功能描述 : 生成Vcard 
* 参    数 : 
* 参    数 : 
* 参    数 : 
* 返 回 值 : 正确 返回 1  不正确 返回 -1
* 作    者 : 王翔
* 设计日期 : 
* 修改日期		  修改人		   修改内容  
 *****************************************************************************/
int VcardGenerator::ProcessVcardGeneration(){
	 
	if (vgs.ucSimcardTransmissionProtocol==SIMCARD_TRANSMISSION_PROTOCOL_T1){
	 	    ProcessVcardGenerationT1();	 	 
	}
	else{ 
		  if (vgs.ucVcardSource==VCARD_SOURCE_DISK) 
		       ProcessVcardGenerationT0FromDisk();	
	    else {
	         if (ProcessVcardGenerationT0FromSimcard()!=1){
	         	    std::cout<<YELLOW<<"Warning! ProcessVcardGenerationT0FromSimcard,Something is wrong!"<<RESET<<std::endl<<std::flush;	
	         	    return -1;	  
	         	}
	    }
	  
	}    
	return 1;
}

/**************************************************************************** 
* 函数名称 : PrintFileOperationList
* 类       ：VcardGenerator
* 功能描述 : 打印Vcard 操作列表 （调试用）
* 参    数 : 
* 参    数 : 
* 参    数 : 
* 返 回 值 : 正确 返回 1  不正确 返回 -1
* 作    者 : 王翔
* 设计日期 : 
* 修改日期		  修改人		   修改内容  
 *****************************************************************************/
void VcardGenerator::PrintFileOperationList(){
      for (int a=0;a<FILEOPERATIONMAX;a++){
   		        if (!((vgs.file_operation_list[a].identifier[0]==0)&&(vgs.file_operation_list[a].identifier[1]==0)))
   		   	
   			          std::cout<<std::hex <<(unsigned short)vgs.file_operation_list[a].identifier[0]<<(unsigned short)vgs.file_operation_list[a].identifier[1]<<std::endl ;
   			      else
   			      	break;  		   		
   		}
}

/**************************************************************************** 
* 函数名称 : PrintUsimFileOperationList
* 类       ：VcardGenerator
* 功能描述 : 打印Vcard 操作列表 （调试用）
* 参    数 : 
* 参    数 : 
* 参    数 : 
* 返 回 值 : 正确 返回 1  不正确 返回 -1
* 作    者 : 王翔
* 设计日期 : 
* 修改日期		  修改人		   修改内容  
 *****************************************************************************/
void VcardGenerator::PrintUsimFileOperationList(){
      for (int a=0;a<FILEOPERATIONMAX;a++){
   		        if (!((vgs.Usim_file_operation_list[a].identifier[0]==0)&&(vgs.Usim_file_operation_list[a].identifier[1]==0))){
   		   	        for (unsigned char b=0; b<vgs.Usim_file_operation_list[a].length;b++)
   			               std::cout<<std::hex <<(unsigned short)vgs.Usim_file_operation_list[a].identifier[b];
   			          std::cout<<std::hex <<"  (ridtype="<<(unsigned short)vgs.Usim_file_operation_list[a].ridtype<<")  ";
   			          std::cout<<std::hex <<"  (nextridtype="<<(unsigned short)vgs.Usim_file_operation_list[a].nextridtype<<")  ";
   			          std::cout<<std::hex <<"  "<<(unsigned short)vgs.Usim_file_operation_list[a].length<<"  ";
   			          
   			          	
         				 	std::cout<<std::hex <<(unsigned short)	vgs.Usim_file_operation_list[a].select_command[0]<<"  ";
   								std::cout<<std::hex <<(unsigned short)	vgs.Usim_file_operation_list[a].select_command[1]<<"  ";
   								std::cout<<std::hex <<(unsigned short)	vgs.Usim_file_operation_list[a].select_command[2]<<"  ";
   								std::cout<<std::hex <<(unsigned short)	vgs.Usim_file_operation_list[a].select_command[3]<<"  ";
   								std::cout<<std::hex <<(unsigned short)	vgs.Usim_file_operation_list[a].select_command[4]<<std::endl ;
   					   			          	
   			      }         	
   			      else
   			      	break;
   		}
      std::cout<<std::endl ;
   		   		
}

//获取VcardGenerator状态 
unsigned char VcardGenerator::GetVcardGeneratorStatus(){
    return vgs.ucVcardGeneratorStatus;
}
void VcardGenerator::SetVcardGeneratorStatus(unsigned char vcardgeneratorstatus){
     vgs.ucVcardGeneratorStatus=vcardgeneratorstatus;
}

//获取VcardGenerator 交互数据状态 
unsigned char VcardGenerator::GetApduInteractiveStatus(){
    return vgs.ucApduInteractiveStatus;
}

void  VcardGenerator::SetApduInteractiveStatus(unsigned char apduinteractivestatus ){
     vgs.ucApduInteractiveStatus=apduinteractivestatus;
}

//获取准备发送给Sim card 的数据 
int VcardGenerator::GetSendDataToSim(unsigned char *sendbuf,unsigned short *sendlength){
	
     memcpy(sendbuf,vgs.ucApduSendBuf,vgs.usApduSendLength);
     (*sendlength)=vgs.usApduSendLength;
     return 1;
}

//传递收到的Sim card 的数据 给VcardGenerator
int VcardGenerator::SetReceiveDataToVgs(unsigned char *revbuf,unsigned short revlength){
	if (revlength<=APDU_BUF_MAX_LENGTH){
     memcpy(vgs.ucApduReceiveBuf,revbuf,revlength);
     vgs.usApduReceiveLength=revlength;
     return 1;
   }
  else
  	return -1; 
}

//获取Vcard 长度 
unsigned long VcardGenerator::GetVcardLengh( ){
	if (vgs.ucVcardGeneratorStatus==VCARD_GENERATOR_STATUS_SUCCESS)
		return (((unsigned long)vgs.ucVcardBuf[0]<<8)+((unsigned long)vgs.ucVcardBuf[1]));
  else
  	return 0; 
}

int VcardGenerator::SetVcardBuffToVGS(unsigned char *buff_vgsm, unsigned short len_vgsm)                                                                                    
{
    if (buff_vgsm != NULL || len_vgsm > 0)
    {
        memcpy(vgs.ucVcardBuf, buff_vgsm, len_vgsm);
    }
    return 0;
}



//获取Vcard 数据 


int VcardGenerator::GetVcardData(unsigned char *vcardbuf,unsigned long *vcardlength){
	if (vgs.ucVcardGeneratorStatus==VCARD_GENERATOR_STATUS_SUCCESS){
		   if (((unsigned long)vgs.ucVcardBuf[0]<<8)+((unsigned long)vgs.ucVcardBuf[1])+2<= *vcardlength){
		   	      *vcardlength=((unsigned long)vgs.ucVcardBuf[0]<<8)+((unsigned long)vgs.ucVcardBuf[1])+2;
		   	      memcpy(vcardbuf,vgs.ucVcardBuf,*vcardlength);		
		  }
		  else  {
		  	     std::cout<<RED<<"Warning! GetVcardData OverFlow!"<<RESET<<std::endl<<std::flush;	
		  	     return -1; 
		  	   }
		}
	else{
		   std::cout<<RED<<"Warning! GetVcardData Fail!"<<RESET<<std::endl<<std::flush;	
		   return -1;
	}    
  	return 1; 
}

/**********************************************************************************************************************************************************************************/

/**************************************************************************** 
* 函数名称 : FuncGetVcardFileProperty
* 类       NetApiToSimTranslator
* 功能描述 : 检查文件标识是否属于GSM11.11定义的文件
* 参    数 : identifier ：文件标识，
* 参    数 :  vcard_file_property：文件属性表指针
* 参    数 : 
* 返 回 值 : 属于 返回 1  不属于 返回 -1
* 作    者 : 王翔
* 设计日期 : 
* 修改日期		  修改人		   修改内容  
 *****************************************************************************/
int NetApiToSimTranslator::FuncGetVcardFileProperty(unsigned char identifier[2],vcard_file_property_t *vcard_file_property) {
		int iListCounter;		
	  
		for (iListCounter=0;iListCounter<sizeof(vcard_file_property_list)/sizeof(vcard_file_property_t);iListCounter++){
		  	if( (vcard_file_property_list[iListCounter].identifier[0]==identifier[0])&&(vcard_file_property_list[iListCounter].identifier[1]==identifier[1])){	  	   
		  	     (*vcard_file_property)=vcard_file_property_list[iListCounter];		  	  
		  	     break;
		  	}
		}
	  if (iListCounter==sizeof(vcard_file_property_list)/sizeof(vcard_file_property_t)){
			
			 return -1;
			}
	  return 1;
	}

int NetApiToSimTranslator::FuncGetVcardFileProperty_Uim(unsigned char identifier[2],vcard_file_property_t *vcard_file_property) {
		int iListCounter;		
	  
		for (iListCounter=0;iListCounter<sizeof(vcard_file_property_list_Uim)/sizeof(vcard_file_property_t);iListCounter++){
		  	if( (vcard_file_property_list_Uim[iListCounter].identifier[0]==identifier[0])&&(vcard_file_property_list_Uim[iListCounter].identifier[1]==identifier[1])){	  	   
		  	     (*vcard_file_property)=vcard_file_property_list_Uim[iListCounter];		  	  
		  	     break;
		  	}
		}
	  if (iListCounter==sizeof(vcard_file_property_list_Uim)/sizeof(vcard_file_property_t)){
			
			 return -1;
			}
	  return 1;
	}
	
int NetApiToSimTranslator::FunGetVcardFilePropertyWithPath_Uim(alltype_vcard_identifier_t vcardfile_identifier,vcard_file_property_t *vcard_file_property) {
		int iListCounter;		
	  
	  if (vcardfile_identifier.length==1)
	  	 return (FuncGetVcardFileProperty_Uim(vcardfile_identifier.identifier1,vcard_file_property));
	  	 
	  else
	  if (vcardfile_identifier.length==2){
	  	  	for (iListCounter=0;iListCounter<sizeof(vcard_file_property_list_Uim)/sizeof(vcard_file_property_t);iListCounter++){
		  	      if( (vcard_file_property_list_Uim[iListCounter].identifier[0]==vcardfile_identifier.identifier2[0])\
		  	      	&&(vcard_file_property_list_Uim[iListCounter].identifier[1]==vcardfile_identifier.identifier2[1])\
		  	      	&&(vcard_file_property_list_Uim[iListCounter].parent_identifier[0]==vcardfile_identifier.identifier1[0])\
		  	      	&&(vcard_file_property_list_Uim[iListCounter].parent_identifier[1]==vcardfile_identifier.identifier1[1])\
		  	      	){	  	   
		  	             (*vcard_file_property)=vcard_file_property_list_Uim[iListCounter];		  	  
		  	               break;
		  	        }
		      }
		      if (iListCounter==sizeof(vcard_file_property_list_Uim)/sizeof(vcard_file_property_t)){
			    //   vgs.ucStatusCode=ERROR_IDENTIFIER_MISMATCH;
			      return -1;
			    }  		
	  }
		else
	  if (vcardfile_identifier.length==3){   
	  	  	for (iListCounter=0;iListCounter<sizeof(vcard_file_property_list_Uim)/sizeof(vcard_file_property_t);iListCounter++){
		  	      if( (vcard_file_property_list_Uim[iListCounter].identifier[0]==vcardfile_identifier.identifier3[0])\
		  	      	&&(vcard_file_property_list_Uim[iListCounter].identifier[1]==vcardfile_identifier.identifier3[1])\
		  	      	&&(vcard_file_property_list_Uim[iListCounter].parent_identifier[0]==vcardfile_identifier.identifier2[0])\
		  	      	&&(vcard_file_property_list_Uim[iListCounter].parent_identifier[1]==vcardfile_identifier.identifier2[1])\
		  	      	&&(vcard_file_property_list_Uim[iListCounter].grandfather_identifier[0]==vcardfile_identifier.identifier1[0])\
		  	      	&&(vcard_file_property_list_Uim[iListCounter].grandfather_identifier[1]==vcardfile_identifier.identifier1[1])\
		  	      	){	  	   
		  	             (*vcard_file_property)=vcard_file_property_list_Uim[iListCounter];		  	  
		  	               break;
		  	        }
		      }
		      if (iListCounter==sizeof(vcard_file_property_list_Uim)/sizeof(vcard_file_property_t)){
			      // vgs.ucStatusCode=ERROR_IDENTIFIER_MISMATCH;
			      return -1;
			    }  		
	  }
	  else
	  	return -1;
	
	  return 1;
	}
int NetApiToSimTranslator::FunGetVcardFilePropertyWithPath_Sim(alltype_vcard_identifier_t vcardfile_identifier,vcard_file_property_t *vcard_file_property) {
		int iListCounter;		
	  
	  if (vcardfile_identifier.length==1)
	  	 return (FuncGetVcardFileProperty(vcardfile_identifier.identifier1,vcard_file_property));
	  	 
	  else
	  if (vcardfile_identifier.length==2){
	  	  	for (iListCounter=0;iListCounter<sizeof(vcard_file_property_list)/sizeof(vcard_file_property_t);iListCounter++){
		  	      if( (vcard_file_property_list[iListCounter].identifier[0]==vcardfile_identifier.identifier2[0])\
		  	      	&&(vcard_file_property_list[iListCounter].identifier[1]==vcardfile_identifier.identifier2[1])\
		  	      	&&(vcard_file_property_list[iListCounter].parent_identifier[0]==vcardfile_identifier.identifier1[0])\
		  	      	&&(vcard_file_property_list[iListCounter].parent_identifier[1]==vcardfile_identifier.identifier1[1])\
		  	      	){	  	   
		  	             (*vcard_file_property)=vcard_file_property_list[iListCounter];		  	  
		  	               break;
		  	        }
		      }
		      if (iListCounter==sizeof(vcard_file_property_list)/sizeof(vcard_file_property_t)){
			    //   vgs.ucStatusCode=ERROR_IDENTIFIER_MISMATCH;
			      return -1;
			    }  		
	  }
		else
	  if (vcardfile_identifier.length==3){   
	  	  	for (iListCounter=0;iListCounter<sizeof(vcard_file_property_list)/sizeof(vcard_file_property_t);iListCounter++){
		  	      if( (vcard_file_property_list[iListCounter].identifier[0]==vcardfile_identifier.identifier3[0])\
		  	      	&&(vcard_file_property_list[iListCounter].identifier[1]==vcardfile_identifier.identifier3[1])\
		  	      	&&(vcard_file_property_list[iListCounter].parent_identifier[0]==vcardfile_identifier.identifier2[0])\
		  	      	&&(vcard_file_property_list[iListCounter].parent_identifier[1]==vcardfile_identifier.identifier2[1])\
		  	      	&&(vcard_file_property_list[iListCounter].grandfather_identifier[0]==vcardfile_identifier.identifier1[0])\
		  	      	&&(vcard_file_property_list[iListCounter].grandfather_identifier[1]==vcardfile_identifier.identifier1[1])\
		  	      	){	  	   
		  	             (*vcard_file_property)=vcard_file_property_list[iListCounter];		  	  
		  	               break;
		  	        }
		      }
		      if (iListCounter==sizeof(vcard_file_property_list)/sizeof(vcard_file_property_t)){
			      // vgs.ucStatusCode=ERROR_IDENTIFIER_MISMATCH;
			      return -1;
			    }  		
	  }
	  else
	  	return -1;
	
	  return 1;
	}

	
	
int NetApiToSimTranslator::FuncGetVcardFileProperty_Usim(unsigned char length,unsigned char *identifier  ,\
	                                            vcard_file_property_t *vcard_file_property) {
		int iListCounter;		
	  if (length<2)
	  	return -1;
		for (iListCounter=0;iListCounter<sizeof(vcard_file_property_list_Usim)/sizeof(vcard_file_property_t);iListCounter++){
			  if (length==2)
			  	 if ((vcard_file_property_list_Usim[iListCounter].identifier[0]== *identifier)\
			  	   && (vcard_file_property_list_Usim[iListCounter].identifier[1]== *(identifier+1))
			  	   ) {
			  	    (*vcard_file_property)=vcard_file_property_list_Usim[iListCounter];		 
			  	   break;
			  	 }
			  	
		  	if (length==4)
			  	 if ((vcard_file_property_list_Usim[iListCounter].parent_identifier[0]== *identifier)\
			  	   && (vcard_file_property_list_Usim[iListCounter].parent_identifier[1]== *(identifier+1)) \
			  	   && (vcard_file_property_list_Usim[iListCounter].identifier[0]== *(identifier+2)) \
			  	   && (vcard_file_property_list_Usim[iListCounter].identifier[1]== *(identifier+3))
			  	   ){
			  	    (*vcard_file_property)=vcard_file_property_list_Usim[iListCounter];	
			  	   break;
			  	   
			      }
			  if (length==6)
			  	 if ((vcard_file_property_list_Usim[iListCounter].parent_identifier[0]== *(identifier+2))\
			  	   && (vcard_file_property_list_Usim[iListCounter].parent_identifier[1]== *(identifier+3)) \
			  	   && (vcard_file_property_list_Usim[iListCounter].identifier[0]== *(identifier+4)) \
			  	   && (vcard_file_property_list_Usim[iListCounter].identifier[1]== *(identifier+5))
			  	   ){
			  	    (*vcard_file_property)=vcard_file_property_list_Usim[iListCounter];	
			  	   break;
			  	   
			      }
		}
	if (iListCounter==sizeof(vcard_file_property_list_Usim)/sizeof(vcard_file_property_t)){
			
			 return -1;
			}
	  return 1;
	}
	
//比较数组前n个字节是否相同， 相同 返回0  //AID 比较工具， AID中含数字0， 不能使用strncmp比较	
int NetApiToSimTranslator::char_arrayncmp(unsigned char * array1 ,unsigned char * array2 ,unsigned char length){
unsigned char tmplength;	
	for (tmplength=0;tmplength<length;tmplength++)
	   if (*(array1+tmplength)!=* (array2+tmplength))
	   	 return -1;
	if (tmplength==length)
		return 0;
}	
	
/**************************************************************************** 
* 函数名称 : FuncGetFileParent
* 类       NetApiToSimTranslator
* 功能描述 : 获取文件父节点， 置于parent_identifier
* 参    数 : identifier ：文件标识
* 参    数 :  parent_identifier ：父节点文件标识
* 参    数 : 
* 返 回 值 : 可以 返回 1  不可以 返回 -1
* 作    者 : 王翔
* 设计日期 : 
* 修改日期		  修改人		   修改内容  
 *****************************************************************************/	
int  NetApiToSimTranslator::FuncGetFileParent(unsigned char identifier[2],unsigned char (*parent_identifier)[2]){
	vcard_file_property_t file_property;
	   
   if (FuncGetVcardFileProperty(identifier, &file_property)<0) 
	   	     return -1;
	   else
	     		 {
	     		 	(*parent_identifier)[0]=file_property.parent_identifier[0];  
	     		 	(*parent_identifier)[1]=file_property.parent_identifier[1];     
	   }       
	 return 1;   
	}	

void  NetApiToSimTranslator::FuncGetTsStatusAndLchAndResLength(unsigned char *Ptr_TsStatus,unsigned char * PtrCurrentLogicChannel,unsigned char * PtrExpectResLength){
	*Ptr_TsStatus=nat.ucTsStatus;
	 if (nat.ucCurrentApduMode==CURRENTAPDUMODE_USIM)
	       *PtrCurrentLogicChannel=nat.ucCurrentProcessLch;
	 else 
	 	   *PtrCurrentLogicChannel=nat.ucCurrentProcessLch|0xa0;
	* PtrExpectResLength=nat.ResLength;
	}	
void  NetApiToSimTranslator::FuncSetTsStatus(unsigned char TsStatus){
	 nat.ucTsStatus=TsStatus;
}		
	
int  NetApiToSimTranslator::FuncGetFileParent_Uim(unsigned char identifier[2],unsigned char (*parent_identifier)[2]){
	vcard_file_property_t file_property;
	   
   if (FuncGetVcardFileProperty_Uim(identifier, &file_property)<0) 
	   	     return -1;
	   else
	     		 {
	     		 	(*parent_identifier)[0]=file_property.parent_identifier[0];  
	     		 	(*parent_identifier)[1]=file_property.parent_identifier[1];     
	   }       
	 return 1;   
	}	
	
/**************************************************************************** 
* 函数名称 : FuncCheckNextFileThrough
* 类       ：NetApiToSimTranslator
* 功能描述 : 检查是否能直接有效选择下1个文件
* 参    数 : identifier ：文件标识
* 参    数 :  next_identifier：下一个文件标识
* 参    数 : 
* 返 回 值 : 可以 返回 1  不可以 返回 -1
* 作    者 : 王翔
* 设计日期 : 
* 修改日期		  修改人		   修改内容  
 *****************************************************************************/	
int   NetApiToSimTranslator::FuncCheckNextFileThrough(unsigned char identifier[2],unsigned char next_identifier[2]){
	   vcard_file_property_t file1,file2,file3;

	   if (FuncGetVcardFileProperty(identifier, &file1)<0) 
	   	   return -1;
	  
	   if (FuncGetVcardFileProperty(next_identifier, &file2)<0) 
	   	   return -1;	
	   	   
	   if 	((file1.property&FILE_TYPE_MF)||(file1.property&FILE_TYPE_DF))
	        if ((file2.parent_identifier[0]==file1.identifier[0])&&(file2.parent_identifier[1]==file1.identifier[1])) //当前目录的直接子文件
	   	   	      return 1;
	   if 	(file1.property&FILE_TYPE_EF)
	        if ((file2.parent_identifier[0]==file1.parent_identifier[0])&&(file2.parent_identifier[1]==file1.parent_identifier[1]))  
	   	   	  		return 1;	
	   	   	  		  
	   if (file1.property&FILE_TYPE_DF)   	  		   
	   	   if ((file2.parent_identifier[0]==file1.parent_identifier[0])&&(file2.parent_identifier[1]==file1.parent_identifier[1])&&(file2.property&FILE_TYPE_DF)) //当前DF件的父目录下的直接DF文件;
	   	   	  		 return 1;	 
	   if (file1.property&FILE_TYPE_EF){   	  		 	   	   	  		 
	   	   	 if (FuncGetVcardFileProperty(file1.parent_identifier, &file3)<0) 
	   	             return -1;	   	      
	   	   	 if ((file3.parent_identifier[0]==file2.parent_identifier[0])&&(file3.parent_identifier[1]==file2.parent_identifier[1])&&(file2.property&FILE_TYPE_DF)) 
	   	   	 			 return 1;
	   	} 	  		 
	   	   	  		 
	   if 	((file1.property&FILE_TYPE_MF)||(file1.property&FILE_TYPE_DF))	   	  		 
	   	   if ((file2.identifier[0]==file1.parent_identifier[0])&&(file2.identifier[1]==file1.parent_identifier[1]))  //当前目录的父目录
	   	   	 			 return 1;  		   
	   if 	(file1.property&FILE_TYPE_EF){
	       if (FuncGetVcardFileProperty(file1.parent_identifier, &file3)<0) 
	   	           return -1;
	   	   if ((file3.parent_identifier[0]==file2.identifier[0])&&(file3.parent_identifier[1]==file2.identifier[1]))  
	   	   	 			 return 1;    
	   }
	   
	   if (file1.property&FILE_TYPE_DF)  
	       if ((file1.identifier[0]==file2.identifier[0])&&(file1.identifier[1]==file2.identifier[1])&&(file2.property&FILE_TYPE_DF)) //当前的DF文件
	   	   	  		 return 1;
	   	   	  		 	
	   if (file2.property&FILE_TYPE_MF)                                                                       // MF文件
	   	   			   return 1;   	  		 
	   	   	  		 
	   return 0;
	   
	  
}	

int   NetApiToSimTranslator::FuncCheckNextFileThrough_Uim(unsigned char identifier[2],unsigned char next_identifier[2]){
	   vcard_file_property_t file1,file2,file3;

	   if (FuncGetVcardFileProperty_Uim(identifier, &file1)<0) 
	   	   return -1;
	  
	   if (FuncGetVcardFileProperty_Uim(next_identifier, &file2)<0) 
	   	   return -1;	
	   	   
	    return (FuncCheckNextFileThrough_Uim_File_Property(file1,file2));
}
int   NetApiToSimTranslator::FuncCheckNextFileThrough_Uim_File_Property(vcard_file_property_t file1,vcard_file_property_t file2){
	   vcard_file_property_t file3;
  /*   if (
     	    (file1.identifier[0]==0x4f)&&
     	    (file1.identifier[1]==0x20)&&
     	    (file1.parent_identifier[0]==0x5f)&&
     	    (file1.parent_identifier[1]==0x3c)&&
     	    (file2.identifier[0]==0x5f)&&
     	    (file2.identifier[1]==0x3c)
     	    )
     	    int kkk=0;
    */ 
     if 	((file1.property&FILE_TYPE_MF)||(file1.property&FILE_TYPE_DF))
	        if ((file2.parent_identifier[0]==file1.identifier[0])&&(file2.parent_identifier[1]==file1.identifier[1])) //当前目录的直接子文件
	   	   	      return 1;
	   if 	(file1.property&FILE_TYPE_EF)
	        if ((file2.parent_identifier[0]==file1.parent_identifier[0])&&(file2.parent_identifier[1]==file1.parent_identifier[1]))  
	   	   	  		return 1;	
	   	   	  		  
	   if (file1.property&FILE_TYPE_DF)   	  		   
	   	   if ((file2.parent_identifier[0]==file1.parent_identifier[0])&&(file2.parent_identifier[1]==file1.parent_identifier[1])&&(file2.property&FILE_TYPE_DF)) //当前DF件的父目录下的直接DF文件;
	   	   	  		 return 1;	 
	   if (file1.property&FILE_TYPE_EF){   	  		 	   	   	  		 
	   	   	 if (FuncGetVcardFileProperty_Uim(file1.parent_identifier, &file3)<0) {
	   	   	 	/*   //2018.06.10 B 如果虽然parent_identifier 不在标准内， 但是能确定parent_identifier= file2， 也能through
	   	   	 	     if (
	   	   	 	     	     (file1.parent_identifier[0]== file2.identifier[0])&&
	   	   	 	     	     (file1.parent_identifier[1]== file2.identifier[1])&& 
	   	   	 	     	     (file1.grandfather_identifier[0]== file2.parent_identifier[0])&& 
	   	   	 	     	     (file1.grandfather_identifier[1]== file2.parent_identifier[1])
	   	   	 	     	)
	   	   	 	        	return 1;
	   	   	 	     	else
	   	   	 	   //2018.06.10 E 
	   	   	 	   */
	   	             return -1;	   	      
	   	     }        
	   	   	 if ((file3.parent_identifier[0]==file2.parent_identifier[0])&&(file3.parent_identifier[1]==file2.parent_identifier[1])&&(file2.property&FILE_TYPE_DF)) 
	   	   	 			 return 1;
	   	} 	  		 
	   	   	  		 
	   if 	((file1.property&FILE_TYPE_MF)||(file1.property&FILE_TYPE_DF))	   	  		 
	   	   if ((file2.identifier[0]==file1.parent_identifier[0])&&(file2.identifier[1]==file1.parent_identifier[1]))  //当前目录的父目录
	   	   	 			 return 1;  		   
	   if 	(file1.property&FILE_TYPE_EF){
	       if (FuncGetVcardFileProperty_Uim(file1.parent_identifier, &file3)<0) 
	   	           return -1;
	   	   if ((file3.parent_identifier[0]==file2.identifier[0])&&(file3.parent_identifier[1]==file2.identifier[1]))  
	   	   	 			 return 1;    
	   }
	   
	   if (file1.property&FILE_TYPE_DF)  
	       if ((file1.identifier[0]==file2.identifier[0])&&(file1.identifier[1]==file2.identifier[1])&&(file2.property&FILE_TYPE_DF)) //当前的DF文件
	   	   	  		 return 1;
	   	   	  		 	
	   if (file2.property&FILE_TYPE_MF)                                                                       // MF文件
	   	   			   return 1;   	  
	   	   			   
	   	//2017.12.18  // 完全相同的文件		 
	   	 if (
	   	 	   (file2.identifier[0]==file1.identifier[0])&&(file2.identifier[1]==file1.identifier[1])&&\
	   	 	   (file2.parent_identifier[0]==file1.parent_identifier[0])&&(file2.parent_identifier[1]==file1.parent_identifier[1])&&\
	   	 	   (file2.grandfather_identifier[0]==file1.grandfather_identifier[0])&&(file2.grandfather_identifier[1]==file1.grandfather_identifier[1])\ 
	   	 	   )
	   	 	   return 1;   	 
	   	   	  		 
	   return 0;
	   
	  
}
int   NetApiToSimTranslator::FuncCheckNextFileThrough_Sim_File_Property(vcard_file_property_t file1,vcard_file_property_t file2){
	   vcard_file_property_t file3;
     
     if 	((file1.property&FILE_TYPE_MF)||(file1.property&FILE_TYPE_DF))
	        if ((file2.parent_identifier[0]==file1.identifier[0])&&(file2.parent_identifier[1]==file1.identifier[1])) //当前目录的直接子文件
	   	   	      return 1;
	   if 	(file1.property&FILE_TYPE_EF)
	        if ((file2.parent_identifier[0]==file1.parent_identifier[0])&&(file2.parent_identifier[1]==file1.parent_identifier[1]))  
	   	   	  		return 1;	
	   	   	  		  
	   if (file1.property&FILE_TYPE_DF)   	  		   
	   	   if ((file2.parent_identifier[0]==file1.parent_identifier[0])&&(file2.parent_identifier[1]==file1.parent_identifier[1])&&(file2.property&FILE_TYPE_DF)) //当前DF件的父目录下的直接DF文件;
	   	   	  		 return 1;	 
	   if (file1.property&FILE_TYPE_EF){   	  		 	   	   	  		 
	   	   	 if (FuncGetVcardFileProperty(file1.parent_identifier, &file3)<0) 
	   	             return -1;	   	      
	   	   	 if ((file3.parent_identifier[0]==file2.parent_identifier[0])&&(file3.parent_identifier[1]==file2.parent_identifier[1])&&(file2.property&FILE_TYPE_DF)) 
	   	   	 			 return 1;
	   	} 	  		 
	   	   	  		 
	   if 	((file1.property&FILE_TYPE_MF)||(file1.property&FILE_TYPE_DF))	   	  		 
	   	   if ((file2.identifier[0]==file1.parent_identifier[0])&&(file2.identifier[1]==file1.parent_identifier[1]))  //当前目录的父目录
	   	   	 			 return 1;  		   
	   if 	(file1.property&FILE_TYPE_EF){
	       if (FuncGetVcardFileProperty(file1.parent_identifier, &file3)<0) 
	   	           return -1;
	   	   if ((file3.parent_identifier[0]==file2.identifier[0])&&(file3.parent_identifier[1]==file2.identifier[1]))  
	   	   	 			 return 1;    
	   }
	   
	   if (file1.property&FILE_TYPE_DF)  
	       if ((file1.identifier[0]==file2.identifier[0])&&(file1.identifier[1]==file2.identifier[1])&&(file2.property&FILE_TYPE_DF)) //当前的DF文件
	   	   	  		 return 1;
	   	   	  		 	
	   if (file2.property&FILE_TYPE_MF)                                                                       // MF文件
	   	   			   return 1;   	  
	   	   			   
	   	//2017.12.18  // 完全相同的文件		 
	   	 if (
	   	 	   (file2.identifier[0]==file1.identifier[0])&&(file2.identifier[1]==file1.identifier[1])&&\
	   	 	   (file2.parent_identifier[0]==file1.parent_identifier[0])&&(file2.parent_identifier[1]==file1.parent_identifier[1])&&\
	   	 	   (file2.grandfather_identifier[0]==file1.grandfather_identifier[0])&&(file2.grandfather_identifier[1]==file1.grandfather_identifier[1])\ 
	   	 	   )
	   	 	   return 1;   	 
	   	   	  		 
	   return 0;
	   
	  
}
void NetApiToSimTranslator::SetOptimizationMode(unsigned char optimizationmode ){
	  nat.ucOptimizationMode=optimizationmode;
	  std::cout<<GREEN<<" Nat Optimizationmode: "<<(unsigned short)nat.ucOptimizationMode<<RESET<<std::endl;
}

/**************************************************************************** 
* 函数名称 : TranslatorInit
* 类       ：NetApiToSimTranslator
* 功能描述 : 初始化netapitosimcard_translator_t
* 参    数 : 
* 参    数 : 
* 参    数 : 
* 返 回 值 :  返回 1 
* 作    者 : 王翔
* 设计日期 : 
* 修改日期		  修改人		   修改内容  
 *****************************************************************************/		
int  NetApiToSimTranslator::TranslatorInit( ){  	 
     memset(&nat, 0, sizeof(netapitosimcard_translator_t));	
     return 1;
}
int  NetApiToSimTranslator::TranslatorInitWithOptimizationMode(unsigned char optimizationmode ){  	 
     memset(&nat, 0, sizeof(netapitosimcard_translator_t));	
     SetOptimizationMode(optimizationmode);
     return 1;
}

/**************************************************************************** 
* 函数名称 : TranslatorInitInnerData
* 类       ：NetApiToSimTranslator
* 功能描述 : 初始化TranslatorInnerData
* 参    数 : 
* 参    数 : 
* 参    数 : 
* 返 回 值 :  返回 1 
* 作    者 : 王翔
* 设计日期 : 
* 修改日期		  修改人		   修改内容  
 *****************************************************************************/		
int  NetApiToSimTranslator::TranslatorInitInnerData(){  	 
     memset(&(nat.TranslatorInnerData), 0, sizeof(translator_data_t));	
     return 1;
}

int NetApiToSimTranslator::SetCurrentCardIdentifier(unsigned char *identifier)                                                                                              
{
    if (identifier == NULL)
    {
        return -1;
    }
    nat.ucCurrentCardIdentifier[0] = identifier[0];
    nat.ucCurrentCardIdentifier[1] = identifier[1];
    return 0;
}

int  NetApiToSimTranslator::SetTranslatorSimcardTransmissionProtocol(unsigned char transmissionprotocol  ){  	 
     nat.ucTranslatorSimcardTransmissionProtocol=transmissionprotocol;
     return 1;
}

int  NetApiToSimTranslator::SetTranslatorStatus(unsigned char ucTranslatorStatus){
	   nat.ucTranslatorStatus=ucTranslatorStatus;
	   return 1;
	};

void NetApiToSimTranslator::SetcRealCardTypeToTranslator(unsigned char ucRealCardType){
	   nat.ucRealCardType=ucRealCardType;
	}
	
/**************************************************************************** 
* 函数名称 : DirectTransfer_NetToSim
* 类       ：NetApiToSimTranslator
* 功能描述 : 将网络侧数据直接传给Sim card 侧， 准备发给Sim Card
* 参    数 : 
* 参    数 : 
* 参    数 : 
* 返 回 值 :   成功 返回 1  不成功 返回 -1 
* 作    者 : 王翔
* 设计日期 : 
* 修改日期		  修改人		   修改内容  
 *****************************************************************************/			
int  NetApiToSimTranslator::DirectTransfer_NetToSim(){
	   if (nat.ucDataPropertyFromNet==DATA_PROPERTY_IS_DATA){
	   	//logical channel iso7816-4  5.1.1
	 	    if 	 (((nat.ucDataBufFromNet[OFFSET_CLA]&0xF)>=0)&&((nat.ucDataBufFromNet[OFFSET_CLA]&0xF)<=3)){	 	    
	 	                       nat.ucCurrentProcessLch=nat.ucDataBufFromNet[OFFSET_CLA]&0xF; 
	 	     }
	 	    else
	 	  	  return -1;
	 	 }
	   if (!((nat.ucDataPropertyFromNet==DATA_PROPERTY_IS_DATA)||(nat.ucDataPropertyFromNet==DATA_PROPERTY_IS_REQ_RST_ICC))){
	   	      std::cout<<RED<<"From Net Property is Err"<<RESET<<std::endl<<std::flush;
	   	      return -1; 	
	   	}   	
     nat.usDataBufLengthToSimcard=nat.usDataBufLengthFromNet;
	   memcpy(nat.ucDataBufToSimcard,nat.ucDataBufFromNet,nat.usDataBufLengthFromNet);  	   	
	   nat.ucDataPropertyToSimcard=nat.ucDataPropertyFromNet;	   
	   nat.ucTranslatorInteractiveStatus=  TRANSLATOR_INTERACTIVE_STATUS_DATA_TO_SIMCARD_IS_READY;  
	   return 1;  
}	

/**************************************************************************** 
* 函数名称 : DirectTransfer_SimToNet
* 类       ：NetApiToSimTranslator
* 功能描述 : 将Sim card侧数据直接传给网络侧， 准备发给Net
* 参    数 : 
* 参    数 : 
* 参    数 : 
* 返 回 值 :   成功 返回 1   
* 作    者 : 王翔
* 设计日期 : 
* 修改日期		  修改人		   修改内容  
 *****************************************************************************/			
int  NetApiToSimTranslator::DirectTransfer_SimToNet(){	
     nat.usDataBufLengthToNet=nat.usDataBufLengthFromSimcard;
	   memcpy(nat.ucDataBufToNet,nat.ucDataBufFromSimcard,nat.usDataBufLengthFromSimcard);  	   	
	   nat.ucDataPropertyToNet=nat.ucDataPropertyFromNet;	   
	   nat.ucTranslatorInteractiveStatus=  TRANSLATOR_INTERACTIVE_STATUS_DATA_TO_NET_IS_READY;  
	   return 1;  
}	

int  NetApiToSimTranslator::TranslatorToSim(unsigned char mode){
	  if (mode==EXPECT_DELIVER_TO_SIM_APDU_AERUMENT){
	  	    nat.usDataBufLengthToSimcard=nat.TranslatorInnerData.ucTranslatorApduArgumentLength[nat.TranslatorInnerData.usCurrentTranslatorApduCounter];
	        memcpy(nat.ucDataBufToSimcard,&(nat.TranslatorInnerData.ucTranslatorApduArgument[nat.TranslatorInnerData.usCurrentTranslatorApduCounter]),nat.usDataBufLengthToSimcard);  	   	
	        nat.ucDataPropertyToSimcard=DATA_PROPERTY_IS_DATA;	   
	        nat.ucTranslatorInteractiveStatus=  TRANSLATOR_INTERACTIVE_STATUS_DATA_TO_SIMCARD_IS_READY;  
	       
	  }
	  else{
	  	     if (mode==EXPECT_DELIVER_TO_SIM_APDU_COMMAND){
	  	         nat.usDataBufLengthToSimcard=5;
	             memcpy(nat.ucDataBufToSimcard,&(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usCurrentTranslatorApduCounter]),5);  	   	
	             nat.ucDataPropertyToSimcard=DATA_PROPERTY_IS_DATA;	   
	             nat.ucTranslatorInteractiveStatus=  TRANSLATOR_INTERACTIVE_STATUS_DATA_TO_SIMCARD_IS_READY;         
	         }
	         else{
	         	   return -1; 
	         	}
	  }
	  	 
	  return 1;  
	}
	
int NetApiToSimTranslator::SetCurrentCardStatusInTranslator(unsigned char ucCurrentCardStatus){
	   nat.ucCurrentCardStatus=ucCurrentCardStatus;
	   return 1;
	}

// 根据SFI 和CurrentIdentifier 产生ExpectedIdentifier
int NetApiToSimTranslator::GenExpectedFidWithSfi_Usim(){   //SFI 是EF文件, 假设Usim 是带路径选择
vcard_file_property_t tmpfile;
unsigned char tmpCounter,tmpExpectIdentifierLength=0;
	int iListCounter;	
       if	(!nat.ucCurrentProcessLch){
       	    // tmpridtype=nat.ucCurrentRidType;
          	if (nat.ucCurrentCardIdentifierLength==2){
          		  if((nat.ucCurrentCardIdentifier[0]==FILE_1ST_ID_MF)||(nat.ucCurrentCardIdentifier[0]==FILE_1ST_ID_UNDER_MF_EF)){
          		  	tmpfile.parent_identifier[0]=0x3F;
          		  	tmpfile.parent_identifier[1]=0;
          		  	tmpfile.grandfather_identifier[0]=0x3F;
					tmpfile.grandfather_identifier[1]=0;
          		  	tmpfile.great_grandfather_identifier[0]=0x3F;
					tmpfile.great_grandfather_identifier[1]=0;
          		  	tmpfile.sfi=nat.ucCurrentSFI;
          		  	tmpExpectIdentifierLength=2;
          		  }
                else
          		  if(nat.ucCurrentCardIdentifier[0]==FILE_1ST_ID_1LEVEL_DF){
          		  	tmpfile.parent_identifier[0]=nat.ucCurrentCardIdentifier[0];
          		  	tmpfile.parent_identifier[1]=nat.ucCurrentCardIdentifier[1];
          		  	tmpfile.grandfather_identifier[0]=0x3F;
					tmpfile.grandfather_identifier[1]=0;
          		  	tmpfile.great_grandfather_identifier[0]=0x3F;
					tmpfile.great_grandfather_identifier[1]=0;
          		  	tmpfile.sfi=nat.ucCurrentSFI;
          		  	tmpExpectIdentifierLength=4;
          		  }
          		  else{
          		  	   std::cout<<RED<<" GenExpectedFidWithSfi_Usim fail  "<<RESET<<std::endl<<std::flush;
          		  	   return -1;
          		  	}
          		  		
          	}
          	else
          	if (nat.ucCurrentCardIdentifierLength==4){
          		  //if((nat.ucCurrentCardIdentifier[2]==FILE_1ST_ID_UNDER_1LEVEL_DF_EF)||(nat.ucCurrentCardIdentifier[3]==FILE_1ST_ID_2LEVEL_DF)){
          		  if(nat.ucCurrentCardIdentifier[2]==FILE_1ST_ID_UNDER_1LEVEL_DF_EF){ 
          		  	tmpfile.parent_identifier[0]=nat.ucCurrentCardIdentifier[0];
          		  	tmpfile.parent_identifier[1]=nat.ucCurrentCardIdentifier[1];
          		  	tmpfile.grandfather_identifier[0]=0x3F;
					tmpfile.grandfather_identifier[1]=0;
          		  	tmpfile.great_grandfather_identifier[0]=0x3F;
					tmpfile.great_grandfather_identifier[1]=0;
          		  	tmpfile.sfi=nat.ucCurrentSFI;
          		  	tmpExpectIdentifierLength=4;
          		  }	
          		  else
          		  if(nat.ucCurrentCardIdentifier[2]==FILE_1ST_ID_2LEVEL_DF){ 
          		  	tmpfile.parent_identifier[0]=nat.ucCurrentCardIdentifier[2];
          		  	tmpfile.parent_identifier[1]=nat.ucCurrentCardIdentifier[3];
          		  	tmpfile.grandfather_identifier[0]=nat.ucCurrentCardIdentifier[0];
          		  	tmpfile.grandfather_identifier[1]=nat.ucCurrentCardIdentifier[1];
          		  	tmpfile.great_grandfather_identifier[0]=0x3F;
					tmpfile.great_grandfather_identifier[1]=0;
          		  	tmpfile.sfi=nat.ucCurrentSFI;
          		  	tmpExpectIdentifierLength=6;
          		  }
          		  else{
          		  	   std::cout<<RED<<" GenExpectedFidWithSfi_Usim fail  "<<RESET<<std::endl<<std::flush;
          		  	   return -1;
          		  }
          	}
          	else
          	if (nat.ucCurrentCardIdentifierLength==6){
          		  //if((nat.ucCurrentCardIdentifier[2]==FILE_1ST_ID_UNDER_1LEVEL_DF_EF)||(nat.ucCurrentCardIdentifier[3]==FILE_1ST_ID_2LEVEL_DF)){
          		  if(nat.ucCurrentCardIdentifier[4]==FILE_1ST_ID_UNDER_2LEVEL_DF_EF){ 
          		  	tmpfile.parent_identifier[0]=nat.ucCurrentCardIdentifier[2];
          		  	tmpfile.parent_identifier[1]=nat.ucCurrentCardIdentifier[3];
          		  	tmpfile.grandfather_identifier[0]=nat.ucCurrentCardIdentifier[0];
          		  	tmpfile.grandfather_identifier[1]=nat.ucCurrentCardIdentifier[1];
          		  	tmpfile.great_grandfather_identifier[0]=0x3F;
					tmpfile.great_grandfather_identifier[1]=0;
          		  	tmpfile.sfi=nat.ucCurrentSFI;
          		  	tmpExpectIdentifierLength=6;
          		  }			  
          		  else{
          		  	   std::cout<<RED<<" GenExpectedFidWithSfi_Usim fail  "<<RESET<<std::endl<<std::flush;
          		  	   return -1;
          		  }
          	}
          	else{
          		  	   std::cout<<RED<<" GenExpectedFidWithSfi_Usim fail  "<<RESET<<std::endl<<std::flush;
          		  	   return -1;
          		  }
          		
          	//	  
          	
          		
           // 找到SFI 对应的identifier
          		for (iListCounter=0;iListCounter<vcard_file_property_list_Usim_num;iListCounter++){			 			 
          			  	 if ((vcard_file_property_list_Usim[iListCounter].parent_identifier[0]== tmpfile.parent_identifier[0])\
          			  	   && (vcard_file_property_list_Usim[iListCounter].parent_identifier[1]== tmpfile.parent_identifier[1]) \
          			  	   && (vcard_file_property_list_Usim[iListCounter].grandfather_identifier[0]== tmpfile.grandfather_identifier[0]) \
          			  	   && (vcard_file_property_list_Usim[iListCounter].grandfather_identifier[1]== tmpfile.grandfather_identifier[1]) \
          			  	   && (vcard_file_property_list_Usim[iListCounter].great_grandfather_identifier[0]== tmpfile.great_grandfather_identifier[0]) \
          			  	   && (vcard_file_property_list_Usim[iListCounter].great_grandfather_identifier[1]== tmpfile.great_grandfather_identifier[1]) \
          			  	    && (vcard_file_property_list_Usim[iListCounter].sfi== tmpfile.sfi) \
          			  	    && (vcard_file_property_list_Usim[iListCounter].application_id_type==nat.ucCurrentRidType)
          			  	   ){
          			  	    tmpfile.identifier[0]=vcard_file_property_list_Usim[iListCounter].identifier[0];
          			  	    tmpfile.identifier[1]=vcard_file_property_list_Usim[iListCounter].identifier[1];
          			  	   break;
          			  	   
          			      }
          		}
          	  if (iListCounter==vcard_file_property_list_Usim_num){
          			
          			 return -1;
          	  }
          	  
              nat.ucExpectIdentifierLength=tmpExpectIdentifierLength;
              if (nat.ucExpectIdentifierLength==2){
              	  nat.ucExpectIdentifier[0]=tmpfile.identifier[0];
              	  nat.ucExpectIdentifier[1]=tmpfile.identifier[1];
              	}
              if (nat.ucExpectIdentifierLength==4){
              	  nat.ucExpectIdentifier[0]=tmpfile.parent_identifier[0];
              	  nat.ucExpectIdentifier[1]=tmpfile.parent_identifier[1];
              	  nat.ucExpectIdentifier[2]=tmpfile.identifier[0];
              	  nat.ucExpectIdentifier[3]=tmpfile.identifier[1];
              }
              if (nat.ucExpectIdentifierLength==6){
              	  nat.ucExpectIdentifier[0]=tmpfile.grandfather_identifier[0];
              	  nat.ucExpectIdentifier[1]=tmpfile.grandfather_identifier[1];
              	  nat.ucExpectIdentifier[2]=tmpfile.parent_identifier[0];
              	  nat.ucExpectIdentifier[3]=tmpfile.parent_identifier[1];
              	  nat.ucExpectIdentifier[4]=tmpfile.identifier[0];
              	  nat.ucExpectIdentifier[5]=tmpfile.identifier[1];
              }
    }  
    else{
    	   if (nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_IdentifierLength==2){
          		  if((nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_Identifier[0]==FILE_1ST_ID_MF)||(nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_Identifier[0]==FILE_1ST_ID_UNDER_MF_EF)){
          		  	tmpfile.parent_identifier[0]=0x3F;
					tmpfile.parent_identifier[1]=0;
          		  	tmpfile.grandfather_identifier[0]=0x3F;
					tmpfile.grandfather_identifier[1]=0;
          		  	tmpfile.great_grandfather_identifier[0]=0x3F;
					tmpfile.great_grandfather_identifier[1]=0;
          		  	tmpfile.sfi=nat.ucCurrentSFI;
          		  	tmpExpectIdentifierLength=2;
          		  }
                else
          		  if(nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_Identifier[0]==FILE_1ST_ID_1LEVEL_DF){
          		  	tmpfile.parent_identifier[0]=nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_Identifier[0];
          		  	tmpfile.parent_identifier[1]=nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_Identifier[1];
          		  	tmpfile.grandfather_identifier[0]=0x3F;
					tmpfile.grandfather_identifier[1]=0;
          		  	tmpfile.great_grandfather_identifier[0]=0x3F;
					tmpfile.great_grandfather_identifier[1]=0;
          		  	tmpfile.sfi=nat.ucCurrentSFI;
          		  	tmpExpectIdentifierLength=4;
          		  }
          		  else{
          		  	   std::cout<<RED<<" GenExpectedFidWithSfi_Usim fail  "<<RESET<<std::endl<<std::flush;
          		  	   return -1;
          		  	}
          		  		
          	}
          	else
          	if (nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_IdentifierLength==4){
          		  //if((nat.ucCurrentCardIdentifier[2]==FILE_1ST_ID_UNDER_1LEVEL_DF_EF)||(nat.ucCurrentCardIdentifier[3]==FILE_1ST_ID_2LEVEL_DF)){
          		  if(nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_Identifier[2]==FILE_1ST_ID_UNDER_1LEVEL_DF_EF){ 
          		  	tmpfile.parent_identifier[0]=nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_Identifier[0];
          		  	tmpfile.parent_identifier[1]=nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_Identifier[1];
          		  	tmpfile.grandfather_identifier[0]=0x3F;
					tmpfile.grandfather_identifier[1]=0;
          		  	tmpfile.great_grandfather_identifier[0]=0x3F;
					tmpfile.great_grandfather_identifier[1]=0;
          		  	tmpfile.sfi=nat.ucCurrentSFI;
          		  	tmpExpectIdentifierLength=4;
          		  }	
          		  else
          		  if(nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_Identifier[2]==FILE_1ST_ID_2LEVEL_DF){ 
          		  	tmpfile.parent_identifier[0]=nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_Identifier[2];
          		  	tmpfile.parent_identifier[1]=nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_Identifier[3];
          		  	tmpfile.grandfather_identifier[0]=nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_Identifier[0];
          		  	tmpfile.grandfather_identifier[1]=nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_Identifier[1];
          		  	tmpfile.great_grandfather_identifier[0]=0x3F;
					tmpfile.great_grandfather_identifier[0]=0;
          		  	tmpfile.sfi=nat.ucCurrentSFI;
          		  	tmpExpectIdentifierLength=6;
          		  }
          		  else{
          		  	   std::cout<<RED<<" GenExpectedFidWithSfi_Usim fail  "<<RESET<<std::endl<<std::flush;
          		  	   return -1;
          		  }
          	}
          	else
          	if (nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_IdentifierLength==6){
          		 
          		  if(nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_Identifier[4]==FILE_1ST_ID_UNDER_2LEVEL_DF_EF){ 
          		  	tmpfile.parent_identifier[0]=nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_Identifier[2];
          		  	tmpfile.parent_identifier[1]=nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_Identifier[3];
          		  	tmpfile.grandfather_identifier[0]=nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_Identifier[0];
          		  	tmpfile.grandfather_identifier[1]=nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_Identifier[1];
          		  	tmpfile.great_grandfather_identifier[0]=0x3F;
					tmpfile.great_grandfather_identifier[0]=0;
          		  	tmpfile.sfi=nat.ucCurrentSFI;
          		  	tmpExpectIdentifierLength=6;
          		  }			  
          		  else{
          		  	   std::cout<<RED<<" GenExpectedFidWithSfi_Usim fail  "<<RESET<<std::endl<<std::flush;
          		  	   return -1;
          		  }
          	}
          	else{
          		  	   std::cout<<RED<<" GenExpectedFidWithSfi_Usim fail  "<<RESET<<std::endl<<std::flush;
          		  	   return -1;
          		  }
          		
          	//	  
          	
          		
           // 找到SFI 对应的identifier
          		for (iListCounter=0;iListCounter<vcard_file_property_list_Usim_num;iListCounter++){			 			 
          			  	 if ((vcard_file_property_list_Usim[iListCounter].parent_identifier[0]== tmpfile.parent_identifier[0])\
          			  	   && (vcard_file_property_list_Usim[iListCounter].parent_identifier[1]== tmpfile.parent_identifier[1]) \
          			  	   && (vcard_file_property_list_Usim[iListCounter].grandfather_identifier[0]== tmpfile.grandfather_identifier[0]) \
          			  	   && (vcard_file_property_list_Usim[iListCounter].grandfather_identifier[1]== tmpfile.grandfather_identifier[1]) \
          			  	   && (vcard_file_property_list_Usim[iListCounter].great_grandfather_identifier[0]== tmpfile.great_grandfather_identifier[0]) \
          			  	   && (vcard_file_property_list_Usim[iListCounter].great_grandfather_identifier[1]== tmpfile.great_grandfather_identifier[1]) \
          			  	    && (vcard_file_property_list_Usim[iListCounter].sfi== tmpfile.sfi) \
          			  	    && (vcard_file_property_list_Usim[iListCounter].application_id_type==nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_Type)
          			  	   ){
          			  	    tmpfile.identifier[0]=vcard_file_property_list_Usim[iListCounter].identifier[0];
          			  	    tmpfile.identifier[1]=vcard_file_property_list_Usim[iListCounter].identifier[1];
          			  	   break;
          			  	   
          			      }
          		}
          	  if (iListCounter==vcard_file_property_list_Usim_num){
          			
          			 return -1;
          	  }
          	  
              nat.Lcm[nat.ucCurrentProcessLch].ucExpectLch_IdentifierLength=tmpExpectIdentifierLength;
              if (nat.Lcm[nat.ucCurrentProcessLch].ucExpectLch_IdentifierLength==2){
              	  nat.Lcm[nat.ucCurrentProcessLch].ucExpectLch_Identifier[0]=tmpfile.identifier[0];
              	  nat.Lcm[nat.ucCurrentProcessLch].ucExpectLch_Identifier[1]=tmpfile.identifier[1];
              	}
              if (nat.Lcm[nat.ucCurrentProcessLch].ucExpectLch_IdentifierLength==4){
              	  nat.Lcm[nat.ucCurrentProcessLch].ucExpectLch_Identifier[0]=tmpfile.parent_identifier[0];
              	  nat.Lcm[nat.ucCurrentProcessLch].ucExpectLch_Identifier[1]=tmpfile.parent_identifier[1];
              	  nat.Lcm[nat.ucCurrentProcessLch].ucExpectLch_Identifier[2]=tmpfile.identifier[0];
              	  nat.Lcm[nat.ucCurrentProcessLch].ucExpectLch_Identifier[3]=tmpfile.identifier[1];
              }
              if (nat.Lcm[nat.ucCurrentProcessLch].ucExpectLch_IdentifierLength==6){
              	  nat.Lcm[nat.ucCurrentProcessLch].ucExpectLch_Identifier[0]=tmpfile.grandfather_identifier[0];
              	  nat.Lcm[nat.ucCurrentProcessLch].ucExpectLch_Identifier[1]=tmpfile.grandfather_identifier[1];
              	  nat.Lcm[nat.ucCurrentProcessLch].ucExpectLch_Identifier[2]=tmpfile.parent_identifier[0];
              	  nat.Lcm[nat.ucCurrentProcessLch].ucExpectLch_Identifier[3]=tmpfile.parent_identifier[1];
              	  nat.Lcm[nat.ucCurrentProcessLch].ucExpectLch_Identifier[4]=tmpfile.identifier[0];
              	  nat.Lcm[nat.ucCurrentProcessLch].ucExpectLch_Identifier[5]=tmpfile.identifier[1];
              }
    	
    }   
   return 1;	
    
}	

/**************************************************************************** 
* 函数名称 : TranslateNetApiToApdu
* 类       ：NetApiToSimTranslator
* 功能描述 : 将NetApI 格式的数据转换成Apdu命令 
* 参    数 : 
* 参    数 : 
* 参    数 : 
* 返 回 值 :   成功 返回 1   不成功  返回 -1
* 作    者 : 王翔
* 设计日期 : 
* 修改日期		  修改人		   修改内容  
 *****************************************************************************/			
int  NetApiToSimTranslator::TranslateNetApiToApdu(){
	  return (TranslateNetApiToApdu_Uim());
}
int  NetApiToSimTranslator::TranslateNetApiToApdu_Uim(){
	int tmpCounter=0;
	int tmpBufCounter=0;
		 if 	 (((nat.ucDataBufFromNet[OFFSET_CLA]&0xF)>=0)&&((nat.ucDataBufFromNet[OFFSET_CLA]&0xF)<=3)){	 	    
	 	                       nat.ucCurrentProcessLch=nat.ucDataBufFromNet[OFFSET_CLA]&0xF; 
	 	                       switch (nat.ucCurrentApduMode){	 	                      
	 	                         case CURRENTAPDUMODE_UNKOWN:
	 	                       	        if (nat.ucDataBufFromNet[OFFSET_CLA]==0xA0)
	 	                       	          nat.ucCurrentApduMode=CURRENTAPDUMODE_SIM_UIM;
	 	                                else{
	 	                       	              if (nat.ucDataBufFromNet[OFFSET_CLA]==0x0)
	 	                       	                  nat.ucCurrentApduMode=CURRENTAPDUMODE_USIM;
	 	                       	        }
	 	                       	       break;
	 	                       	case CURRENTAPDUMODE_SIM_UIM:
	 	                       		       if (nat.ucDataBufFromNet[OFFSET_CLA]==0x0)
	 	                       	                  nat.ucCurrentApduMode=CURRENTAPDUMODE_USIM;
	 	                       	         break;
	 	                       	case CURRENTAPDUMODE_USIM:
	 	                       		       if (nat.ucDataBufFromNet[OFFSET_CLA]==0xA0)
	 	                       	                  nat.ucCurrentApduMode=CURRENTAPDUMODE_SIM_UIM;
	 	                       	         break;
	 	                       	         
	 	                       	}
	 	                      	 	                       	
	 	  }
	 	  else
	 	  	  return -1;
	   //将路径转换命令存入
	   while (!(( nat.TranslatorInnerData.FileOperationList[tmpBufCounter].identifier[0]==0)&&( nat.TranslatorInnerData.FileOperationList[tmpBufCounter].identifier[1]==0))){
		    memcpy(&(nat.TranslatorInnerData.ucTranslatorApduCommand[tmpBufCounter]),command_select,5);	
		    memcpy(&(nat.TranslatorInnerData.ucTranslatorApduArgument[tmpBufCounter]),&(nat.TranslatorInnerData.FileOperationList[tmpBufCounter].identifier),2);	
 	   		nat.TranslatorInnerData.ucTranslatorApduArgumentLength[tmpBufCounter]=2;
 	   		tmpBufCounter++;	      
	   }
  tmpCounter=nat.ucCurrentOffsetWithoutPathCommand; 
	while (tmpCounter<nat.usDataBufLengthFromNet){
		    memcpy(&(nat.TranslatorInnerData.ucTranslatorApduCommand[tmpBufCounter]),&(nat.ucDataBufFromNet[tmpCounter]),5);		       
		    switch(nat.ucDataBufFromNet[tmpCounter+OFFSET_INS]){
		    	 case APDU_COMMAND_UIM_GENERATE_KEY_VPM:
		    	 case APDU_COMMAND_UIM_STORE_ESN_ME:
		    	 case APDU_COMMAND_UIM_BASE_STATION_CHALLENGE:
		    	 case APDU_COMMAND_RUN_GSM_ALGORITHM:  
		    	 	
		    	 //Add  Command in C.S0023-0_v4.0  //20200102	  
        case APDU_COMMAND_GET_CHALLENGE:
        case APDU_COMMAND_UIM_CONFIRM_SSD: 
        case APDU_COMMAND_UIM_GENERATE_PUBLIC_KEY:   
        case APDU_COMMAND_UIM_KEY_GENERATION_REQUEST:
        case APDU_COMMAND_UIM_CONFIGURATION_REQUEST:
        case APDU_COMMAND_UIM_KEY_DOWNLOAD_REQUEST:   
        case APDU_COMMAND_UIM_OTAPA_REQUEST:          
        case APDU_COMMAND_UIM_SSPR_CONFIGURATION_REQUEST: 
        case APDU_COMMAND_UIM_SSPR_DOWNLOAD_REQUEST:      
        case APDU_COMMAND_UIM_VALID: 	

		    	 	    memcpy(&(nat.TranslatorInnerData.ucTranslatorApduArgument[tmpBufCounter]),&(nat.ucDataBufFromNet[tmpCounter+5]),nat.ucDataBufFromNet[tmpCounter+OFFSET_P3]);	
 	   			      nat.TranslatorInnerData.ucTranslatorApduArgumentLength[tmpBufCounter]=nat.ucDataBufFromNet[tmpCounter+OFFSET_P3];
 	   			      tmpCounter+=nat.ucDataBufFromNet[tmpCounter+OFFSET_P3]+5;       								        		  				     		      
 	   			     
		    	 	    if (nat.ucOptimizationMode&EMU_TRANSLAOTR_OPTIMIZATION_FORK_GET_RESPONSE_WITH_RUNAUTH){ 	   			       	  
 	   			       	  nat.ucTsStatus=TS_STATUS_GEN_GETSTATUS_FOR_RUNAUTH;	   			       	
 	   			       	}  
 	   			      break;   	  		  
  	  		 case APDU_COMMAND_TERMINAL_PROFILE:    
  	  		 case APDU_COMMAND_ENVELOPE:              		              
  	  		 case APDU_COMMAND_TERMINAL_RESPONSE:	  
  	  		 case APDU_COMMAND_INCREASE:  	   				
  	  		 case APDU_COMMAND_UPDATE_BINARY:       	
  	  		 case APDU_COMMAND_UPDATE_RECORD:       	
  	  		 case APDU_COMMAND_VERIFY_CHV:          	
  	  		 case APDU_COMMAND_CHANGE_CHV:          	
  	  		 case APDU_COMMAND_DISABLE_CHV:         	
  	  		 case APDU_COMMAND_ENABLE_CHV:          	
  	  		 case APDU_COMMAND_UNBLOCK_CHV: 
  	  		// case APDU_COMMAND_UIM_STORE_ESN_ME:
  	  		 case	APDU_COMMAND_UIM_COMPUTE_IP_AUTHENTICATION:
  	  	//	 case APDU_COMMAND_UIM_GENERATE_KEY_VPM:	
  	  		 case APDU_COMMAND_SEEK:
    	  	 case APDU_COMMAND_SELECT:  
    	  	 case APDU_COMMAND_MANAGE_CHANNEL:            
 	   			      memcpy(&(nat.TranslatorInnerData.ucTranslatorApduArgument[tmpBufCounter]),&(nat.ucDataBufFromNet[tmpCounter+5]),nat.ucDataBufFromNet[tmpCounter+OFFSET_P3]);	
 	   			      nat.TranslatorInnerData.ucTranslatorApduArgumentLength[tmpBufCounter]=nat.ucDataBufFromNet[tmpCounter+OFFSET_P3];
 	   			      tmpCounter+=nat.ucDataBufFromNet[tmpCounter+OFFSET_P3]+5;       								        		  				     		      
 	   			      break; 
 	   			/*        
 	   			 case APDU_COMMAND_UIM_STORE_ESN_ME:    //出现过参数小于8的样例
 	   			 	 //   if (( tmpCounter+nat.ucDataBufFromNet[tmpCounter+OFFSET_P3]+5)==nat.usDataBufLengthFromNet){
 	   			 	        memcpy(&(nat.TranslatorInnerData.ucTranslatorApduArgument[tmpBufCounter]),&(nat.ucDataBufFromNet[tmpCounter+5]),nat.ucDataBufFromNet[tmpCounter+OFFSET_P3]);	
 	   			          nat.TranslatorInnerData.ucTranslatorApduArgumentLength[tmpBufCounter]=nat.ucDataBufFromNet[tmpCounter+OFFSET_P3];
 	   			          tmpCounter+=nat.ucDataBufFromNet[tmpCounter+OFFSET_P3]+5;    
 	   			    //  }
 	   			   					        		  				     		      
 	   			      break;  
 	   			 */                      
  	  		 case APDU_COMMAND_STATUS:              
  	  		 case APDU_COMMAND_READ_BINARY:         
  	  		 case APDU_COMMAND_READ_RECORD:         
  	  		 	 
  	  		 case APDU_COMMAND_INVALIDATE:          	
  	  		 case APDU_COMMAND_REHABILITATE: 	
  	  		 case APDU_COMMAND_SLEEP: 
  	  		 case APDU_COMMAND_GET_RESPONSE:    
  	  		 case APDU_COMMAND_FETCH: 
  	  		 	// Add  Command in C.S0023-0_v4.0  //20200102
  	  		 case	APDU_COMMAND_UIM_COMMIT:
  	  		 //case APDU_COMMAND_UIM_STORE_ESN_ME: 
  	  		 	 		tmpCounter+=5;
  	  		 	 		break;
  	  		 default:	
  	  		 	 std::cout<<RED<<"TranslateNetApiToApdu Err"<<RESET<<std::endl<<std::flush;	 
  	  		 	 return -1;      	
  	  	}	 	
  	  	tmpBufCounter++;	 	 	  		 		
		}
		//2018.06.10 B
		  // APDU_COMMAND_UIM_STORE_ESN_ME:    //出现过参数小于8的样例，需要初始化usDataBufLengthFromNet
		  memset(nat.ucDataBufFromNet,0,NETAPIBUFMAXLENGTH);	  
		//2018.06.10 E
	if(tmpCounter!=nat.usDataBufLengthFromNet){
		 std::cout<<RED<<"TranslateNetApiToApdu Length Err"<<RESET<<std::endl<<std::flush;	
		 return -1;
	}	
		return 1;
}

int  NetApiToSimTranslator::TranslateNetApiToApdu_Usim(){
	int tmpCounter=0;
	int tmpBufCounter=0;
	unsigned char tmplch;
	    //logical channel iso7816-4  5.1.1
	 	  if 	 (((nat.ucDataBufFromNet[OFFSET_CLA]&0xF)>=0)&&((nat.ucDataBufFromNet[OFFSET_CLA]&0xF)<=3)){	 	    
	 	                       nat.ucCurrentProcessLch=nat.ucDataBufFromNet[OFFSET_CLA]&0xF; 
	 	                       switch (nat.ucCurrentApduMode){	 	                      
	 	                         case CURRENTAPDUMODE_UNKOWN:
	 	                       	        if (nat.ucDataBufFromNet[OFFSET_CLA]==0xA0)
	 	                       	          nat.ucCurrentApduMode=CURRENTAPDUMODE_SIM_UIM;
	 	                                else{
	 	                       	              if (nat.ucDataBufFromNet[OFFSET_CLA]==0x0)
	 	                       	                  nat.ucCurrentApduMode=CURRENTAPDUMODE_USIM;
	 	                       	        }
	 	                       	       break;
	 	                       	case CURRENTAPDUMODE_SIM_UIM:
	 	                       		       if (nat.ucDataBufFromNet[OFFSET_CLA]==0x0)
	 	                       	                  nat.ucCurrentApduMode=CURRENTAPDUMODE_USIM;
	 	                       	         break;
	 	                       	case CURRENTAPDUMODE_USIM:
	 	                       		       if (nat.ucDataBufFromNet[OFFSET_CLA]==0xA0)
	 	                       	                  nat.ucCurrentApduMode=CURRENTAPDUMODE_SIM_UIM;
	 	                       	         break;
	 	                       	         
	 	                       	}
	 	                      	 	                       	
	 	  }
	 	  else
	 	  	  return -1;
	 	  
	while (tmpCounter<nat.usDataBufLengthFromNet){
		    memcpy(&(nat.TranslatorInnerData.ucTranslatorApduCommand[tmpBufCounter]),&(nat.ucDataBufFromNet[tmpCounter]),5);		       
		    switch(nat.ucDataBufFromNet[tmpCounter+OFFSET_INS]){
		    	case APDU_COMMAND_UPDATE_BINARY: 
		    	      if (((nat.ucDataBufFromNet[tmpCounter+OFFSET_P1])>>5)==READ_UPDATE_BINARY_P1_SFI_SUPPORT_B8_B7_B6){  //SFI  	  	
   	  	                 
   	                      nat.ucCurrentSFI=(nat.ucDataBufFromNet[tmpCounter+OFFSET_P1])&0x1F; 
   	                     // if (GenExpectedFidWithSfi_Usim()>0){
     		   	  	      	//       std::cout<<GREEN<<"Bank Side Get right SFI "<<RESET<<std::endl<<std::flush;  
     		   	  	      	       nat.ucCurrentUpdateMode=UPDATEMODE_SFI;	                           
     		   	  	        //  }
   	            }
   	                 
		    	      memcpy(&(nat.TranslatorInnerData.ucTranslatorApduArgument[tmpBufCounter]),&(nat.ucDataBufFromNet[tmpCounter+5]),nat.ucDataBufFromNet[tmpCounter+OFFSET_P3]);	
 	   			      nat.TranslatorInnerData.ucTranslatorApduArgumentLength[tmpBufCounter]=nat.ucDataBufFromNet[tmpCounter+OFFSET_P3];
 	   			      tmpCounter+=nat.ucDataBufFromNet[tmpCounter+OFFSET_P3]+5;       								        		  				     		      
 	   			      break; 
 	   			 case APDU_COMMAND_UPDATE_RECORD: 
 	   			 	   if (((nat.ucDataBufFromNet[tmpCounter+OFFSET_P2])>>3)>0){  //SFI  	  	   	  	                 
   	                      nat.ucCurrentSFI=(nat.ucDataBufFromNet[tmpCounter+OFFSET_P2])>>3; 
   	                   //   if (GenExpectedFidWithSfi_Usim()>0){
     		   	  	      	//       std::cout<<GREEN<<"Bank Side Get right SFI "<<RESET<<std::endl<<std::flush;  
     		   	  	      	       nat.ucCurrentUpdateMode=UPDATEMODE_SFI;	                           
     		   	  	        //  }
   	            }
   	                 
		    	      memcpy(&(nat.TranslatorInnerData.ucTranslatorApduArgument[tmpBufCounter]),&(nat.ucDataBufFromNet[tmpCounter+5]),nat.ucDataBufFromNet[tmpCounter+OFFSET_P3]);	
 	   			      nat.TranslatorInnerData.ucTranslatorApduArgumentLength[tmpBufCounter]=nat.ucDataBufFromNet[tmpCounter+OFFSET_P3];
 	   			      tmpCounter+=nat.ucDataBufFromNet[tmpCounter+OFFSET_P3]+5;       								        		  				     		      
 	   			      break; 
 	   			 case APDU_COMMAND_UIM_GENERATE_KEY_VPM: // Usim Apdu 中出现此UIM指令 20180620     
 	   			 case	APDU_COMMAND_UIM_STORE_ESN_ME:   // Usim Apdu 中出现此UIM指令   20180620  
 	   			 case APDU_COMMAND_UIM_BASE_STATION_CHALLENGE:  
		    	 case APDU_COMMAND_RUN_GSM_ALGORITHM:   
		    	 	
		    	  	 //Add  Command in C.S0023-0_v4.0  //20200102	  
        case APDU_COMMAND_GET_CHALLENGE:
        case APDU_COMMAND_UIM_CONFIRM_SSD: 
        case APDU_COMMAND_UIM_GENERATE_PUBLIC_KEY:   
        case APDU_COMMAND_UIM_KEY_GENERATION_REQUEST:
        case APDU_COMMAND_UIM_CONFIGURATION_REQUEST:
        case APDU_COMMAND_UIM_KEY_DOWNLOAD_REQUEST:   
        case APDU_COMMAND_UIM_OTAPA_REQUEST:          
        case APDU_COMMAND_UIM_SSPR_CONFIGURATION_REQUEST: 
        case APDU_COMMAND_UIM_SSPR_DOWNLOAD_REQUEST:      
        case APDU_COMMAND_UIM_VALID: 	
        	
		    	 	     memcpy(&(nat.TranslatorInnerData.ucTranslatorApduArgument[tmpBufCounter]),&(nat.ucDataBufFromNet[tmpCounter+5]),nat.ucDataBufFromNet[tmpCounter+OFFSET_P3]);	
 	   			       nat.TranslatorInnerData.ucTranslatorApduArgumentLength[tmpBufCounter]=nat.ucDataBufFromNet[tmpCounter+OFFSET_P3];
 	   			       tmpCounter+=nat.ucDataBufFromNet[tmpCounter+OFFSET_P3]+5;  
 	   			       if (nat.ucOptimizationMode&EMU_TRANSLAOTR_OPTIMIZATION_FORK_GET_RESPONSE_WITH_RUNAUTH){ 	   			       	  
 	   			       	  nat.ucTsStatus=TS_STATUS_GEN_GETSTATUS_FOR_RUNAUTH;	   			       	
 	   			       	}     								        		  				     		      
 	   			      break;  	  		  
  	  		 case APDU_COMMAND_TERMINAL_PROFILE:    
  	  		 case APDU_COMMAND_ENVELOPE:              		              
  	  		 case APDU_COMMAND_TERMINAL_RESPONSE:	  
  	  		 case APDU_COMMAND_INCREASE:  	   				   	
  	  		 case APDU_COMMAND_VERIFY_CHV:          	
  	  		 case APDU_COMMAND_CHANGE_CHV:          	
  	  		 case APDU_COMMAND_DISABLE_CHV:         	
  	  		 case APDU_COMMAND_ENABLE_CHV:          	
  	  		 case APDU_COMMAND_UNBLOCK_CHV: 
  	  		 case APDU_COMMAND_SEEK:
  	  		// case	APDU_COMMAND_UIM_STORE_ESN_ME:   // Usim Apdu 中出现此UIM指令   20180620
  	  		// case APDU_COMMAND_UIM_GENERATE_KEY_VPM: // Usim Apdu 中出现此UIM指令 20180620
  	  		 case	APDU_COMMAND_UIM_COMPUTE_IP_AUTHENTICATION:   // Usim Apdu 中出现此UIM指令 20180620
  	  		 	    memcpy(&(nat.TranslatorInnerData.ucTranslatorApduArgument[tmpBufCounter]),&(nat.ucDataBufFromNet[tmpCounter+5]),nat.ucDataBufFromNet[tmpCounter+OFFSET_P3]);	
 	   			      nat.TranslatorInnerData.ucTranslatorApduArgumentLength[tmpBufCounter]=nat.ucDataBufFromNet[tmpCounter+OFFSET_P3];
 	   			      tmpCounter+=nat.ucDataBufFromNet[tmpCounter+OFFSET_P3]+5;       								        		  				     		      
 	   			      break;  
    	  	 case APDU_COMMAND_SELECT:
    	  	 	      //如果本地当前通道文件在AID下，则省去此条Select指令  
    	  	 	    if  (
    	  	 	    	   ((tmpCounter+nat.ucDataBufFromNet[tmpCounter+OFFSET_P3]+5)<nat.usDataBufLengthFromNet)&&\
    	  	 	    	   (nat.ucDataBufFromNet[tmpCounter+nat.ucDataBufFromNet[tmpCounter+OFFSET_P3]+5+OFFSET_INS]==APDU_COMMAND_RUN_GSM_ALGORITHM)&&\
    	  	 	    	    (nat.ucSelectFileStatus==SELECTFILESTATUS_SUCCESS)&&\
    	  	 	    	   (((nat.ucCurrentProcessLch)&&(nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_Identifier[0]==0x7f)&&(nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_Identifier[1]==0xff))||\
    	  	 	    	   ((!nat.ucCurrentProcessLch)&&(nat.ucCurrentCardIdentifier[0]==0x7f)&&(nat.ucCurrentCardIdentifier[1]==0xff)))
    	  	 	    	  )  
    	  	 	    	    nat.ucCurrentInnerDataProcessStatus=INNERDATAPROCESSSTATUS_IGNORE;
    	  	 	    else	    	  	 	    	          
 	   			         memcpy(&(nat.TranslatorInnerData.ucTranslatorApduArgument[tmpBufCounter]),&(nat.ucDataBufFromNet[tmpCounter+5]),nat.ucDataBufFromNet[tmpCounter+OFFSET_P3]);	
 	   			      nat.TranslatorInnerData.ucTranslatorApduArgumentLength[tmpBufCounter]=nat.ucDataBufFromNet[tmpCounter+OFFSET_P3];
 	   			      tmpCounter+=nat.ucDataBufFromNet[tmpCounter+OFFSET_P3]+5;       								        		  				     		      
 	   			      break;   
 	   			  case APDU_COMMAND_READ_BINARY:   
 	   			  	      if (((nat.ucDataBufFromNet[tmpCounter+OFFSET_P1])>>5)==READ_UPDATE_BINARY_P1_SFI_SUPPORT_B8_B7_B6){  //SFI  	  	
   	  	                 
   	                      nat.ucCurrentSFI=(nat.ucDataBufFromNet[tmpCounter+OFFSET_P1])&0x1F; 
   	                   //   if (GenExpectedFidWithSfi_Usim()>0){
     		   	  	      	//       std::cout<<GREEN<<"Bank Side Get right SFI "<<RESET<<std::endl<<std::flush;  
     		   	  	      	       nat.ucCurrentReadMode=READMODE_SFI;	                           
     		   	  	        //  }
   	                 }
   	            tmpCounter+=5;     
 	   			  	  break;                             
  	  		
  	  		 case APDU_COMMAND_READ_RECORD:    	  		 	  	  		 	       
  	  		  	   if (((nat.ucDataBufFromNet[tmpCounter+OFFSET_P2])>>3)>0){  //SFI  	  	  	  	                 
   	                    nat.ucCurrentSFI=(nat.ucDataBufFromNet[tmpCounter+OFFSET_P2])>>3; 
   	                    //  if (GenExpectedFidWithSfi_Usim()>0){
     		   	  	      	 //      std::cout<<GREEN<<"Bank Side Get right SFI "<<RESET<<std::endl<<std::flush;  
     		   	  	      	       nat.ucCurrentReadMode=READMODE_SFI;	                           
     		   	  	        //  }
   	                 }
   	            tmpCounter+=5;     
 	   			  	  break;
 	   			  	                 
 	   			 case APDU_COMMAND_STATUS:                	  		        	  
  	  		 case APDU_COMMAND_INVALIDATE:          	
  	  		 case APDU_COMMAND_REHABILITATE: 	
  	  		 case APDU_COMMAND_SLEEP: 
  	  		 case APDU_COMMAND_GET_RESPONSE:    
  	  		 case APDU_COMMAND_FETCH: 
  	  		 case APDU_COMMAND_MANAGE_CHANNEL:  // Usim Apdu 中出现此UIM指令
  	  		 	
  	  		 	// Add  Command in C.S0023-0_v4.0  //20200102
  	  		 case	APDU_COMMAND_UIM_COMMIT:	
  	  		 	 		tmpCounter+=5;
  	  		 	 		break;
  	  		 default:	
  	  		 	 std::cout<<RED<<"TranslateNetApiToApdu Err"<<RESET<<std::endl<<std::flush;	 
  	  		 	 return -1;      	
  	  	}
  	  	if (nat.ucCurrentInnerDataProcessStatus==INNERDATAPROCESSSTATUS_IGNORE	) 	
  	  	    nat.ucCurrentInnerDataProcessStatus=INNERDATAPROCESSSTATUS_NORMAL;
  	  	else   
  	  	  tmpBufCounter++;	 	 	  		 		
		}
	//2018.06.10 B
		  // APDU_COMMAND_UIM_STORE_ESN_ME:    //出现过参数小于8的样例，需要初始化usDataBufLengthFromNet
		  memset(nat.ucDataBufFromNet,0,NETAPIBUFMAXLENGTH);	  
		//2018.06.10 E
			
	if(tmpCounter!=nat.usDataBufLengthFromNet){
		 std::cout<<RED<<"TranslateNetApiToApdu Length Err"<<RESET<<std::endl<<std::flush;	
		 return -1;
	}	
//Debug S	
/*	for ( tmpBufCounter=0;tmpBufCounter<TRANSLATOR_APDUCMD_DEEPTH;tmpBufCounter++){
		    if (!(nat.TranslatorInnerData.ucTranslatorApduCommand[tmpBufCounter][OFFSET_INS]))
		 	       break;
		 	  else{
		 	  	     std::cout<<"TranslateNetApiToApdu Print"<<std::endl<<std::flush; 
		 	  	     for ( int tmp=0;tmp<5;tmp++)
		 	  	         std::cout<<std::hex <<(unsigned short)nat.TranslatorInnerData.ucTranslatorApduCommand[tmpBufCounter][tmp]<<" ";
		 	  	     std::cout<<std::hex <<"  Arg:";    	
               for ( int tmp=0;tmp<nat.TranslatorInnerData.ucTranslatorApduArgumentLength[tmpBufCounter];tmp++)	
                   std::cout<<std::hex <<(unsigned short)nat.TranslatorInnerData.ucTranslatorApduArgument[tmpBufCounter][tmp]<<" ";
               std::cout<<std::endl<<std::flush;    		 	  	        	 
		 	  }		 	  	    
		}*/
//Debug E		 
		return 1;
}


int  NetApiToSimTranslator::PseudoNetDataDeliver2Translater(unsigned char*PtrPseudoDataBuf,unsigned char PseudoDataLength,unsigned char PseudoDataProperity ){
	 if (PseudoDataLength>NETAPIBUFMAXLENGTH)
	 	  return -1;
	  memcpy(nat.ucDataBufFromNet,PtrPseudoDataBuf,PseudoDataLength);
	  nat.usDataBufLengthFromNet=(unsigned short)PseudoDataLength;
	  nat.ucDataPropertyFromNet=PseudoDataProperity;
	  return 1;
}	


/**************************************************************************** 
* 函数名称 : NetApiToApduGenFileOperationList
* 类       ：NetApiToSimTranslator
* 功能描述 : 产生 FileOperationList， 用于产生Bank侧Simcard 文件目录到 Net侧传递的文件的有效文件路径
* 参    数 : 
* 参    数 : 
* 参    数 : 
* 返 回 值 :   成功 返回 1   不成功  返回 -1
* 作    者 : 王翔
* 设计日期 : 
* 修改日期		  修改人		   修改内容  
 *****************************************************************************/	
 int  NetApiToSimTranslator::NetApiToApduGenFileOperationList(){
	  unsigned char net1stidentifier[2];
	  vcard_file_property_t file1,file2;
	  vcard_file_property_t tmpfile3;
	
   	int iCounter,iListCounter,tmpCounter,retvalue;
	  unsigned char tmp_identifier[2],path_identifier[SIMFILEPATHDEEPTH][2];
	  unsigned char mf_identifier[2]=MF_IDENTIFIER;  //Update 9/21/2015  
	  unsigned char NetSideIdPath[SIMFILEPATHDEEPTH][2]; //Update 12/14/2017
	  unsigned char pathlength;
	  alltype_vcard_identifier_t NetSide_Alltype_Identifier,BankSide_Alltype_Identifier ;
	  if (NetApiGetNetSideIdPathAndSaveOffsetWithoutPath(NetSideIdPath,&pathlength)!=1) // 如果网络传来的路径过深
	  	  return -1;
	  if 	(pathlength==0)   //如果没有文件标识符号
	  	  return 0;  
	  	    	  
	  //网络侧路径转换成alltype_vcard_identifier_t 格式	  
	  NetSide_Alltype_Identifier.length=	pathlength;
	  if (pathlength==1){
	  	 NetSide_Alltype_Identifier.identifier1[0]= NetSideIdPath[0][0];
	  	 NetSide_Alltype_Identifier.identifier1[1]= NetSideIdPath[0][1]; 
	  }
	  else
	  if (pathlength==2){
	  	 NetSide_Alltype_Identifier.identifier1[0]= NetSideIdPath[0][0];
	  	 NetSide_Alltype_Identifier.identifier1[1]= NetSideIdPath[0][1]; 
	  	 NetSide_Alltype_Identifier.identifier2[0]= NetSideIdPath[1][0];
	  	 NetSide_Alltype_Identifier.identifier2[1]= NetSideIdPath[1][1]; 
	  }	
	  else
	  if (pathlength==3){
	  	 NetSide_Alltype_Identifier.identifier1[0]= NetSideIdPath[0][0];
	  	 NetSide_Alltype_Identifier.identifier1[1]= NetSideIdPath[0][1]; 
	  	 NetSide_Alltype_Identifier.identifier2[0]= NetSideIdPath[1][0];
	  	 NetSide_Alltype_Identifier.identifier2[1]= NetSideIdPath[1][1]; 
	  	 NetSide_Alltype_Identifier.identifier3[0]= NetSideIdPath[2][0];
	  	 NetSide_Alltype_Identifier.identifier3[1]= NetSideIdPath[2][1]; 
	  }	
	   if (NetSide_Alltype_Identifier.identifier1[1]==0x44)
	           	     	tmpfile3.identifier[1]=0x44; 
	 
	  if (FunGetVcardFilePropertyWithPath_Sim(NetSide_Alltype_Identifier,&file2)<0){  //非标准库中的文件
	  	   // Net Path 找文件
	  	  std::cout<<MAGENTA<<"The identifier from net is not found in GSM11.11 "<<RESET<<std::endl<<std::flush; 
	  	  if (Tranfer_AllTypePath2FileProperty(NetSide_Alltype_Identifier,&file2)<0)
	  	  	 return -1;
	  }
	  
	  //Bank侧路径转换成alltype_vcard_identifier_t 格式	 
	   int deeplen=0;
	   if (nat.CurrentIdWithPath.firstlevelid[0]!=0)
	       deeplen++;
	   if (nat.CurrentIdWithPath.secondlevelid[0]!=0)
	       deeplen++;    
	   if (nat.CurrentIdWithPath.thirdlevelid[0]!=0)
	       deeplen++;   
	   
	   
	   if  (deeplen==1){ //firstlevelid
	   	  BankSide_Alltype_Identifier.length=1;
	   	  BankSide_Alltype_Identifier.identifier1[0]=nat.CurrentIdWithPath.firstlevelid[0];	   	
	   	  BankSide_Alltype_Identifier.identifier1[1]=nat.CurrentIdWithPath.firstlevelid[1];	   	
	   	} 
	   	else
	    if  (deeplen==2){ //secondlevelid
	   	  BankSide_Alltype_Identifier.length=2;
	   	  BankSide_Alltype_Identifier.identifier1[0]=nat.CurrentIdWithPath.firstlevelid[0];	
	   	  BankSide_Alltype_Identifier.identifier1[1]=nat.CurrentIdWithPath.firstlevelid[1];	
	   	  BankSide_Alltype_Identifier.identifier2[0]=nat.CurrentIdWithPath.secondlevelid[0];
	   	  BankSide_Alltype_Identifier.identifier2[1]=nat.CurrentIdWithPath.secondlevelid[1];	 	   	   	
	   	}
	   	else      
	    if  (deeplen==3){ //secondlevelid
	   	  BankSide_Alltype_Identifier.length=3;
	   	  BankSide_Alltype_Identifier.identifier1[0]=nat.CurrentIdWithPath.firstlevelid[0];	
	   	  BankSide_Alltype_Identifier.identifier1[1]=nat.CurrentIdWithPath.firstlevelid[1];	
	   	  BankSide_Alltype_Identifier.identifier2[0]=nat.CurrentIdWithPath.secondlevelid[0];	 
	   	  BankSide_Alltype_Identifier.identifier2[1]=nat.CurrentIdWithPath.secondlevelid[1];
	   	  BankSide_Alltype_Identifier.identifier3[0]=nat.CurrentIdWithPath.thirdlevelid[0];	
	   	  BankSide_Alltype_Identifier.identifier3[1]=nat.CurrentIdWithPath.thirdlevelid[1];	      	   	
	   	}  
	   
	    if  (deeplen==0)  //MF
	       FuncGetVcardFileProperty(mf_identifier, &file1);
	    else{
	   	     // 通过vcard_file_property_list 找文件
	        if (FunGetVcardFilePropertyWithPath_Sim(BankSide_Alltype_Identifier,&file1)<0){  //非标准库中的文件
	  	   // Bank Path 找文件
	  	        std::cout<<MAGENTA<<"The current identifier in bank side  is not found in GSM11.11 "\
	  	    	  <<(unsigned short)nat.ucCurrentCardIdentifier[0]<<" "<<(unsigned short)nat.ucCurrentCardIdentifier[1]<<RESET<<std::endl<<std::flush; 
	  	    if (Tranfer_AllTypePath2FileProperty(BankSide_Alltype_Identifier,&file1)<0)
	  	  	 return -1;
	        }	   		   	
	    }
	    // 
	    // 如果2端文件完全相同，省去定位
	    if (NetSide_Alltype_Identifier.length==1)
	        if (
	        	  (file1.identifier[0]==file2.identifier[0])&&\
	        	  (file1.identifier[1]==file2.identifier[1])&&\
	        	  (nat.ucCurrentOffsetWithoutPathCommand<nat.usDataBufLengthFromNet)   //表明后面还有命令
	        	 ){
	        	
	        	 return 1;
	        	}
	     if (NetSide_Alltype_Identifier.length==2)
	        if (
	        	  (file1.identifier[0]==file2.identifier[0])&&\
	        	  (file1.identifier[1]==file2.identifier[1])&&\
	        	  (file1.parent_identifier[0]==file2.parent_identifier[0])&&\
	        	  (file1.parent_identifier[1]==file2.parent_identifier[1])&&\
	        	  (nat.ucCurrentOffsetWithoutPathCommand<nat.usDataBufLengthFromNet)   //表明后面还有命令
	        	 )
	        	 return 1;
	     if (NetSide_Alltype_Identifier.length==3)
	        if (
	        	  (file1.identifier[0]==file2.identifier[0])&&\
	        	  (file1.identifier[1]==file2.identifier[1])&&\
	        	  (file1.parent_identifier[0]==file2.parent_identifier[0])&&\
	        	  (file1.parent_identifier[1]==file2.parent_identifier[1])&&\
	        	  (file1.grandfather_identifier[0]==file2.grandfather_identifier[0])&&\
	        	  (file1.grandfather_identifier[1]==file2.grandfather_identifier[1])&&\
	        	  (nat.ucCurrentOffsetWithoutPathCommand<nat.usDataBufLengthFromNet)   //表明后面还有命令
	        	 )
	        	 return 1;
	     
	    
	     if ((retvalue=FuncCheckNextFileThrough_Sim_File_Property(file1, file2))==0){	 	//   		   	 	               	  		     	 		     	 	 	     	                        
	       tmp_identifier[0] = file2.identifier[0];
	       tmp_identifier[1] = file2.identifier[1];   
	       tmpfile3=file2;
	       for (tmpCounter=0;tmpCounter<SIMFILEPATHDEEPTH;tmpCounter++){
	          // if (FuncGetFileParent_Uim(tmp_identifier,&(path_identifier[tmpCounter]))==1){  
	           	   //生成 parent file
	           	  
	           	   path_identifier[tmpCounter][0]=tmpfile3.parent_identifier[0];
	           	   path_identifier[tmpCounter][1]=tmpfile3.parent_identifier[1];
	           	   tmpfile3.identifier[0] =tmpfile3.parent_identifier[0];
	           	   tmpfile3.identifier[1] =tmpfile3.parent_identifier[1];
	           	   tmpfile3.parent_identifier[0]=tmpfile3.grandfather_identifier[0];
	           	   tmpfile3.parent_identifier[1]=tmpfile3.grandfather_identifier[1];
	           	   tmpfile3.grandfather_identifier[0]=tmpfile3.great_grandfather_identifier[0]; 
	           	   tmpfile3.grandfather_identifier[1]=tmpfile3.great_grandfather_identifier[1]; 
				   tmpfile3.great_grandfather_identifier[0] = 0x3F;
				   tmpfile3.great_grandfather_identifier[1] = 0x0;

				   
	           	   if 	((tmpfile3.identifier[0]== FILE_1ST_ID_UNDER_MF_EF)||\
	     		             (tmpfile3.identifier[0]== FILE_1ST_ID_UNDER_1LEVEL_DF_EF)||\ 
	     		             (tmpfile3.identifier[0]== FILE_1ST_ID_UNDER_2LEVEL_DF_EF))
	     		                  tmpfile3.property=FILE_TYPE_EF;
	               else	     	
	     	         if 	((tmpfile3.identifier[0]== FILE_1ST_ID_1LEVEL_DF)||\
	     		          (tmpfile3.identifier[0]== FILE_1ST_ID_2LEVEL_DF))
	     		                  tmpfile3.property=FILE_TYPE_DF;
	     	         else	     	
	     	         if 	(tmpfile3.identifier[0]== FILE_1ST_ID_MF)
	     		                  tmpfile3.property=FILE_TYPE_MF;
	           	   
	           	  
	               if ((retvalue=FuncCheckNextFileThrough_Sim_File_Property(file1,  tmpfile3))==1)
	                  break;
	               else {
	  	                if (retvalue<0){
	  	        	          std::cout<<YELLOW<<"Warning! CheckNextFileThrough fail1"<<RESET<<std::endl<<std::flush;	
	                       return -1;	
	  	        	      }
	               } 
	                     	                          	                
	          // }
	           /*
	           else  {                          	  	    
	 	            std::cout<<YELLOW<<"Warning! GetFileParent fail"<<RESET<<std::endl<<std::flush;	
	 	            return -1;	 
	           }
	           	
	           tmp_identifier[0]=	path_identifier[tmpCounter][0]; 
	           tmp_identifier[1]=	path_identifier[tmpCounter][1]; 
	           */
	       }
	       if (tmpCounter==SIMFILEPATHDEEPTH){    // 没有找到2个文件的转换路径
	         std::cout<<YELLOW<<"Warning! Can not find PATH File A -> File B"<<RESET<<std::endl<<std::flush;		                        	  
	         return -1;	 
	       }	
	       else	{  	                             
	             iListCounter=0;
	             do {
	                 nat.TranslatorInnerData.FileOperationList[iListCounter].identifier[0]=path_identifier[tmpCounter][0];
	                 nat.TranslatorInnerData.FileOperationList[iListCounter].identifier[1]=path_identifier[tmpCounter][1];	  	                                   		     	 	 	    	               
	                 iListCounter++;
	                 tmpCounter--;
	             }	while (tmpCounter>=0);
	             //将路径末节点加上
	              nat.TranslatorInnerData.FileOperationList[iListCounter].identifier[0]=file2.identifier[0];
	              nat.TranslatorInnerData.FileOperationList[iListCounter].identifier[1]=file2.identifier[1];	  
	             
	       }	                          	    	    
	     }  		     	 	 
	     else {  		     	 	 	       
	         if (retvalue<0){ 	  		     	 	 	           
	             std::cout<<YELLOW<<"Warning! CheckNextFileThrough fail"<<RESET<<std::endl<<std::flush;	
	             return -1;	
	         }
	         // 表示能直接转换
	         //将路径末节点加上
	              nat.TranslatorInnerData.FileOperationList[0].identifier[0]=file2.identifier[0];
	              nat.TranslatorInnerData.FileOperationList[0].identifier[1]=file2.identifier[1];	   
	     }		
    return 1;	    //Update 9/21/2015			  
	}	

int  NetApiToSimTranslator::NetApiGetNetSideIdPathAndSaveOffsetWithoutPath(unsigned char (*pNetSideIdPath)[2],unsigned char *pPathlength){
	int tmpBufCounter=0,tmpCounter=0;
	nat.ucCurrentOffsetWithoutPathCommand=0;
	
	while (tmpBufCounter<nat.usDataBufLengthFromNet){
		  if (nat.ucDataBufFromNet[tmpBufCounter+1]==APDU_COMMAND_SELECT) {
		  	    if (tmpCounter>=SIMFILEPATHDEEPTH){
		  	    	  std::cout<<RED<<"Too many Identifier Path from net! "<<RESET<<std::endl<<std::flush;
		  	    	  nat.ucCurrentOffsetWithoutPathCommand=0;
	   	          return -1;
		  	    	}		  	    	
		  	    (*(pNetSideIdPath+tmpCounter))[0]=nat.ucDataBufFromNet[tmpBufCounter+5];
		  	    (*(pNetSideIdPath+tmpCounter))[1]=nat.ucDataBufFromNet[tmpBufCounter+6];		  	    
		  	    tmpBufCounter=tmpBufCounter+7;
		  	    nat.ucCurrentOffsetWithoutPathCommand=tmpBufCounter;
		  	    tmpCounter++;	  	   
		  }
		  else
		  	   break;		  	    	  	 
	}
	*pPathlength=tmpCounter;
  return 1;
}
int  NetApiToSimTranslator::Tranfer_AllTypePath2FileProperty(alltype_vcard_identifier_t NetSide_Alltype_Identifier,vcard_file_property_t *pfile){
	      if (NetSide_Alltype_Identifier.length==1){
	      	  pfile->identifier[0]=NetSide_Alltype_Identifier.identifier1[0];
	      	  pfile->identifier[1]=NetSide_Alltype_Identifier.identifier1[1];

				pfile->parent_identifier[0] = 0x3F;
				pfile->parent_identifier[1] = 0x0;
				pfile->grandfather_identifier[0] = 0x3F;
				pfile->grandfather_identifier[1] = 0x0;
				pfile->great_grandfather_identifier[0] = 0x3F;
				pfile->great_grandfather_identifier[1] = 0x0;
	     	}
	     	else
	     	if (NetSide_Alltype_Identifier.length==2){
	      	  pfile->identifier[0]=NetSide_Alltype_Identifier.identifier2[0];
	      	  pfile->identifier[1]=NetSide_Alltype_Identifier.identifier2[1];
	     	    pfile->parent_identifier[0]=NetSide_Alltype_Identifier.identifier1[0];
	     	    pfile->parent_identifier[1]=NetSide_Alltype_Identifier.identifier1[1];
				pfile->grandfather_identifier[0] = 0x3F;
				pfile->grandfather_identifier[1] = 0x0;
				pfile->great_grandfather_identifier[0] = 0x3F;
				pfile->great_grandfather_identifier[1] = 0x0;
	     	}
	     	else
	     	if (NetSide_Alltype_Identifier.length==3){
	      	  pfile->identifier[0]=NetSide_Alltype_Identifier.identifier3[0];
	      	  pfile->identifier[1]=NetSide_Alltype_Identifier.identifier3[1];
	     	    pfile->parent_identifier[0]=NetSide_Alltype_Identifier.identifier2[0];
	     	    pfile->parent_identifier[1]=NetSide_Alltype_Identifier.identifier2[1];
	     	    pfile->grandfather_identifier[0]=NetSide_Alltype_Identifier.identifier1[0];
	     	    pfile->grandfather_identifier[1]=NetSide_Alltype_Identifier.identifier1[1];
				pfile->great_grandfather_identifier[0] = 0x3F;
				pfile->great_grandfather_identifier[1] = 0x0;
	     	}	
	     	else{
	     		  std::cout<<RED<<"NetSide_Alltype_Identifier.length is wrong! "<<RESET<<std::endl<<std::flush;
	     		  return -1;	
	     	}	   
	     	  	
	     	if 	((pfile->identifier[0]== FILE_1ST_ID_UNDER_MF_EF)||\
	     		   (pfile->identifier[0]== FILE_1ST_ID_UNDER_1LEVEL_DF_EF)||\ 
	     		    (pfile->identifier[0]== FILE_1ST_ID_UNDER_2LEVEL_DF_EF))
	     		    pfile->property=FILE_TYPE_EF;
	     	else	     	
	     	if 	((pfile->identifier[0]== FILE_1ST_ID_1LEVEL_DF)||\
	     		    (pfile->identifier[0]== FILE_1ST_ID_2LEVEL_DF))
	     		    pfile->property=FILE_TYPE_DF;
	     	else	     	
	     	if 	(pfile->identifier[0]== FILE_1ST_ID_MF)
	     		    pfile->property=FILE_TYPE_MF;
	     	
	     
	  return 1;   	 	  
}

int  NetApiToSimTranslator::NetApiToApduGenFileOperationList_Uim(){
	  unsigned char net1stidentifier[2];
	  vcard_file_property_t file1,file2;
	  vcard_file_property_t tmpfile3;
	  //2018.06.10 B
	  unsigned  char net_currentid_in_standard=1;
	  unsigned  char bank_currentid_in_standard=1; 
	//unsigned  char  netpath_identifier[SIMFILEPATHDEEPTH][2];
	  unsigned  char tmppathlength=0;
	  //2018.06.10 E
	  
   	int iCounter,iListCounter,tmpCounter,retvalue;
	  unsigned char tmp_identifier[2],path_identifier[SIMFILEPATHDEEPTH][2];
	  unsigned char mf_identifier[2]=MF_IDENTIFIER;  //Update 9/21/2015  
	  unsigned char NetSideIdPath[SIMFILEPATHDEEPTH][2]; //Update 12/14/2017
	  unsigned char pathlength;
	  alltype_vcard_identifier_t NetSide_Alltype_Identifier,BankSide_Alltype_Identifier ;
	  if (NetApiGetNetSideIdPathAndSaveOffsetWithoutPath(NetSideIdPath,&pathlength)!=1) // 如果网络传来的路径过深
	  	  return -1;
	  if 	(pathlength==0)   //如果没有文件标识符号
	  	  return 0;  
	  	    	  
	  //网络侧路径转换成alltype_vcard_identifier_t 格式	  
	  NetSide_Alltype_Identifier.length=	pathlength;
	  if (pathlength==1){
	  	 NetSide_Alltype_Identifier.identifier1[0]= NetSideIdPath[0][0];
	  	 NetSide_Alltype_Identifier.identifier1[1]= NetSideIdPath[0][1]; 
	  }
	  else
	  if (pathlength==2){
	  	 NetSide_Alltype_Identifier.identifier1[0]= NetSideIdPath[0][0];
	  	 NetSide_Alltype_Identifier.identifier1[1]= NetSideIdPath[0][1]; 
	  	 NetSide_Alltype_Identifier.identifier2[0]= NetSideIdPath[1][0];
	  	 NetSide_Alltype_Identifier.identifier2[1]= NetSideIdPath[1][1]; 
	  }	
	  else
	  if (pathlength==3){
	  	 NetSide_Alltype_Identifier.identifier1[0]= NetSideIdPath[0][0];
	  	 NetSide_Alltype_Identifier.identifier1[1]= NetSideIdPath[0][1]; 
	  	 NetSide_Alltype_Identifier.identifier2[0]= NetSideIdPath[1][0];
	  	 NetSide_Alltype_Identifier.identifier2[1]= NetSideIdPath[1][1]; 
	  	 NetSide_Alltype_Identifier.identifier3[0]= NetSideIdPath[2][0];
	  	 NetSide_Alltype_Identifier.identifier3[1]= NetSideIdPath[2][1]; 
	  }	
	  // 通过vcard_file_property_list_Uim 找文件
	//  if (NetSideIdPath[0][1]==0x21)
	//  	NetSideIdPath[0][1]=0x21;
	  if (FunGetVcardFilePropertyWithPath_Uim(NetSide_Alltype_Identifier,&file2)<0){  //非标准库中的文件
	  	   // Net Path 找文件
	  	  std::cout<<MAGENTA<<"The identifier from net is not found in 3GPP2 C.S0023-C "<<RESET<<std::endl<<std::flush; 
	  	  net_currentid_in_standard=0;
	  	  if (Tranfer_AllTypePath2FileProperty(NetSide_Alltype_Identifier,&file2)<0)
	  	  	 return -1;
	  }
	  
	  //Bank侧路径转换成alltype_vcard_identifier_t 格式	 
	   int deeplen=0;
	   if (nat.CurrentIdWithPath.firstlevelid[0]!=0)
	       deeplen++;
	   if (nat.CurrentIdWithPath.secondlevelid[0]!=0)
	       deeplen++;    
	   if (nat.CurrentIdWithPath.thirdlevelid[0]!=0)
	       deeplen++;   
	   
	   
	   if  (deeplen==1){ //firstlevelid
	   	  BankSide_Alltype_Identifier.length=1;
	   	  BankSide_Alltype_Identifier.identifier1[0]=nat.CurrentIdWithPath.firstlevelid[0];	   	
	   	  BankSide_Alltype_Identifier.identifier1[1]=nat.CurrentIdWithPath.firstlevelid[1];	   	
	   	} 
	   	else
	    if  (deeplen==2){ //secondlevelid
	   	  BankSide_Alltype_Identifier.length=2;
	   	  BankSide_Alltype_Identifier.identifier1[0]=nat.CurrentIdWithPath.firstlevelid[0];	
	   	  BankSide_Alltype_Identifier.identifier1[1]=nat.CurrentIdWithPath.firstlevelid[1];	
	   	  BankSide_Alltype_Identifier.identifier2[0]=nat.CurrentIdWithPath.secondlevelid[0];
	   	  BankSide_Alltype_Identifier.identifier2[1]=nat.CurrentIdWithPath.secondlevelid[1];	 	   	   	
	   	}
	   	else      
	    if  (deeplen==3){ //secondlevelid
	   	  BankSide_Alltype_Identifier.length=3;
	   	  BankSide_Alltype_Identifier.identifier1[0]=nat.CurrentIdWithPath.firstlevelid[0];	
	   	  BankSide_Alltype_Identifier.identifier1[1]=nat.CurrentIdWithPath.firstlevelid[1];	
	   	  BankSide_Alltype_Identifier.identifier2[0]=nat.CurrentIdWithPath.secondlevelid[0];	 
	   	  BankSide_Alltype_Identifier.identifier2[1]=nat.CurrentIdWithPath.secondlevelid[1];
	   	  BankSide_Alltype_Identifier.identifier3[0]=nat.CurrentIdWithPath.thirdlevelid[0];	
	   	  BankSide_Alltype_Identifier.identifier3[1]=nat.CurrentIdWithPath.thirdlevelid[1];	      	   	
	   	}  
	   
	    if  (deeplen==0)  //MF
	       FuncGetVcardFileProperty_Uim(mf_identifier, &file1);
	    else{
	   	     // 通过vcard_file_property_list_Uim 找文件
	        if (FunGetVcardFilePropertyWithPath_Uim(BankSide_Alltype_Identifier,&file1)<0){  //非标准库中的文件
	  	   // Bank Path 找文件
	  	    std::cout<<MAGENTA<<"The current identifier in bank side  is not found in 3GPP2 C.S0023-C "<<RESET<<std::endl<<std::flush; 
	  	    bank_currentid_in_standard=0;
	  	    if (Tranfer_AllTypePath2FileProperty(BankSide_Alltype_Identifier,&file1)<0)
	  	  	 return -1;
	        }	   		   	
	    }
	        
	    // 
	    // 如果2端文件完全相同，省去定位
	    if (NetSide_Alltype_Identifier.length==1)
	        if (
	        	  (file1.identifier[0]==file2.identifier[0])&&\
	        	  (file1.identifier[1]==file2.identifier[1])&&\
	        	  (nat.ucCurrentOffsetWithoutPathCommand<nat.usDataBufLengthFromNet)   //表明后面还有命令
	        	 ){
	        	
	        	 return 1;
	        	}
	     if (NetSide_Alltype_Identifier.length==2)
	        if (
	        	  (file1.identifier[0]==file2.identifier[0])&&\
	        	  (file1.identifier[1]==file2.identifier[1])&&\
	        	  (file1.parent_identifier[0]==file2.parent_identifier[0])&&\
	        	  (file1.parent_identifier[1]==file2.parent_identifier[1])&&\
	        	  (nat.ucCurrentOffsetWithoutPathCommand<nat.usDataBufLengthFromNet)   //表明后面还有命令
	        	 )
	        	 return 1;
	 //    if (NetSide_Alltype_Identifier.length==2)
	     if (NetSide_Alltype_Identifier.length==3)	
	        if (
	        	  (file1.identifier[0]==file2.identifier[0])&&\
	        	  (file1.identifier[1]==file2.identifier[1])&&\
	        	  (file1.parent_identifier[0]==file2.parent_identifier[0])&&\
	        	  (file1.parent_identifier[1]==file2.parent_identifier[1])&&\
	        	  (file1.grandfather_identifier[0]==file2.grandfather_identifier[0])&&\
	        	  (file1.grandfather_identifier[1]==file2.grandfather_identifier[1])&&\
	        	  (nat.ucCurrentOffsetWithoutPathCommand<nat.usDataBufLengthFromNet)   //表明后面还有命令
	        	 )
	        	 return 1;
	     
	     //2018.06.10 B  如果2端 ID 都不在标准内，递归找到NetSide路径中在标准内的ID
	      //  if((bank_currentid_in_standard==0)&&(net_currentid_in_standard==0)){
	          if(net_currentid_in_standard==0){
	        	    while (NetSide_Alltype_Identifier.length){
	        	    	   NetSide_Alltype_Identifier.length--;
	        	    	   if (FunGetVcardFilePropertyWithPath_Uim(NetSide_Alltype_Identifier,&file2)<0){  //非标准库中的文件
	  	                    std::cout<<MAGENTA<<"Identifier From Net is not found in 3GPP2 C.S0023-C "<<RESET<<std::endl<<std::flush; 
	  	                    if (Tranfer_AllTypePath2FileProperty(NetSide_Alltype_Identifier,&file2)<0)
	  	  	                   return -1;
	                   }
	                   else
	                   	   break;        	    	 
	        	    }
	        	    
	        	    if (!NetSide_Alltype_Identifier.length){  //netID 路径中所有文件都不在标准中
	        	    	  std::cout<<MAGENTA<<"Path from net is not found in 3GPP2 C.S0023-C "<<RESET<<std::endl<<std::flush; 	  	              
	  	  	          return -1;	        	    	
	        	    }
	        	}  
	        	 if(bank_currentid_in_standard==0){
	        	    while (BankSide_Alltype_Identifier.length){
	        	    	   BankSide_Alltype_Identifier.length--;
	        	    	   if (FunGetVcardFilePropertyWithPath_Uim(BankSide_Alltype_Identifier,&file1)<0){  //非标准库中的文件
	  	                    std::cout<<MAGENTA<<"Identifier from Bank is not found in 3GPP2 C.S0023-C "<<RESET<<std::endl<<std::flush; 
	  	                    if (Tranfer_AllTypePath2FileProperty(BankSide_Alltype_Identifier,&file1)<0)
	  	  	                   return -1;
	                   }
	                   else
	                   	   break;        	    	 
	        	    }
	        	    
	        	    if (!BankSide_Alltype_Identifier.length){  //netID 路径中所有文件都不在标准中
	        	    	  std::cout<<MAGENTA<<"Path from Bank is not found in 3GPP2 C.S0023-C "<<RESET<<std::endl<<std::flush; 	  	              
	  	  	          return -1;	        	    	
	        	    }
	        	}              
	     //2018.06.10 E
	     
	     if ((retvalue=FuncCheckNextFileThrough_Uim_File_Property(file1, file2))==0){	 	//   		   	 	               	  		     	 		     	 	 	     	                        
	       tmp_identifier[0] = file2.identifier[0];
	       tmp_identifier[1] = file2.identifier[1];   
	       tmpfile3=file2;
	       for (tmpCounter=0;tmpCounter<SIMFILEPATHDEEPTH;tmpCounter++){
	           	   //生成 parent file
	           	  
	           	   path_identifier[tmpCounter][0]=tmpfile3.parent_identifier[0];
	           	   path_identifier[tmpCounter][1]=tmpfile3.parent_identifier[1];
	           	   tmpfile3.identifier[0] =tmpfile3.parent_identifier[0];
	           	   tmpfile3.identifier[1] =tmpfile3.parent_identifier[1];
	           	   tmpfile3.parent_identifier[0]=tmpfile3.grandfather_identifier[0];
	           	   tmpfile3.parent_identifier[1]=tmpfile3.grandfather_identifier[1];
	           	   tmpfile3.grandfather_identifier[0]=tmpfile3.great_grandfather_identifier[0]; 
	           	   tmpfile3.grandfather_identifier[1]=tmpfile3.great_grandfather_identifier[1]; 
	           	   tmpfile3.great_grandfather_identifier[0] = 0x3F;
				   tmpfile3.great_grandfather_identifier[1] = 0x0;
				   
	           	   if 	((tmpfile3.identifier[0]== FILE_1ST_ID_UNDER_MF_EF)||\
	     		             (tmpfile3.identifier[0]== FILE_1ST_ID_UNDER_1LEVEL_DF_EF)||\ 
	     		             (tmpfile3.identifier[0]== FILE_1ST_ID_UNDER_2LEVEL_DF_EF))
	     		                  tmpfile3.property=FILE_TYPE_EF;
	               else	     	
	     	         if 	((tmpfile3.identifier[0]== FILE_1ST_ID_1LEVEL_DF)||\
	     		          (tmpfile3.identifier[0]== FILE_1ST_ID_2LEVEL_DF))
	     		                  tmpfile3.property=FILE_TYPE_DF;
	     	         else	     	
	     	         if 	(tmpfile3.identifier[0]== FILE_1ST_ID_MF)
	     		                  tmpfile3.property=FILE_TYPE_MF;
	           	   
	           	   
	               if ((retvalue=FuncCheckNextFileThrough_Uim_File_Property(file1,  tmpfile3))==1)
	                  break;
	               else {
	  	                if (retvalue<0){
	  	        	          std::cout<<YELLOW<<"Warning! CheckNextFileThrough fail1"<<RESET<<std::endl<<std::flush;	
	                       return -1;	
	  	        	      }
	               } 
	                     	                          	                	         
	       }
	       if (tmpCounter==SIMFILEPATHDEEPTH){    // 没有找到2个文件的转换路径
	         std::cout<<YELLOW<<"Warning! Can not find PATH File A -> File B"<<RESET<<std::endl<<std::flush;		                        	  
	         return -1;	 
	       }	
	       else	{  	                             
	             iListCounter=0;
	             //2018.06.11 B
	             if(bank_currentid_in_standard==0){
	              	   tmppathlength=deeplen-BankSide_Alltype_Identifier.length;
	      	           if (tmppathlength==1){
	      	           	   if (deeplen==2){
	      	           	     nat.TranslatorInnerData.FileOperationList[iListCounter].identifier[0]=nat.CurrentIdWithPath.firstlevelid[0];
	                         nat.TranslatorInnerData.FileOperationList[iListCounter].identifier[1]=nat.CurrentIdWithPath.firstlevelid[1];
	      	               }
	      	               if (deeplen==3){
	      	           	     nat.TranslatorInnerData.FileOperationList[iListCounter].identifier[0]=nat.CurrentIdWithPath.secondlevelid[0];
	                         nat.TranslatorInnerData.FileOperationList[iListCounter].identifier[1]=nat.CurrentIdWithPath.secondlevelid[1];
	      	               }
	      	              iListCounter++;
	      	           }
	      	           else {
	      	                if (tmppathlength==2){
	      	                	 if (deeplen==3){
	      	           	          nat.TranslatorInnerData.FileOperationList[iListCounter].identifier[0]=nat.CurrentIdWithPath.secondlevelid[0];
	                              nat.TranslatorInnerData.FileOperationList[iListCounter].identifier[1]=nat.CurrentIdWithPath.secondlevelid[1];
	                              nat.TranslatorInnerData.FileOperationList[iListCounter+1].identifier[0]=nat.CurrentIdWithPath.firstlevelid[0];
	                              nat.TranslatorInnerData.FileOperationList[iListCounter+1].identifier[1]=nat.CurrentIdWithPath.firstlevelid[0];
	                             iListCounter=iListCounter+2;
	                           }
	      	                }
	      	               	else{
	      	               		    std::cout<<MAGENTA<<"Path from net CheckNextFileThrough fail2 "<<RESET<<std::endl<<std::flush; 	  	              
	  	  	                      return -1;	 
	      	               		
	      	               	}      	           	
	      	           }
	     	        }	
	             //2018.06.11 E
	             do {
	                 nat.TranslatorInnerData.FileOperationList[iListCounter].identifier[0]=path_identifier[tmpCounter][0];
	                 nat.TranslatorInnerData.FileOperationList[iListCounter].identifier[1]=path_identifier[tmpCounter][1];	  	                                   		     	 	 	    	               
	                 iListCounter++;
	                 tmpCounter--;
	             }	while (tmpCounter>=0);
	             //将路径末节点加上
	              nat.TranslatorInnerData.FileOperationList[iListCounter].identifier[0]=file2.identifier[0];
	              nat.TranslatorInnerData.FileOperationList[iListCounter].identifier[1]=file2.identifier[1];	
	              
	              //2018.06.10 B 如果2端 ID 都不在标准内，将未在标准内的PATH_ID 补充进去
	              if(net_currentid_in_standard==0){
	              	   tmppathlength=pathlength-NetSide_Alltype_Identifier.length;
	      	           if (tmppathlength==1){
	      	           	  nat.TranslatorInnerData.FileOperationList[iListCounter+1].identifier[0]=NetSideIdPath[pathlength-1][0];
	                      nat.TranslatorInnerData.FileOperationList[iListCounter+1].identifier[1]=NetSideIdPath[pathlength-1][1];
	      	           }
	      	           else {
	      	                if (tmppathlength==2){
	      	           	       nat.TranslatorInnerData.FileOperationList[iListCounter+1].identifier[0]=NetSideIdPath[pathlength-2][0];
	                           nat.TranslatorInnerData.FileOperationList[iListCounter+1].identifier[1]=NetSideIdPath[pathlength-2][1];
	                           nat.TranslatorInnerData.FileOperationList[iListCounter+2].identifier[0]=NetSideIdPath[pathlength-1][0];
	                           nat.TranslatorInnerData.FileOperationList[iListCounter+2].identifier[1]=NetSideIdPath[pathlength-1][1];
	      	                }
	      	               	else{
	      	               		    std::cout<<MAGENTA<<"Path from net CheckNextFileThrough fail2 "<<RESET<<std::endl<<std::flush; 	  	              
	  	  	                      return -1;	 
	      	               		
	      	               	}      	           	
	      	           }
	     	        }	
	     	        //2018.06.10 E   	             
	       }	       	                          	    	    
	     }  		     	 	 
	     else {  		     	 	 	       
	         if (retvalue<0){ 	  		     	 	 	           
	             std::cout<<YELLOW<<"Warning! CheckNextFileThrough fail --- "<<RESET<<std::endl<<std::flush;	
	             return -1;	
	         }
	         // 表示能直接转换
	         //将路径末节点加上
	              //2018.06.11 B
	             iListCounter=0; 
	             if(bank_currentid_in_standard==0){
	              	   tmppathlength=deeplen-BankSide_Alltype_Identifier.length;
	      	           if (tmppathlength==1){
	      	           	   if (deeplen==2){
	      	           	     nat.TranslatorInnerData.FileOperationList[iListCounter].identifier[0]=nat.CurrentIdWithPath.firstlevelid[0];
	                         nat.TranslatorInnerData.FileOperationList[iListCounter].identifier[1]=nat.CurrentIdWithPath.firstlevelid[1];
	      	               }
	      	               if (deeplen==3){
	      	           	     nat.TranslatorInnerData.FileOperationList[iListCounter].identifier[0]=nat.CurrentIdWithPath.secondlevelid[0];
	                         nat.TranslatorInnerData.FileOperationList[iListCounter].identifier[1]=nat.CurrentIdWithPath.secondlevelid[1];
	      	               }
	      	              iListCounter++;
	      	           }
	      	           else {
	      	                if (tmppathlength==2){
	      	                	 if (deeplen==3){
	      	           	          nat.TranslatorInnerData.FileOperationList[iListCounter].identifier[0]=nat.CurrentIdWithPath.secondlevelid[0];
	                              nat.TranslatorInnerData.FileOperationList[iListCounter].identifier[1]=nat.CurrentIdWithPath.secondlevelid[1];
	                              nat.TranslatorInnerData.FileOperationList[iListCounter+1].identifier[0]=nat.CurrentIdWithPath.firstlevelid[0];
	                              nat.TranslatorInnerData.FileOperationList[iListCounter+1].identifier[1]=nat.CurrentIdWithPath.firstlevelid[0];
	                             iListCounter=iListCounter+2;
	                           }
	      	                }
	      	               	else{
	      	               		    std::cout<<MAGENTA<<"Path from net CheckNextFileThrough fail2 "<<RESET<<std::endl<<std::flush; 	  	              
	  	  	                      return -1;	 
	      	               		
	      	               	}      	           	
	      	           }
	     	        }	
	     	        nat.TranslatorInnerData.FileOperationList[iListCounter].identifier[0]=file2.identifier[0];
	              nat.TranslatorInnerData.FileOperationList[iListCounter].identifier[1]=file2.identifier[1];	
	              
	              if(net_currentid_in_standard==0){
	              	   tmppathlength=pathlength-NetSide_Alltype_Identifier.length;
	      	           if (tmppathlength==1){
	      	           	  nat.TranslatorInnerData.FileOperationList[iListCounter+1].identifier[0]=NetSideIdPath[pathlength-1][0];
	                      nat.TranslatorInnerData.FileOperationList[iListCounter+1].identifier[1]=NetSideIdPath[pathlength-1][1];
	      	           }
	      	           else {
	      	                if (tmppathlength==2){
	      	           	       nat.TranslatorInnerData.FileOperationList[iListCounter+1].identifier[0]=NetSideIdPath[pathlength-2][0];
	                           nat.TranslatorInnerData.FileOperationList[iListCounter+1].identifier[1]=NetSideIdPath[pathlength-2][1];
	                           nat.TranslatorInnerData.FileOperationList[iListCounter+2].identifier[0]=NetSideIdPath[pathlength-1][0];
	                           nat.TranslatorInnerData.FileOperationList[iListCounter+2].identifier[1]=NetSideIdPath[pathlength-1][1];
	      	                }
	      	               	else{
	      	               		    std::cout<<MAGENTA<<"Path from net CheckNextFileThrough fail2 "<<RESET<<std::endl<<std::flush; 	  	              
	  	  	                      return -1;	 
	      	               		
	      	               	}      	           	
	      	           }
	     	        }	
	             //2018.06.11 E
	         
	           //  nat.TranslatorInnerData.FileOperationList[0].identifier[0]=file2.identifier[0];
	           //   nat.TranslatorInnerData.FileOperationList[0].identifier[1]=file2.identifier[1];	
	              //2018.06.10 B 如果2端 ID 都不在标准内，将未在标准内的PATH_ID 补充进去
	             /*
	              if(net_currentid_in_standard==0){
	              	   tmppathlength=pathlength-NetSide_Alltype_Identifier.length;
	      	           if (tmppathlength==1){
	      	           	  nat.TranslatorInnerData.FileOperationList[1].identifier[0]=NetSideIdPath[pathlength-1][0];
	                      nat.TranslatorInnerData.FileOperationList[1].identifier[1]=NetSideIdPath[pathlength-1][1];
	      	           }
	      	           else {
	      	                if (tmppathlength==2){
	      	           	       nat.TranslatorInnerData.FileOperationList[1].identifier[0]=NetSideIdPath[pathlength-2][0];
	                           nat.TranslatorInnerData.FileOperationList[1].identifier[1]=NetSideIdPath[pathlength-2][1];
	                           nat.TranslatorInnerData.FileOperationList[2].identifier[0]=NetSideIdPath[pathlength-1][0];
	                           nat.TranslatorInnerData.FileOperationList[2].identifier[1]=NetSideIdPath[pathlength-1][1];
	      	                }
	      	               	else{
	      	               		    std::cout<<MAGENTA<<"Path from net CheckNextFileThrough fail4 "<<RESET<<std::endl<<std::flush; 	  	              
	  	  	                      return -1;	 
	      	               		
	      	               	}      	           	
	      	           }
	     	        }	
	     	        //2018.06.10 E   	
	     	        */ 
	                
	     }
	     
	     
           
    return 1;	    //Update 9/21/2015			  
	}


int  NetApiToSimTranslator::NetApiToApduGenFileOperationList_Usim(){
	unsigned char net1stidentifier[CARD_IDENTIFIERDEEPTH];
	vcard_file_property_t file1,file2;
	
   	int iCounter,iListCounter,tmpCounter,retvalue,i;
	  unsigned char tmp_identifier[CARD_IDENTIFIERDEEPTH],path_identifier[SIMFILEPATHDEEPTH][CARD_IDENTIFIERDEEPTH],tmp_identifierlength;
	  unsigned char path_identifierlength[SIMFILEPATHDEEPTH];  
	  unsigned char mf_identifier[2]=MF_IDENTIFIER;  
	  if (nat.ucDataBufFromNet[1]==APDU_COMMAND_SELECT){
	  	    for (tmp_identifierlength=0;tmp_identifierlength<nat.ucDataBufFromNet[4];tmp_identifierlength)
	  	         net1stidentifier[tmp_identifierlength]=nat.ucDataBufFromNet[5+tmp_identifierlength];
	  	    tmp_identifierlength=tmp_identifierlength<nat.ucDataBufFromNet[4];
	  	   
	  	    if (tmp_identifierlength==nat.ucCurrentCardIdentifierLength){    //检查远端近端identifier是否相同
	  	   	      i=tmp_identifierlength;
	  	   	      while (i){
	  	   	      	          if (net1stidentifier[i]!=nat.ucCurrentCardIdentifier[i])
    	    	  	 	             break;
    	    	  	 	          else
    	    	  	 	   	          i--;   	   	      	
	  	   	      }
	  	   	      if (!i) 
	  	   	      	     return 1;   
	  	   	}
	  	   	
	  	   	if (nat.ucDataBufFromNet[2]==8) // Select by path from MF 与当前文件指针无关
	  	   	     return 1;
	  	   	     	  	  
	  	    if (FuncGetVcardFileProperty_Usim(tmp_identifierlength,net1stidentifier  ,&file1)<0){  //如果不是TS31.102的文件
  	      	    std::cout<<RED<<"Can not between local and remote identifier through pass! "<<RESET<<std::endl<<std::flush;
	   	                    return -1;
	   	    } 
	   	    else{
	   	           //网络侧来的文件是TS31.102的文件，但当前文件不是TS31.102的文件，
	   	           //TODO	   	        
	   	    }   	      	  	
		      	  			      
		}
    return 1;	    //Update 9/21/2015			  
	}

/**************************************************************************** 
* 函数名称 : ProcessSimResponse
* 类       ：NetApiToSimTranslator
* 功能描述 : 处理Sim card 返回的响应
* 参    数 : 
* 参    数 : 
* 参    数 : 
* 返 回 值 :   成功 返回 1   不成功  返回 -1
* 作    者 : 王翔
* 设计日期 : 
* 修改日期		  修改人		   修改内容  
 *****************************************************************************/		
int  NetApiToSimTranslator::ProcessSimResponse(){	
	     if (nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usCurrentTranslatorApduCounter][OFFSET_INS]==0) {
	     	      DirectTransfer_SimToNet();
	     	      if (nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_SELECT){
	     	      	    if ((nat.usDataBufLengthFromSimcard==2)&&(nat.ucDataBufFromSimcard[0]==SW1_9F)){
	     	      	    	 nat.ucCurrentCardIdentifier[0]=nat.TranslatorInnerData.ucTranslatorApduArgument[nat.TranslatorInnerData.usLastTranslatorApduCounter][0];
	     	      	    	 nat.ucCurrentCardIdentifier[1]=nat.TranslatorInnerData.ucTranslatorApduArgument[nat.TranslatorInnerData.usLastTranslatorApduCounter][1];
	     	      	       UpdatePath(nat.ucCurrentCardIdentifier); //2017/12/15
	     	      	    }
	     	      }
	     	      else{   
	     	      if (
	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_RUN_GSM_ALGORITHM)||\
	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UIM_STORE_ESN_ME)||\
	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UIM_GENERATE_KEY_VPM)||\  
	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UIM_BASE_STATION_CHALLENGE)||\
	     	      	 
	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_GET_CHALLENGE)||\
	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UIM_CONFIRM_SSD)||\
	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UIM_GENERATE_PUBLIC_KEY)||\  
	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UIM_KEY_GENERATION_REQUEST)||\
	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UIM_CONFIGURATION_REQUEST)||\  
	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UIM_KEY_DOWNLOAD_REQUEST)||\
	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UIM_OTAPA_REQUEST)||\
	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UIM_SSPR_CONFIGURATION_REQUEST)||\
	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UIM_SSPR_DOWNLOAD_REQUEST)||\  
	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UIM_VALID)
	     	      	
	     	      	) 
	     	      	 	             	                  	
                  	     if (nat.ucTsStatus==TS_STATUS_GEN_GETSTATUS_FOR_RUNAUTH)
                  	     	if ((nat.usDataBufLengthFromSimcard==2)&&(nat.ucDataBufFromSimcard[0]==SW1_9F)){
                  	     		 nat.ResLength=nat.ucDataBufFromSimcard[1];
                  	     	   nat.ucTsStatus=TS_STATUS_GEN_GETSTATUS_RESPONSELENGTH_ENBALE;
                  	     	}   
	     	      }  	      	    	
	     	      std::cout<<GREEN<<std::hex <<"Bank Current Sim Idntifier:"<<(unsigned short)nat.ucCurrentCardIdentifier[0]<<" "<<(unsigned short)nat.ucCurrentCardIdentifier[1]<<std::endl ; 
	     	      
	     	      std::cout<<GREEN<<std::hex <<"Bank Current PATH:";
	     	      std::cout<<GREEN<<std::hex <<(unsigned short)nat.CurrentIdWithPath.firstlevelid[0]\
	     	          	           <<" "<<(unsigned short)nat.CurrentIdWithPath.firstlevelid[1]<<" " ; 	     	          	          	     	      
	     	      std::cout<<GREEN<<std::hex <<(unsigned short)nat.CurrentIdWithPath.secondlevelid[0]\
	     	          	           <<" "<<(unsigned short)nat.CurrentIdWithPath.secondlevelid[1]<<" " ;
	     	      std::cout<<GREEN<<std::hex <<(unsigned short)nat.CurrentIdWithPath.thirdlevelid[0]\
	     	          	           <<" "<<(unsigned short)nat.CurrentIdWithPath.thirdlevelid[1]<<" " ; 	      	     	       
	     	      std::cout<<std::endl ; 
	     	      	    	   
	     }	      
	     else	{      
	          if (nat.TranslatorInnerData.ucExpectDeliverToSim==EXPECT_DELIVER_TO_SIM_APDU_COMMAND){
	    	        //TODO  CheckSimResponse(); 
	    	         if ( nat.TranslatorInnerData.ucTranslatorApduArgumentLength[nat.TranslatorInnerData.usCurrentTranslatorApduCounter]!=0){
	    	         	      TranslatorToSim(EXPECT_DELIVER_TO_SIM_APDU_AERUMENT);
	    	         	      nat.TranslatorInnerData.ucExpectDeliverToSim=EXPECT_DELIVER_TO_SIM_APDU_AERUMENT; 
	    	         	      nat.TranslatorInnerData.usLastTranslatorApduCounter=nat.TranslatorInnerData.usCurrentTranslatorApduCounter  ;  
	    	         	      nat.TranslatorInnerData.usCurrentTranslatorApduCounter++;   	         	     
	    	         } 
	    	         else  {
	    	         	      nat.TranslatorInnerData.usLastTranslatorApduCounter=nat.TranslatorInnerData.usCurrentTranslatorApduCounter  ; 
	    	         	      nat.TranslatorInnerData.usCurrentTranslatorApduCounter++; 
	    	         	      if (nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usCurrentTranslatorApduCounter][OFFSET_INS]==0){ 
	     	                     DirectTransfer_SimToNet();
	     	                   //  std::cout<<std::hex <<"Bank Current Sim Idntifier:"<<(unsigned short)nat.ucCurrentCardIdentifier[0]<<" "<<(unsigned short)nat.ucCurrentCardIdentifier[1]<<std::endl ;    
	     	                }     
	     	                else      
	    	         	          TranslatorToSim(EXPECT_DELIVER_TO_SIM_APDU_COMMAND);
	    	         }	      
	    	         
	    	    }
	    	    else{
	    	    	    if (nat.TranslatorInnerData.ucExpectDeliverToSim==EXPECT_DELIVER_TO_SIM_APDU_AERUMENT){
	    	    	         // nat.TranslatorInnerData.usCurrentTranslatorApduCounter++; 	    	    	          
	    	         	      if (nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usCurrentTranslatorApduCounter][OFFSET_INS]==0){ 
	     	                     DirectTransfer_SimToNet();	     	                     
	     	                }     
	     	                else{      
	    	         	          TranslatorToSim(EXPECT_DELIVER_TO_SIM_APDU_COMMAND); 
	    	         	          nat.TranslatorInnerData.ucExpectDeliverToSim=EXPECT_DELIVER_TO_SIM_APDU_COMMAND;	       	          
	    	         	      }
	    	         	      if (nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_SELECT)
	     	      	           if ((nat.usDataBufLengthFromSimcard==2)&&(nat.ucDataBufFromSimcard[0]==SW1_9F)){
	     	      	    	           nat.ucCurrentCardIdentifier[0]=nat.TranslatorInnerData.ucTranslatorApduArgument[nat.TranslatorInnerData.usLastTranslatorApduCounter][0];
	     	      	    	           nat.ucCurrentCardIdentifier[1]=nat.TranslatorInnerData.ucTranslatorApduArgument[nat.TranslatorInnerData.usLastTranslatorApduCounter][1];
	     	      	                 UpdatePath(nat.ucCurrentCardIdentifier); //2017/12/15
	     	      	           }   
	    	         	      std::cout<<std::hex <<"Bank Current Sim Idntifier:"<<(unsigned short)nat.ucCurrentCardIdentifier[0]<<" "<<(unsigned short)nat.ucCurrentCardIdentifier[1]<<std::endl ;    
	    	         	      
	    	         	      std::cout<<GREEN<<std::hex <<"Bank Current PATH:";
	     	      					std::cout<<GREEN<<std::hex <<(unsigned short)nat.CurrentIdWithPath.firstlevelid[0]\
	     	          	           <<" "<<(unsigned short)nat.CurrentIdWithPath.firstlevelid[1]<<" " ; 	     	          	          	     	      
	     	      					std::cout<<GREEN<<std::hex <<(unsigned short)nat.CurrentIdWithPath.secondlevelid[0]\
	     	          	           <<" "<<(unsigned short)nat.CurrentIdWithPath.secondlevelid[1]<<" " ; 	
	     	          	    std::cout<<GREEN<<std::hex <<(unsigned short)nat.CurrentIdWithPath.thirdlevelid[0]\
	     	          	           <<" "<<(unsigned short)nat.CurrentIdWithPath.thirdlevelid[1]<<" " ; 	              	       
	     	      					std::cout<<std::endl ; 
	    	         	     
	    	    	    }
	    	    	    else	
	    	    	    	  return -1;
	    	    }
	    	    
	     } 
	return 1;         
	}	
	
int  NetApiToSimTranslator::ProcessSimResponse_Usim_Lch0(){
unsigned char  tmpnumber;
    
	     if (nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usCurrentTranslatorApduCounter][OFFSET_INS]==0) {  //已经向卡传完数据	     	     
	     	      DirectTransfer_SimToNet();
	     	      if (nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_SELECT){     	      	  
	     	      	   if (  (nat.usDataBufLengthFromSimcard==2)&& \
	     	      	   	     (
	     	      	   	       (nat.ucDataBufFromSimcard[0]==SW1_61)|| ((nat.ucDataBufFromSimcard[0]==SW1_90)&&(nat.ucDataBufFromSimcard[1]==0))||\
	     	      	   	       ((nat.ucDataBufFromSimcard[0]==SW1_91)&&(nat.ucDataBufFromSimcard[1]!=0)) 
	     	      	   	       // Select NoDataReturn时 repsonse  90 0 or 91 xx
	     	      	   	      )
	     	      	   	   ){	     	      
	     	      	       nat.ucSelectFileStatus=SELECTFILESTATUS_SUCCESS;	     	      	          
	     	      	        //检查是否为合法AID
     	     		 	       if  (nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][APDU_CMD_OFFSET_P3]==0x10) {  //按AID 选择
     	     		 	         for (tmpnumber=0;tmpnumber<sizeof(vc_ridset)/sizeof(rid_inform_t);tmpnumber++){
                 	            if ((!char_arrayncmp ( nat.TranslatorInnerData.ucTranslatorApduArgument[nat.TranslatorInnerData.usLastTranslatorApduCounter], &(vc_ridset[tmpnumber].rid[0]), 5 )))
                 	  	           break;
                 	       }
                 	       if (tmpnumber<sizeof(vc_ridset)/sizeof(rid_inform_t))  { //是合法的AID                 	                  
     	     		  	                     	     		  	  	                   
      	     		  	  	                    nat.ucCurrentSimCardRidType=vc_ridset[tmpnumber].ridtype;
      	     		  	  	                    nat.ucCurrentRidType=nat.ucCurrentSimCardRidType;
      	     		  	  	                    nat.ucCurrentCardIdentifierLength=2;
	     	      	   		                      nat.ucCurrentCardIdentifier[0]=0x7F;
	     	      	   		                      nat.ucCurrentCardIdentifier[1]=0xFF;
      	     		  	  	                  
                 	        }               	   
	     	      	           }
	     	      	       else{   //不是按 AID 选择
	     	      	     	           
	     	      	     	               if (
	     	      	     	               	     (nat.TranslatorInnerData.ucTranslatorApduArgument[nat.TranslatorInnerData.usLastTranslatorApduCounter][0]==0x7f)&&\
	     	      	     	               	     (nat.TranslatorInnerData.ucTranslatorApduArgument[nat.TranslatorInnerData.usLastTranslatorApduCounter][1]==0xff)      
	     	      	     	               	   )	     	      	     	               	   	  
      	     		  	  	                    nat.ucCurrentRidType=nat.ucCurrentSimCardRidType;      	     		  	  	                   	     	      	     	               	   	
	     	      	     	               else
	     	      	     	               	     nat.ucCurrentRidType=RIDTYPE_NONEEDAID;
	     	      	     	               	     
	     	      	     	               nat.ucCurrentCardIdentifierLength=nat.TranslatorInnerData.ucTranslatorApduArgumentLength[nat.TranslatorInnerData.usLastTranslatorApduCounter];
	     	      	                     for (unsigned char i=0;i<nat.ucCurrentCardIdentifierLength;i++)
	     	      	                         nat.ucCurrentCardIdentifier[i]=nat.TranslatorInnerData.ucTranslatorApduArgument[nat.TranslatorInnerData.usLastTranslatorApduCounter][i];
	     	      	     	            
	     	      	     	     }
	     	      	    }
	     	      	    else	     	      	    	 
	     	      	       nat.ucSelectFileStatus=SELECTFILESTATUS_FAIL;	     	      	         
	     	      	     
	     	      }
	     	      else{
	     	       // SFI UPDATE
                  if (
                  	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UPDATE_BINARY)||\
                  	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UPDATE_RECORD)
                  	)
                  	{
               	     	        if (nat.ucCurrentUpdateMode==UPDATEMODE_SFI){
               	     	        	    if (GenExpectedFidWithSfi_Usim()>0)
     		   	  	      	                    std::cout<<GREEN<<"Bank Side Get right SFI "<<RESET<<std::endl<<std::flush; 
               	     	      	 		  nat.ucCurrentUpdateMode=UPDATEMODE_COMMON;
               	     	      	 	  if (nat.usDataBufLengthFromSimcard>=2)
               	     	      	 	  	//读到数据,说明选择文件操作正常
               	     	      	 	     if (
               	     	      	 	     	((nat.ucDataBufFromSimcard[nat.usDataBufLengthFromSimcard-2]==SW1_90)&&(nat.ucDataBufFromSimcard[nat.usDataBufLengthFromSimcard-1]==SW2_00))\
               	     	     		           ||(nat.ucDataBufFromSimcard[nat.usDataBufLengthFromSimcard-2]==SW1_91)
               						        		)
               
               	     	      	       {	     	      	   
               	     	      	          nat.ucCurrentCardIdentifierLength=nat.ucExpectIdentifierLength;
               	     	      	          for (unsigned char i=0;i<nat.ucCurrentCardIdentifierLength;i++)
               	     	      	               nat.ucCurrentCardIdentifier[i]=nat.ucExpectIdentifier[i];
               	     	      	       }	
               	     	      	 }
               	     	      	 std::cout<<GREEN<<std::hex <<"SFI: Update ";
               	     	    
	     	          }
	     	          else {  //Run Auth
	     	          	if (
	     	          		(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_RUN_GSM_ALGORITHM)||\
	     	          		(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UIM_STORE_ESN_ME)||\
	     	          		(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UIM_BASE_STATION_CHALLENGE)||\
	     	          		(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UIM_GENERATE_KEY_VPM)||\  
	     	          		  		 
	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_GET_CHALLENGE)||\
	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UIM_CONFIRM_SSD)||\
	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UIM_GENERATE_PUBLIC_KEY)||\  
	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UIM_KEY_GENERATION_REQUEST)||\
	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UIM_CONFIGURATION_REQUEST)||\  
	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UIM_KEY_DOWNLOAD_REQUEST)||\
	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UIM_OTAPA_REQUEST)||\
	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UIM_SSPR_CONFIGURATION_REQUEST)||\
	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UIM_SSPR_DOWNLOAD_REQUEST)||\  
	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UIM_VALID)
	     	      	)
	     	          		              	                  	
                  	     if (nat.ucTsStatus==TS_STATUS_GEN_GETSTATUS_FOR_RUNAUTH)
                  	     	if ((nat.usDataBufLengthFromSimcard==2)&&(nat.ucDataBufFromSimcard[0]==SW1_61)){
                  	     		 nat.ResLength=nat.ucDataBufFromSimcard[1];
                  	     	   nat.ucTsStatus=TS_STATUS_GEN_GETSTATUS_RESPONSELENGTH_ENBALE;
                  	     	}     	          	 
	     	          }
	     	      } 
	     	       std::cout<<GREEN<<std::hex <<"Bank Current Sim Idntifier: Ch"<<(unsigned short)nat.ucCurrentProcessLch<<"  ";     	  
	     	      for (unsigned char i=0;i<nat.ucCurrentCardIdentifierLength;i++)	 
	     	            std::cout<<GREEN<<std::hex<<(unsigned short)nat.ucCurrentCardIdentifier[i]<<" ";	     	    
	     	     std::cout<<" "<<std::endl ;      
	     	       
	     }	      
	     else	{      
	          if (nat.TranslatorInnerData.ucExpectDeliverToSim==EXPECT_DELIVER_TO_SIM_APDU_COMMAND){
	    	        //TODO  CheckSimResponse(); 
	    	         if ( nat.TranslatorInnerData.ucTranslatorApduArgumentLength[nat.TranslatorInnerData.usCurrentTranslatorApduCounter]!=0){
	    	         	      TranslatorToSim(EXPECT_DELIVER_TO_SIM_APDU_AERUMENT);
	    	         	      nat.TranslatorInnerData.ucExpectDeliverToSim=EXPECT_DELIVER_TO_SIM_APDU_AERUMENT; 
	    	         	      nat.TranslatorInnerData.usLastTranslatorApduCounter=nat.TranslatorInnerData.usCurrentTranslatorApduCounter  ;  
	    	         	      nat.TranslatorInnerData.usCurrentTranslatorApduCounter++;   	         	     
	    	         } 
	    	         else  {	    	         	       
	    	         	      nat.TranslatorInnerData.usLastTranslatorApduCounter=nat.TranslatorInnerData.usCurrentTranslatorApduCounter  ; 
	    	         	      nat.TranslatorInnerData.usCurrentTranslatorApduCounter++; 
	    	         	      if (nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usCurrentTranslatorApduCounter][OFFSET_INS]==0){ 
	     	                     DirectTransfer_SimToNet();
	     	                   // SFI READ
               	     	      if (
               	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_READ_BINARY)||\
               	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_READ_RECORD)
               	     	      	)
               	     	      	{
               	     	        if (nat.ucCurrentReadMode==READMODE_SFI){
               	     	        	    if (GenExpectedFidWithSfi_Usim()>0)
     		   	  	      	                    std::cout<<GREEN<<"Bank Side Get right SFI "<<RESET<<std::endl<<std::flush;  
               	     	      	 		  nat.ucCurrentReadMode=READMODE_COMMON;
               	     	      	 	  if (nat.usDataBufLengthFromSimcard>=2)
               	     	      	 	  	//读到数据,说明选择文件操作正常
               	     	      	 	     if (
               	     	      	 	     	((nat.ucDataBufFromSimcard[nat.usDataBufLengthFromSimcard-2]==SW1_90)&&(nat.ucDataBufFromSimcard[nat.usDataBufLengthFromSimcard-1]==SW2_00))\
               	     	     		           ||(nat.ucDataBufFromSimcard[nat.usDataBufLengthFromSimcard-2]==SW1_91)
               						        		)
               
               	     	      	       {	     	      	   
               	     	      	          nat.ucCurrentCardIdentifierLength=nat.ucExpectIdentifierLength;
               	     	      	          for (unsigned char i=0;i<nat.ucCurrentCardIdentifierLength;i++)
               	     	      	               nat.ucCurrentCardIdentifier[i]=nat.ucExpectIdentifier[i];
               	     	      	       }
               	     	      	    std::cout<<GREEN<<std::hex <<"SFI: ";   	
               	     	      	 }
               	     	      	 std::cout<<GREEN<<std::hex <<"READ Bank Current Sim Identifier: Ch"<<(unsigned short)nat.ucCurrentProcessLch<<"  ";
               	     	         for (unsigned char i=0;i<nat.ucCurrentCardIdentifierLength;i++)	 
               	     	            std::cout<<GREEN<<std::hex<<(unsigned short)nat.ucCurrentCardIdentifier[i]<<" ";
               	     	         std::cout<<" "<<std::endl ;  
	     	                    }      

	     	                }     
	     	                else      
	    	         	          TranslatorToSim(EXPECT_DELIVER_TO_SIM_APDU_COMMAND);
	    	         }	      
	    	         
	    	    }
	    	    else{
	    	    	    if (nat.TranslatorInnerData.ucExpectDeliverToSim==EXPECT_DELIVER_TO_SIM_APDU_AERUMENT){
	    	    	    	  
	    	    	    	   //如果后面没有指令了
	    	    	          if (nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usCurrentTranslatorApduCounter][OFFSET_INS]==0){ 
	     	                     DirectTransfer_SimToNet();	     	                     
	     	                }     
	     	                else{     //如果后面还有指令	     	                	     
	    	         	          TranslatorToSim(EXPECT_DELIVER_TO_SIM_APDU_COMMAND); 
	    	         	          nat.TranslatorInnerData.ucExpectDeliverToSim=EXPECT_DELIVER_TO_SIM_APDU_COMMAND;	       	          
	    	         	      }
	    	         	   /*   
	    	         	      if ( 
	    	         	      	(nat.TranslatorInnerData.ucTranslatorApduArgument[nat.TranslatorInnerData.usLastTranslatorApduCounter][1]==0x20)&&\
	    	         	      	(nat.TranslatorInnerData.ucTranslatorApduArgument[nat.TranslatorInnerData.usLastTranslatorApduCounter][2]==0x6f)&&\
	    	         	      	(nat.TranslatorInnerData.ucTranslatorApduArgument[nat.TranslatorInnerData.usLastTranslatorApduCounter][3]==0x11)
	    	         	      	)
	    	         	      	int erl=0;
	    	         	      	*/
	    	         	      if (nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_SELECT)
	     	      	           if ((nat.usDataBufLengthFromSimcard==2)&&(nat.ucDataBufFromSimcard[0]==SW1_61)){
	     	      	    	       nat.ucCurrentCardIdentifierLength=nat.TranslatorInnerData.ucTranslatorApduArgumentLength[nat.TranslatorInnerData.usLastTranslatorApduCounter];
	     	      	             for (unsigned char i=0;i<nat.ucCurrentCardIdentifierLength;i++)
	     	      	                nat.ucCurrentCardIdentifier[i]=nat.TranslatorInnerData.ucTranslatorApduArgument[nat.TranslatorInnerData.usLastTranslatorApduCounter][i];
	     	      	             nat.ucSelectFileStatus=SELECTFILESTATUS_SUCCESS;
	     	      	           }
	     	      	          
	    	         	       
	     	      	            
	    	         	     std::cout<<GREEN<<std::hex <<"Bank Current Sim Idntifier: Ch"<<(unsigned short)nat.ucCurrentProcessLch<<"  ";
	     	               for (unsigned char i=0;i<nat.ucCurrentCardIdentifierLength;i++)	 
	     	                     std::cout<<GREEN<<std::hex<<(unsigned short)nat.ucCurrentCardIdentifier[i]<<" ";
	     	               std::cout<<" "<<std::endl ;   
	    	    	    }
	    	    	    else	
	    	    	    	  return -1;
	    	    }
	    	    
	     } 
	return 1;         
	}
	
int  NetApiToSimTranslator::ProcessSimResponse_Usim_LchNot0(){
unsigned char  tmpnumber;
    
	     if (nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usCurrentTranslatorApduCounter][OFFSET_INS]==0) {  //已经向卡传完数据
	     	      DirectTransfer_SimToNet();
	     	      if (nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_SELECT){     	      	  
	     	      	   if (  (nat.usDataBufLengthFromSimcard==2)&& \
	     	      	   	     (
	     	      	   	       (nat.ucDataBufFromSimcard[0]==SW1_61)|| ((nat.ucDataBufFromSimcard[0]==SW1_90)&&(nat.ucDataBufFromSimcard[1]==0))||\
	     	      	   	       ((nat.ucDataBufFromSimcard[0]==SW1_91)&&(nat.ucDataBufFromSimcard[1]!=0)) 
	     	      	   	       // Select NoDataReturn时 repsonse  90 0 or 91 xx
	     	      	   	      )
	     	      	   	   )	{     	      
	     	      	           nat.ucSelectFileStatus=SELECTFILESTATUS_SUCCESS;	 
	     	      	        //检查是否为合法AID
     	     		 	     if  (nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][APDU_CMD_OFFSET_P3]==0x10) {  //按AID 选择
     	     		 	         for (tmpnumber=0;tmpnumber<sizeof(vc_ridset)/sizeof(rid_inform_t);tmpnumber++){
                 	            if ((!char_arrayncmp ( nat.TranslatorInnerData.ucTranslatorApduArgument[nat.TranslatorInnerData.usLastTranslatorApduCounter], &(vc_ridset[tmpnumber].rid[0]), 5 )))
                 	  	           break;
                 	       }
                 	       if (tmpnumber<sizeof(vc_ridset)/sizeof(rid_inform_t))  { //是合法的AID                 	                       	     		  	                   
      	     		  	 	                      nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_RidType=vc_ridset[tmpnumber].ridtype;
      	     		  	 	                      nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_Type=nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_RidType;
      	     		  	 	                      nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_IdentifierLength=2;
      	     		  	 	                      nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_Identifier[0]=0x7F;
	     	      	   		                      nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_Identifier[1]=0xFF;
      	     		  	                  
                 	        }               	   
	     	      	     }
	     	      	     else{   //不是按 AID 选择
	 
	     	      	     	            	     if (
	     	      	     	               	     (nat.TranslatorInnerData.ucTranslatorApduArgument[nat.TranslatorInnerData.usLastTranslatorApduCounter][0]==0x7f)&&\
	     	      	     	               	     (nat.TranslatorInnerData.ucTranslatorApduArgument[nat.TranslatorInnerData.usLastTranslatorApduCounter][1]==0xff)      
	     	      	     	               	   )	     	      	     	               	   	  
      	     		  	  	                    nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_RidType=nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_Type;      	     		  	  	                   	     	      	     	               	   	
	     	      	     	                   else
	     	      	     	               	      nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_RidType=RIDTYPE_NONEEDAID;
	     	      	     	               	     
	     	      	     	                  nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_IdentifierLength=nat.TranslatorInnerData.ucTranslatorApduArgumentLength[nat.TranslatorInnerData.usLastTranslatorApduCounter];
	     	      	                        for (unsigned char i=0;i<nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_IdentifierLength;i++)
	     	      	                            nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_Identifier[i]=nat.TranslatorInnerData.ucTranslatorApduArgument[nat.TranslatorInnerData.usLastTranslatorApduCounter][i];	     	      	     	       	     	      	     	            
     	      	     	   }
                     }
                     else
                     	 nat.ucSelectFileStatus=SELECTFILESTATUS_FAIL;	 
	     	      }
	     	       else{
	     	       // SFI UPDATE
                  if (
                  	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UPDATE_BINARY)||\
                  	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UPDATE_RECORD)
                  	 )
                  	{
               	     	        if (nat.ucCurrentUpdateMode==UPDATEMODE_SFI){
               	     	        	    if (GenExpectedFidWithSfi_Usim()>0)
     		   	  	      	                    std::cout<<GREEN<<"Bank Side Get right SFI "<<RESET<<std::endl<<std::flush; 
               	     	      	 		  nat.ucCurrentUpdateMode=UPDATEMODE_COMMON;
               	     	      	 	  if (nat.usDataBufLengthFromSimcard>=2)
               	     	      	 	  	//读到数据,说明选择文件操作正常
               	     	      	 	     if (
               	     	      	 	     	((nat.ucDataBufFromSimcard[nat.usDataBufLengthFromSimcard-2]==SW1_90)&&(nat.ucDataBufFromSimcard[nat.usDataBufLengthFromSimcard-1]==SW2_00))\
               	     	     		           ||(nat.ucDataBufFromSimcard[nat.usDataBufLengthFromSimcard-2]==SW1_91)
               						        		)
               
               	     	      	       {	     	      	   
               	     	      	          nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_IdentifierLength=nat.Lcm[nat.ucCurrentProcessLch].ucExpectLch_IdentifierLength;
               	     	      	          for (unsigned char i=0;i<nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_IdentifierLength;i++)
               	     	      	              nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_Identifier[i]=nat.Lcm[nat.ucCurrentProcessLch].ucExpectLch_Identifier[i];
               	     	      	       }	
               	     	      	 }
               	     	      	 std::cout<<GREEN<<std::hex <<"SFI Update ";
               	     	    
	     	          }
	     	          else {  //Run Auth
	     	          	if (
	     	          		(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_RUN_GSM_ALGORITHM)||\
	     	          		(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UIM_STORE_ESN_ME)||\ 
	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UIM_GENERATE_KEY_VPM)||\  
	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UIM_BASE_STATION_CHALLENGE)||\
	     	      	 
	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_GET_CHALLENGE)||\
	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UIM_CONFIRM_SSD)||\
	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UIM_GENERATE_PUBLIC_KEY)||\  
	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UIM_KEY_GENERATION_REQUEST)||\
	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UIM_CONFIGURATION_REQUEST)||\  
	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UIM_KEY_DOWNLOAD_REQUEST)||\
	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UIM_OTAPA_REQUEST)||\
	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UIM_SSPR_CONFIGURATION_REQUEST)||\
	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UIM_SSPR_DOWNLOAD_REQUEST)||\  
	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_UIM_VALID)
	     	      	
	     	      	)

                  	     if (nat.ucTsStatus==TS_STATUS_GEN_GETSTATUS_FOR_RUNAUTH)
                  	     	if ((nat.usDataBufLengthFromSimcard==2)&&(nat.ucDataBufFromSimcard[0]==SW1_61)){
                  	     		 nat.ResLength=nat.ucDataBufFromSimcard[1];
                  	     	   nat.ucTsStatus=TS_STATUS_GEN_GETSTATUS_RESPONSELENGTH_ENBALE;
                  	     	}     	          	 
	     	          	} 
	     	      } 

	     	     std::cout<<GREEN<<std::hex <<"Bank Current Sim Idntifier: Ch"<<(unsigned short)nat.ucCurrentProcessLch<<"  ";	     	    
	     	     for (unsigned char i=0;i<nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_IdentifierLength;i++)	 
	     	            std::cout<<GREEN<<std::hex<<(unsigned short)nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_Identifier[i]<<" ";  	
	     	     std::cout<<" "<<std::endl ;        
	     }	      
	     else	{      
	          if (nat.TranslatorInnerData.ucExpectDeliverToSim==EXPECT_DELIVER_TO_SIM_APDU_COMMAND){
	    	        //TODO  CheckSimResponse(); 
	    	         if ( nat.TranslatorInnerData.ucTranslatorApduArgumentLength[nat.TranslatorInnerData.usCurrentTranslatorApduCounter]!=0){
	    	         	      TranslatorToSim(EXPECT_DELIVER_TO_SIM_APDU_AERUMENT);
	    	         	      nat.TranslatorInnerData.ucExpectDeliverToSim=EXPECT_DELIVER_TO_SIM_APDU_AERUMENT; 
	    	         	      nat.TranslatorInnerData.usLastTranslatorApduCounter=nat.TranslatorInnerData.usCurrentTranslatorApduCounter  ;  
	    	         	      nat.TranslatorInnerData.usCurrentTranslatorApduCounter++;   	         	     
	    	         } 
	    	         else  {
	    	         	      nat.TranslatorInnerData.usLastTranslatorApduCounter=nat.TranslatorInnerData.usCurrentTranslatorApduCounter  ; 
	    	         	      nat.TranslatorInnerData.usCurrentTranslatorApduCounter++; 
	    	         	      if (nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usCurrentTranslatorApduCounter][OFFSET_INS]==0){ 
	     	                     DirectTransfer_SimToNet();
	     	                   // SFI READ
               	     	      if (
               	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_READ_BINARY)||\
               	     	      	(nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_READ_RECORD)
               	     	        )
               	     	      	{
               	     	        if (nat.ucCurrentReadMode==READMODE_SFI){
               	     	        	    if (GenExpectedFidWithSfi_Usim()>0)
     		   	  	      	                    std::cout<<GREEN<<"Bank Side Get right SFI "<<RESET<<std::endl<<std::flush; 
               	     	      	 		  nat.ucCurrentReadMode=READMODE_COMMON;
               	     	      	 	  if (nat.usDataBufLengthFromSimcard>=2)
               	     	      	 	  	//读到数据,说明选择文件操作正常
               	     	      	 	     if (
               	     	      	 	     	((nat.ucDataBufFromSimcard[nat.usDataBufLengthFromSimcard-2]==SW1_90)&&(nat.ucDataBufFromSimcard[nat.usDataBufLengthFromSimcard-1]==SW2_00))\
               	     	     		           ||(nat.ucDataBufFromSimcard[nat.usDataBufLengthFromSimcard-2]==SW1_91)
               						        		)
               
               	     	      	       {	     	      	   
               	     	      	          /*nat.ucCurrentCardIdentifierLength=nat.ucExpectIdentifierLength;
               	     	      	          for (unsigned char i=0;i<nat.ucCurrentCardIdentifierLength;i++)
               	     	      	               nat.ucCurrentCardIdentifier[i]=nat.ucExpectIdentifier[i];
               	     	      	               */
               	     	      	          nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_IdentifierLength=nat.Lcm[nat.ucCurrentProcessLch].ucExpectLch_IdentifierLength;
               	     	      	          for (unsigned char i=0;i<nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_IdentifierLength;i++)
               	     	      	              nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_Identifier[i]=nat.Lcm[nat.ucCurrentProcessLch].ucExpectLch_Identifier[i];
               	     	      	       }
               	     	      	        std::cout<<GREEN<<std::hex <<"SFI:  "; 	
               	     	      	 }
               	     	      	 std::cout<<GREEN<<std::hex <<"Bank Current Sim Idntifier: CH"<<(unsigned short)nat.ucCurrentProcessLch<<" " ;
               	     	         for (unsigned char i=0;i< nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_IdentifierLength;i++)	 
               	     	            std::cout<<GREEN<<std::hex<<(unsigned short) nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_Identifier[i]<<" ";
               	     	         std::cout<<" "<<std::endl ;  
	     	                    }      

	     	                }     
	     	                else      
	    	         	          TranslatorToSim(EXPECT_DELIVER_TO_SIM_APDU_COMMAND);
	    	         }	      
	    	         
	    	    }
	    	    else{
	    	    	    if (nat.TranslatorInnerData.ucExpectDeliverToSim==EXPECT_DELIVER_TO_SIM_APDU_AERUMENT){
	    	    	          if (nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usCurrentTranslatorApduCounter][OFFSET_INS]==0){ 
	     	                     DirectTransfer_SimToNet();	     	                     
	     	                }     
	     	                else{      
	    	         	          TranslatorToSim(EXPECT_DELIVER_TO_SIM_APDU_COMMAND); 
	    	         	          nat.TranslatorInnerData.ucExpectDeliverToSim=EXPECT_DELIVER_TO_SIM_APDU_COMMAND;	       	          
	    	         	      }
	    	         	      if (nat.TranslatorInnerData.ucTranslatorApduCommand[nat.TranslatorInnerData.usLastTranslatorApduCounter][OFFSET_INS]==APDU_COMMAND_SELECT)
	     	      	           if ((nat.usDataBufLengthFromSimcard==2)&&(nat.ucDataBufFromSimcard[0]==SW1_61)){
	     	      	    	     //  nat.ucCurrentCardIdentifierLength=nat.TranslatorInnerData.ucTranslatorApduArgumentLength[nat.TranslatorInnerData.usLastTranslatorApduCounter];
	     	      	              nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_IdentifierLength=nat.TranslatorInnerData.ucTranslatorApduArgumentLength[nat.TranslatorInnerData.usLastTranslatorApduCounter];
	     	      	          
	     	      	              for (unsigned char i=0;i<nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_IdentifierLength;i++)
	     	      	                nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_Identifier[i]=nat.TranslatorInnerData.ucTranslatorApduArgument[nat.TranslatorInnerData.usLastTranslatorApduCounter][i];
	     	      	              nat.ucSelectFileStatus=SELECTFILESTATUS_SUCCESS;
	     	      	           }  
	     	      	           else
	     	      	           	 nat.ucSelectFileStatus=SELECTFILESTATUS_FAIL; 
	    	         	     std::cout<<GREEN<<std::hex <<"Bank Current Sim Idntifier:Ch"<<(unsigned short)nat.ucCurrentProcessLch<<" "  ;
	     	               for (unsigned char i=0;i<nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_IdentifierLength;i++)	 
	     	                     std::cout<<GREEN<<std::hex<<(unsigned short)nat.Lcm[nat.ucCurrentProcessLch].ucCurrentLch_Identifier[i]<<" ";
	     	               std::cout<<" "<<std::endl ;   
	    	    	    }
	    	    	    else	
	    	    	    	  return -1;
	    	    }
	    	    
	     } 
	return 1;         		
}	
int  NetApiToSimTranslator::ProcessSimResponse_Usim(){	
        if (!nat.ucCurrentProcessLch)
           return (ProcessSimResponse_Usim_Lch0());
        else
        	 return (ProcessSimResponse_Usim_LchNot0());
             
}

void  NetApiToSimTranslator::UpdatePath(unsigned char identifier[2] ){
	  
	   if (identifier[0]==FILE_1ST_ID_MF){
     	      nat.CurrentIdWithPath.mfid[0]=identifier[0]	;
 	   				nat.CurrentIdWithPath.mfid[1]=identifier[1]	;
					memset(nat.CurrentIdWithPath.firstlevelid,0,sizeof(nat.CurrentIdWithPath.firstlevelid));
					memset(nat.CurrentIdWithPath.secondlevelid,0,sizeof(nat.CurrentIdWithPath.secondlevelid));
					memset(nat.CurrentIdWithPath.thirdlevelid,0,sizeof(nat.CurrentIdWithPath.thirdlevelid));		
     	}
     else
	   if ((identifier[0]==FILE_1ST_ID_UNDER_MF_EF)||(identifier[0]==FILE_1ST_ID_1LEVEL_DF)){
 	   				nat.CurrentIdWithPath.firstlevelid[0]=identifier[0]	;
 	   				nat.CurrentIdWithPath.firstlevelid[1]=identifier[1]	;
					memset(nat.CurrentIdWithPath.secondlevelid,0,sizeof(nat.CurrentIdWithPath.secondlevelid));
					memset(nat.CurrentIdWithPath.thirdlevelid,0,sizeof(nat.CurrentIdWithPath.thirdlevelid));		
 	    }
     else
     if ((identifier[0]==FILE_1ST_ID_UNDER_1LEVEL_DF_EF)||(identifier[0]==FILE_1ST_ID_2LEVEL_DF)){
     	      nat.CurrentIdWithPath.secondlevelid[0]=identifier[0]	;
 	   				nat.CurrentIdWithPath.secondlevelid[1]=identifier[1]	;
					memset(nat.CurrentIdWithPath.thirdlevelid,0,sizeof(nat.CurrentIdWithPath.thirdlevelid));		
 	   				
     	} 
     else	
     if (identifier[0]==FILE_1ST_ID_UNDER_2LEVEL_DF_EF){
     	      nat.CurrentIdWithPath.thirdlevelid[0]=identifier[0]	;
 	   				nat.CurrentIdWithPath.thirdlevelid[1]=identifier[1]	;
     	}
     else{
     	     
     	     std::cout<<RED<<"UNRECONIZED IDENTIFIER"<<RESET<<std::endl<<std::flush;	
     	} 
	}	

void  NetApiToSimTranslator::UpdatePathLch(unsigned char identifier[2] ,unsigned char Lch){
	  
	   if (identifier[0]==FILE_1ST_ID_MF){
     	      nat.Lcm[Lch].CurrentLchIdWithPath.mfid[0]=identifier[0]	;
 	   				nat.Lcm[Lch].CurrentLchIdWithPath.mfid[1]=identifier[1]	;
					memset(nat.Lcm[Lch].CurrentLchIdWithPath.firstlevelid,0,sizeof(nat.Lcm[Lch].CurrentLchIdWithPath.firstlevelid));
					memset(nat.Lcm[Lch].CurrentLchIdWithPath.secondlevelid,0,sizeof(nat.Lcm[Lch].CurrentLchIdWithPath.secondlevelid));
					memset(nat.Lcm[Lch].CurrentLchIdWithPath.thirdlevelid,0,sizeof(nat.Lcm[Lch].CurrentLchIdWithPath.thirdlevelid));
     	}
     else
	   if ((identifier[0]==FILE_1ST_ID_UNDER_MF_EF)||(identifier[0]==FILE_1ST_ID_1LEVEL_DF)){
 	   				nat.Lcm[Lch].CurrentLchIdWithPath.firstlevelid[0]=identifier[0]	;
 	   				nat.Lcm[Lch].CurrentLchIdWithPath.firstlevelid[1]=identifier[1]	;
					memset(nat.Lcm[Lch].CurrentLchIdWithPath.secondlevelid,0,sizeof(nat.Lcm[Lch].CurrentLchIdWithPath.secondlevelid));
					memset(nat.Lcm[Lch].CurrentLchIdWithPath.thirdlevelid,0,sizeof(nat.Lcm[Lch].CurrentLchIdWithPath.thirdlevelid));
 	    }
     else
     if ((identifier[0]==FILE_1ST_ID_UNDER_1LEVEL_DF_EF)||(identifier[0]==FILE_1ST_ID_2LEVEL_DF)){
     	      nat.Lcm[Lch].CurrentLchIdWithPath.secondlevelid[0]=identifier[0]	;
 	   				nat.Lcm[Lch].CurrentLchIdWithPath.secondlevelid[1]=identifier[1]	;
					memset(nat.Lcm[Lch].CurrentLchIdWithPath.thirdlevelid,0,sizeof(nat.Lcm[Lch].CurrentLchIdWithPath.thirdlevelid));
 	   				
     	} 
     else	
     if (identifier[0]==FILE_1ST_ID_UNDER_2LEVEL_DF_EF){
     	      nat.Lcm[Lch].CurrentLchIdWithPath.thirdlevelid[0]=identifier[0]	;
 	   				nat.Lcm[Lch].CurrentLchIdWithPath.thirdlevelid[1]=identifier[1]	;
     	}
     else{
     	     
     	     std::cout<<RED<<"UNRECONIZED IDENTIFIER"<<RESET<<std::endl<<std::flush;	
     	} 
	}	

/**************************************************************************** 
* 函数名称 : ProcessTranslator
* 类       ：NetApiToSimTranslator
* 功能描述 : 处理进入nat中的数据，产生新的状态和数据，外部操作者据此操作
* 参    数 : 
* 参    数 : 
* 参    数 : 
* 返 回 值 :   成功 返回 1   不成功  返回 -1
* 作    者 : 王翔
* 设计日期 : 
* 修改日期		  修改人		   修改内容  
 *****************************************************************************/		 	
int  NetApiToSimTranslator::ProcessTranslator( ){
unsigned long tmpTimeCounter;
	
  if (nat.ucTranslatorStatus==TRANSLATOR_WAITING_EMU_DELIVER_RST_ICC){
   	      switch(nat.ucTranslatorInteractiveStatus){
    	  	   case TRANSLATOR_INTERACTIVE_STATUS_DATA_FROM_NET_IS_READY:
    	  	        if (nat.ucDataPropertyFromNet==DATA_PROPERTY_IS_REQ_RST_ICC){
    	  	        	   nat.ucWaitGetInteractiveStartTime=GetTickCount();	 
    	  	        	   nat.ulApduCommandCounter=0;
    	  	        	   DirectTransfer_NetToSim();		    	  	        	      	  	        	  
    	  	        }	
    	  	        break;
    	  	  case TRANSLATOR_INTERACTIVE_STATUS_ICC_RST_IS_OK:
    	  	  	   tmpTimeCounter=GetTickCount();
 					     if (tmpTimeCounter<nat.ucWaitGetInteractiveStartTime)
 					             tmpTimeCounter+=0xFFFFFFFF-nat.ucWaitGetInteractiveStartTime;
 					     else
 					             tmpTimeCounter=tmpTimeCounter-nat.ucWaitGetInteractiveStartTime;
 					     if(tmpTimeCounter>EMUIATIMEOUT){
 					             std::cout<<RED<<"Warning! ICC_RST Timeout"<<RESET<<std::endl<<std::flush;	
 					             nat.ucTranslatorInteractiveStatus= TRANSLATOR_INTERACTIVE_STATUS_ERROR;
 					             return -1;
 					     }
 					     else{
 					             nat.ucTranslatorInteractiveStatus= TRANSLATOR_INTERACTIVE_STATUS_IDLE; 
 					             nat.ucTranslatorStatus=TRANSLATOR_WORKING;
 					             SetCurrentCardStatusInTranslator(CARDMODE_UNKOWN);	//如果已经复位ICC
 					             TranslatorInitInnerData();
 					             
 					             nat.ucCurrentCardIdentifier[0]=0x3F;
 					             nat.ucCurrentCardIdentifier[1]=0x0; 	 					             
 					             nat.ucCurrentCardIdentifierLength=2;		
 					             UpdatePath(nat.ucCurrentCardIdentifier);		
 					              
 					             for (unsigned char tmpi=0; tmpi<MAX_LOGICAL_CHANNELS_NUMBER;tmpi++){
 					             	  nat.Lcm[tmpi].ucCurrentLch_Identifier[0]=0x3F;
 					             	  nat.Lcm[tmpi].ucCurrentLch_Identifier[1]=0x0;
 					             	  nat.Lcm[tmpi].ucCurrentLch_IdentifierLength=2;
 					             	  UpdatePathLch(nat.Lcm[tmpi].ucCurrentLch_Identifier,tmpi);
 					             	}
 					             //TODO UPdateLcPath	
 					                    						                                              						             
 					     }
 					     break;	
    	  	  	
    	  	  default:
         	    
         	     break;
            	             	     	  	        	     	  	        	 	     	  	        	              	  	
	     	  }	     	     
  } 
  else{	     	      
    	   if (nat.ucTranslatorStatus==TRANSLATOR_WORKING){
    	       switch(nat.ucTranslatorInteractiveStatus){
		             case TRANSLATOR_INTERACTIVE_STATUS_DATA_FROM_NET_IS_READY:		             	    
		              	  nat.ucWaitGetInteractiveStartTime=GetTickCount();	
		                  if ((nat.ucDataPropertyFromNet==DATA_PROPERTY_IS_REQ_RST_ICC)||(nat.ucDataPropertyFromNet==DATA_PROPERTY_IS_DATA)){ 
		               ///   	 std::cout<< "------------------------------DATA_PROPERTY_IS_REQ_RST_ICC)||(nat.ucDataPropertyFromNet==DATA_PROPERTY_IS_DATA--------------------"<<std::endl;   	  	        	   
    	  	        	       nat.ulApduCommandCounter=0;
    	  	        	       if (nat.ucCurrentCardStatus==CARDMODE_UNKOWN)  //通过数据判断卡模式
    	  	        	       	  if (nat.ucDataPropertyFromNet==DATA_PROPERTY_IS_DATA){
    	  	        	       	  	  if (nat.ucDataBufFromNet[0]==0xa0){
    	  	        	       	  	    	  if (nat.ucRealCardType&CARDMODE_UIM)
    	  	        	       	  	    	  	  nat.ucCurrentCardStatus=CARDMODE_UIM;
    	  	        	       	  	    	  else{
    	  	        	       	  	    	  	      if (nat.ucRealCardType&CARDMODE_SIM)
    	  	        	       	  	    	  	        nat.ucCurrentCardStatus=CARDMODE_SIM;
    	  	        	       	  	    	  	
    	  	        	       	  	    	  	}  	    	  	        	       	  	    
    	  	        	       	  	  	   }   	  	        	       	  	  	    	  	        	       	  	  	
    	  	        	       	  	  	// nat.ucCurrentCardStatus=CARDMODE_SIM;
    	  	        	       	  	  if ((nat.ucDataBufFromNet[0]==0x0)||(nat.ucDataBufFromNet[0]==0x80))
    	  	        	       	  	  	 nat.ucCurrentCardStatus=CARDMODE_USIM_SESSIONDISACTIVE;
    	  	        	       	  }
    	  	        	       	  	  
    	  	        	       DirectTransfer_NetToSim();		    	  	        	      	  	        	  
    	  	            }	
    	  	            else {
    	  	            	      if (nat.ucDataPropertyFromNet==DATA_PROPERTY_IS_NETAPI_COMMAND){
    	  	            	    	  //TODO
    	  	            	    	//  std::cout<< "------------------------------DDATA_PROPERTY_IS_NETAPI_COMMAND-------------------"<<std::endl; 
    	  	            	    	   if (nat.ucCurrentCardStatus==CARDMODE_UNKOWN){  //通过数据判断卡模式
    	  	        	       	  	    if (nat.ucDataBufFromNet[0]==0xa0){
    	  	        	       	  	    	  if (nat.ucRealCardType&CARDMODE_UIM)
    	  	        	       	  	    	  	  nat.ucCurrentCardStatus=CARDMODE_UIM;
    	  	        	       	  	    	  else{
    	  	        	       	  	    	  	      if (nat.ucRealCardType&CARDMODE_SIM)
    	  	        	       	  	    	  	        nat.ucCurrentCardStatus=CARDMODE_SIM;
    	  	        	       	  	    	  	
    	  	        	       	  	    	  	}  	
    	  	        	       	  	    	
    	  	        	       	  	  	  //  nat.ucCurrentCardStatus=CARDMODE_SIM;
    	  	        	       	  	  	   } 
    	  	        	       	  	  	    
    	  	        	       	  	    if ( 
    	  	        	       	  	    	((nat.ucDataBufFromNet[0]==0x0)||(nat.ucDataBufFromNet[0]==0x80))||\
    	  	        	       	  	    	((nat.ucDataBufFromNet[0]&0x3)!=0)  //逻辑通道
    	  	        	       	  	    	)
    	  	        	       	  	    	  if (nat.ucRealCardType&CARDMODE_USIM)
    	  	        	       	  	  	       nat.ucCurrentCardStatus=CARDMODE_USIM_SESSIONDISACTIVE;
    	  	        	       	     }
    	  	        	             if (nat.ucCurrentCardStatus==CARDMODE_SIM){     
    	  	            	    	       TranslatorInitInnerData();    	  	            	    	  
    	  	            	    	       if(NetApiToApduGenFileOperationList()<0){
    	  	            	    	  	       std::cout<<RED<<"NetApiToApduGenFileOperationList Err"<<RESET<<std::endl<<std::flush;	
 					            			         nat.ucTranslatorInteractiveStatus= TRANSLATOR_INTERACTIVE_STATUS_ERROR;
 					            			         return -1;
    	  	            	    	       };
    	  	            	    	       TranslateNetApiToApdu(); 
    	  	            	    	       TranslatorToSim(EXPECT_DELIVER_TO_SIM_APDU_COMMAND);
    	  	            	    	       nat.TranslatorInnerData.ucExpectDeliverToSim=EXPECT_DELIVER_TO_SIM_APDU_COMMAND;
    	  	            	    	       nat.ucTranslatorInteractiveStatus= TRANSLATOR_INTERACTIVE_STATUS_DATA_TO_SIMCARD_IS_READY; 
    	  	            	         }
    	  	            	         if (nat.ucCurrentCardStatus==CARDMODE_UIM){     
    	  	            	    	       TranslatorInitInnerData();    	  	            	    	  
    	  	            	    	       if(NetApiToApduGenFileOperationList_Uim()<0){
    	  	            	    	  	       std::cout<<RED<<"NetApiToApduGenFileOperationListUim Err"<<RESET<<std::endl<<std::flush;	
 					            			         nat.ucTranslatorInteractiveStatus= TRANSLATOR_INTERACTIVE_STATUS_ERROR;
 					            			         return -1;
    	  	            	    	       };
    	  	            	    	      // TranslateNetApiToApdu(); 
    	  	            	    	       TranslateNetApiToApdu_Uim();
    	  	            	    	       TranslatorToSim(EXPECT_DELIVER_TO_SIM_APDU_COMMAND);
    	  	            	    	       nat.TranslatorInnerData.ucExpectDeliverToSim=EXPECT_DELIVER_TO_SIM_APDU_COMMAND;
    	  	            	    	       nat.ucTranslatorInteractiveStatus= TRANSLATOR_INTERACTIVE_STATUS_DATA_TO_SIMCARD_IS_READY; 
    	  	            	         }
    	  	            	         
    	  	            	         if ((nat.ucCurrentCardStatus==CARDMODE_USIM_SESSIONDISACTIVE)||\
    	  	            	         	  (nat.ucCurrentCardStatus==CARDMODE_USIM_SESSIONACTIVE)){     
    	  	            	    	       TranslatorInitInnerData();    	  	            	    	  
    	  	            	    	     
    	  	            	    	       TranslateNetApiToApdu_Usim(); 
    	  	            	    	       TranslatorToSim(EXPECT_DELIVER_TO_SIM_APDU_COMMAND);
    	  	            	    	       nat.TranslatorInnerData.ucExpectDeliverToSim=EXPECT_DELIVER_TO_SIM_APDU_COMMAND;
    	  	            	    	       nat.ucTranslatorInteractiveStatus= TRANSLATOR_INTERACTIVE_STATUS_DATA_TO_SIMCARD_IS_READY; 
    	  	            	         }
    	  	            	   }     	  	            	
    	  	            }
	                    break;
	               case TRANSLATOR_INTERACTIVE_STATUS_ICC_RST_IS_OK:
    	  	  	        tmpTimeCounter=GetTickCount();
 					    				 if (tmpTimeCounter<nat.ucWaitGetInteractiveStartTime)
 					             		tmpTimeCounter+=0xFFFFFFFF-nat.ucWaitGetInteractiveStartTime;
 					    				 else
 					             		tmpTimeCounter=tmpTimeCounter-nat.ucWaitGetInteractiveStartTime;
 					    				 if(tmpTimeCounter>EMUIATIMEOUT){
 					            			 std::cout<<RED<<"Warning! ICC_RST Timeout"<<RESET<<std::endl<<std::flush;	
 					            			 nat.ucTranslatorInteractiveStatus= TRANSLATOR_INTERACTIVE_STATUS_ERROR;
 					            			 return -1;
 					    				 }
 					    				 else{
 					           				 nat.ucTranslatorInteractiveStatus= TRANSLATOR_INTERACTIVE_STATUS_IDLE; 
 					           				// nat.ucTranslatorStatus=TRANSLATOR_WORKING;
 					           				SetCurrentCardStatusInTranslator(CARDMODE_UNKOWN);	//如果已经复位ICC
 					          			   TranslatorInitInnerData();
 					            			 nat.ucCurrentCardIdentifier[0]=0x3F;
 					           				 nat.ucCurrentCardIdentifier[1]=0x0;
 					           				 nat.ucCurrentCardIdentifierLength=2;	  //
 					           				 UpdatePath(nat.ucCurrentCardIdentifier);		
 					           				 for (unsigned char tmpi=0; tmpi<MAX_LOGICAL_CHANNELS_NUMBER;tmpi++){
 					             	             nat.Lcm[tmpi].ucCurrentLch_Identifier[0]=0x3F;
 					             	             nat.Lcm[tmpi].ucCurrentLch_Identifier[1]=0x0;
 					             	             nat.Lcm[tmpi].ucCurrentLch_IdentifierLength=2; 
 					             	             UpdatePathLch(nat.Lcm[tmpi].ucCurrentLch_Identifier,tmpi);					             	 
 					             	     }					          						                                              						             
 					    				 }
 					     				break;
 					     	 case TRANSLATOR_INTERACTIVE_STATUS_DATA_FROM_SIMCARD_IS_READY:
 					     	 	       if (nat.ucDataPropertyFromNet==DATA_PROPERTY_IS_DATA){    	  	        	       	  	        	       
    	  	        	         DirectTransfer_SimToNet();		    	  	        	      	  	        	  
    	  	               }
    	  	               else	{
    	  	               	      if (nat.ucDataPropertyFromNet==DATA_PROPERTY_IS_NETAPI_COMMAND){
    	  	               	         // CheckSimResponse(); 
    	  	               	          if ((nat.ucCurrentCardStatus==CARDMODE_SIM)||(nat.ucCurrentCardStatus==CARDMODE_UIM))
    	  	               	             ProcessSimResponse();
    	  	               	          
    	  	               	          if ((nat.ucCurrentCardStatus==CARDMODE_USIM_SESSIONDISACTIVE)||\
    	  	            	         	  (nat.ucCurrentCardStatus==CARDMODE_USIM_SESSIONACTIVE))
    	  	            	         	       ProcessSimResponse_Usim();
    	  	               	          
    	  	               	      }
    	  	               }
 					     	 	
 					     	 			break;		    
	               default:         	    
         	            break;  
         	   }
         }
  }       	             
	     
} 		
		
 unsigned char NetApiToSimTranslator::GetTranslatorStatus(){
 	return nat.ucTranslatorStatus;
 	}
unsigned char  NetApiToSimTranslator::GetTranslatorInteractiveStatus(){
	return nat.ucTranslatorInteractiveStatus;
	}
int NetApiToSimTranslator::SetTranslatorInteractiveStatus(unsigned char ucTranslatorInteractiveStatus){
	   nat.ucTranslatorInteractiveStatus=ucTranslatorInteractiveStatus;
	   return 1;
	} 
unsigned char NetApiToSimTranslator::GetDataPropertyFromNet(){
	return nat.ucDataPropertyFromNet;
	}	
int NetApiToSimTranslator::CopyDataToDeliverSimBuf(unsigned char* simbuf, unsigned short* lengthptr){
	   memcpy(simbuf,nat.ucDataBufToSimcard, nat.usDataBufLengthToSimcard);
	   (*lengthptr)=nat.usDataBufLengthToSimcard;
	   return 1;
}
int NetApiToSimTranslator::CopyDataFromSimToTranslator(unsigned char* simbuf, unsigned short length){
	    memcpy(nat.ucDataBufFromSimcard,simbuf,length);
      nat.usDataBufLengthFromSimcard=length; 
      return 1;   
}

int NetApiToSimTranslator::CopyTranslatorDataToDeliverNetBuf(unsigned char* netbuf, unsigned short* lengthptr,unsigned char* DataPropertyToNet){
	   memcpy(netbuf,nat.ucDataBufToNet, nat.usDataBufLengthToNet);
	   (*lengthptr)=nat.usDataBufLengthToNet;
	   (*DataPropertyToNet)=nat.ucDataPropertyToNet;
	   return 1; 
}

int NetApiToSimTranslator::CopyDataFromNetToTranslator(unsigned char* netbuf, unsigned short length,unsigned char DataPropertyFromNet){	  
	  memcpy(nat.ucDataBufFromNet, netbuf,length); 
    nat.usDataBufLengthFromNet=length;
    nat.ucDataPropertyFromNet=DataPropertyFromNet;
	  return 1;   
	}
	
unsigned long NetApiToSimTranslator::GetTickCount()  
{  
    struct timespec ts;  
  
    clock_gettime(CLOCK_MONOTONIC, &ts);  
  
    return (ts.tv_sec * 1000 + ts.tv_nsec / 1000000);  
}	
              
/******************************* 
* For VcardGenerator Test End
*******************************/

/******************************************************************************************************* 
* For SimBank Side Additional API 
********************************************************************************************************/

/**************************************************************************** 
* 函数名称 : GetVcardFileProperty
* 功能描述 : 检查文件标识是否属于GSM11.11定义的文件
* 参    数 : identifier ：文件标识，
* 参    数 :  vcard_file_property：文件属性表指针
* 参    数 : 
* 返 回 值 : 属于 返回 1  不属于 返回 -1
* 作    者 : 王翔
* 设计日期 : 
* 修改日期		  修改人		   修改内容  
 *****************************************************************************/
int GetVcardFileProperty(unsigned char identifier[2],vcard_file_property_t *vcard_file_property) {
		int iListCounter;		
	  
		for (iListCounter=0;iListCounter<vcard_file_property_list_num;iListCounter++){
		  	if( (vcard_file_property_list[iListCounter].identifier[0]==identifier[0])&&(vcard_file_property_list[iListCounter].identifier[1]==identifier[1])){	  	   
		  	     (*vcard_file_property)=vcard_file_property_list[iListCounter];		  	  
		  	     break;
		  	}
		}
	  if (iListCounter==vcard_file_property_list_num){
			 return -1;
		}
	  return 1;
	} 

/**************************************************************************** 
* 函数名称 : CheckCurrentFileInVcard
* 功能描述 : 检查Vcard内1个文件段的合法性
* 参    数 : ucvcardbuf ：Vcard Buf 
* 参    数 :  currentoffset 文件偏置指针
* 参    数 : 
* 返 回 值 : 合法 返回 1  合法 返回 -1
* 作    者 : 王翔
* 设计日期 : 
* 修改日期		  修改人		   修改内容  
 *****************************************************************************/	
int CheckCurrentFileInVcard(unsigned char ucvcardbuf[] , unsigned long *currentoffset){
	 unsigned long vcardbuflength,offsetcurrentfile_length,offsetcurrentfile_identifier,offsetcurrentfile_access_status,
	offsetcurrentfile_header_length,offsetcurrentfile_header_response,offsetcurrentfile_header,offsetcurrentfile_body_length,
	offsetcurrentfile_body_response,offsetcurrentfile_body,offsetcurrentrecord_reponse,offsetcurrentrecord_length;
	vcard_file_property_t file1;
	unsigned char identifier[2];
	unsigned short currentfile_length,currentfile_header_length,currentfile_body_length,currentrecord_length;
	
	offsetcurrentfile_length=*currentoffset;
	currentfile_length=   ((unsigned short) ucvcardbuf[offsetcurrentfile_length]<<8)+(unsigned short) ucvcardbuf[offsetcurrentfile_length+1];
	if (currentfile_length<5)
		   return -1;	
	offsetcurrentfile_identifier=	offsetcurrentfile_length+2;	
	identifier[0]=ucvcardbuf[offsetcurrentfile_identifier];
	identifier[1]=ucvcardbuf[offsetcurrentfile_identifier+1];	   	       	   	    
  if (GetVcardFileProperty(identifier, &file1)<0) 
	   	 return -1;	
  offsetcurrentfile_access_status=	offsetcurrentfile_length+4;	
	if (!( (ucvcardbuf[offsetcurrentfile_access_status]==VCARD_FILE_ACCESS_ALLOW)||(ucvcardbuf[offsetcurrentfile_access_status]==VCARD_FILE_ACCESS_PROHIBIT)))     
	   	 return -1;	   
	if (currentfile_length==5){
		   *currentoffset+=5;
		   return 1;
		 }
	offsetcurrentfile_header_length=offsetcurrentfile_length+5;
	currentfile_header_length=ucvcardbuf[offsetcurrentfile_header_length];	   
	if ((file1.property&FILE_TYPE_MF)|(file1.property&FILE_TYPE_DF)){
		   if (currentfile_header_length<22)
		        return -1;		
	}	
	else{
		    if (file1.property&FILE_TYPE_EF)
		        if (currentfile_header_length!=15)
		            return -1;		
		}
		
	offsetcurrentfile_header_response	=offsetcurrentfile_length+6;   		   
	if (!(ucvcardbuf[offsetcurrentfile_header_response]==SW1_90)&&(ucvcardbuf[offsetcurrentfile_header_response+1]==SW2_00))
	     	return -1;	
	if ((file1.property&FILE_TYPE_MF)|(file1.property&FILE_TYPE_DF)){  
		      	if (currentfile_length!=currentfile_header_length+8)
		      		   return -1;	
		      	else{
		      		  *currentoffset+=currentfile_length;
		      		  return 1;
		      		}	   
		      		  
  }
  if ((file1.property&FILE_TYPE_EF)&&(file1.property&EF_STRUCTURE_TRANSPARENT)){
  	     offsetcurrentfile_body_length=offsetcurrentfile_length+currentfile_header_length+8;
  	     currentfile_body_length=((unsigned short) ucvcardbuf[offsetcurrentfile_body_length]<<8)+(unsigned short) ucvcardbuf[offsetcurrentfile_body_length+1];
  	     offsetcurrentfile_body_response=offsetcurrentfile_body_length+2;
  	     
  	     if (!(((ucvcardbuf[offsetcurrentfile_body_response]==SW1_90)&&(ucvcardbuf[offsetcurrentfile_body_response+1]==SW2_00))||
  	     	  ((ucvcardbuf[offsetcurrentfile_body_response]==SW1_91)&&(ucvcardbuf[offsetcurrentfile_body_response+1]!=SW2_00))))
  	     	   return -1;
  	     	   
  	     if (currentfile_length!=currentfile_header_length+8+currentfile_body_length+4)
		      		   return -1;	
		      	else{
		      		  *currentoffset+=currentfile_length;
		      		  return 1;
		      		}	  	        	    	     	
  }
  if ((file1.property&FILE_TYPE_EF)&&(file1.property&EF_STRUCTURE_LINEARFIXED||file1.property&EF_STRUCTURE_CYCLIC)){
  	   offsetcurrentrecord_reponse=offsetcurrentfile_header_response+currentfile_header_length+2;
  	   if (!(((ucvcardbuf[offsetcurrentrecord_reponse]==SW1_90)&&(ucvcardbuf[offsetcurrentrecord_reponse+1]==SW2_00))||
  	     	  ((ucvcardbuf[offsetcurrentrecord_reponse]==SW1_91)&&(ucvcardbuf[offsetcurrentrecord_reponse+1]!=SW2_00))))
  	     	   return -1;
  	     	   
  	   if (currentfile_length<currentfile_header_length+10)
		      		   return -1;	
		   if (currentfile_length==currentfile_header_length+10){
		      		  *currentoffset+=currentfile_length;
		      		  return 1;
		   }
		   if (currentfile_length>currentfile_header_length+10){
		   	        offsetcurrentrecord_length=offsetcurrentrecord_reponse+3;
		   	        currentrecord_length=ucvcardbuf[offsetcurrentrecord_length];
		   	        if ((currentfile_length-currentfile_header_length-10)%(currentrecord_length+2))
		   	        	   return -1;	
		   	        else	{   
		      		           *currentoffset+=currentfile_length;
		      		           return 1;
		      		  }       
		   }		 	    	     	   
  	}
  return 1;  	   
}	
/**************************************************************************** 
* 函数名称 : CheckVcardValidate
* 功能描述 : 检查Vcard的合法性
* 参    数 : ucvcardbuf ：Vcard Buf 
* 参    数 : 
* 参    数 : 
* 返 回 值 : 合法 返回 1  不合法 返回 -1
* 作    者 : 王翔
* 设计日期 : 
* 修改日期		  修改人		   修改内容  
 *****************************************************************************/	
int CheckVcardValidate(unsigned char ucvcardbuf[]){
	unsigned long currentoffset,vcardbuflength;

  vcardbuflength=((unsigned long)ucvcardbuf[0]<<16)+((unsigned long)ucvcardbuf[1]<<8)+(unsigned long)ucvcardbuf[2];
  
	if (vcardbuflength>3){	
		   currentoffset=3;
		   while ( currentoffset<vcardbuflength){	   	    
		   	    if ((CheckCurrentFileInVcard(ucvcardbuf ,&currentoffset))<0)
		   	         break;	   
		   }		   
		   if (currentoffset!=vcardbuflength)
		   		 return -1;   	     
	}
	else
		return -1;
 return 1;				
} 

/**************************************************************************** 
* 函数名称 : InitVcardIndexList
* 功能描述 : 初始化Vcard 索引表
* 参    数 : VcardIndexList ：索引表指针 
* 参    数 : ListVolume 索引表记录数
* 参    数 : 
* 返 回 值 : 成功 返回 1  不成功 返回 -1
* 作    者 : 王翔
* 设计日期 : 
* 修改日期		  修改人		   修改内容  
 *****************************************************************************/	
void InitVcardIndexList( vcard_sort_list_t *VcardIndexList ,unsigned short ListVolume){
	 memset(VcardIndexList, 0, sizeof(vcard_sort_list_t)*ListVolume);
} 

/**************************************************************************** 
* 函数名称 : GenVcardIndex
* 功能描述 : 产生Vcard 索引表 
* 参    数 : ucvcardbuf ：Vcard指针 
* 参    数 : maxbuflengh： Vcard Buf 最大长度
* 参    数 : VcardIndexList： ：索引表指针
* 参    数 : ListVolume 索引表记录数
* 返 回 值 : 成功 返回 1  不成功 返回 -1
* 作    者 : 王翔
* 设计日期 : 
* 修改日期		  修改人		   修改内容  
 *****************************************************************************/	
int GenVcardIndex(unsigned char ucvcardbuf[] , unsigned long maxbuflengh,vcard_sort_list_t *VcardIndexList  ,unsigned short ListVolume ){
	unsigned long offsetcurrentfile_length=3;
	unsigned char currentlistnum=0,currentrecordnum=0;
	vcard_file_property_t file1;
	unsigned char identifier[2];
	unsigned long vcardbuflength,offsetcurrentfile_identifier,offsetcurrentfile_access_status,
	offsetcurrentfile_header_length,offsetcurrentfile_header_response,offsetcurrentfile_header,offsetcurrentfile_body_length,
	offsetcurrentfile_body_response,offsetcurrentfile_body,offsetcurrentrecord_reponse,offsetcurrentrecord_length,offsetcurrentrecord;
	unsigned short currentfile_length,currentfile_header_length,currentfile_body_length,currentrecord_length;
	
	vcardbuflength=((unsigned long)ucvcardbuf[0]<<16)+((unsigned long)ucvcardbuf[1]<<8)+(unsigned long)ucvcardbuf[2];
	if (vcardbuflength<maxbuflengh){		
		   if (CheckVcardValidate(ucvcardbuf)==1){
		       InitVcardIndexList(VcardIndexList,ListVolume);
		       while (offsetcurrentfile_length<vcardbuflength){
		       	 currentfile_length=((unsigned short) ucvcardbuf[offsetcurrentfile_length]<<8)+(unsigned short) ucvcardbuf[offsetcurrentfile_length+1];
		       	 VcardIndexList[currentlistnum].ptr_identifier=&ucvcardbuf[offsetcurrentfile_length+2];
		       	 VcardIndexList[currentlistnum].ptr_access_flag=&ucvcardbuf[offsetcurrentfile_length+4];
		       	 if (currentfile_length==5){
		       	 	   offsetcurrentfile_length+=currentfile_length;
		       	 	   currentlistnum++;
		       	 }
		       	 else{
		       	 	    VcardIndexList[currentlistnum].ptr_fileheaderlength=&ucvcardbuf[offsetcurrentfile_length+5];
		       	      VcardIndexList[currentlistnum].ptr_fileheaderresponse=&ucvcardbuf[offsetcurrentfile_length+6];
		       	 	    VcardIndexList[currentlistnum].ptr_fileheader=&ucvcardbuf[offsetcurrentfile_length+8];
		       	 	    identifier[0]=ucvcardbuf[offsetcurrentfile_length+2];
	                identifier[1]=ucvcardbuf[offsetcurrentfile_length+2+1];	   	       	   	    
                  if (GetVcardFileProperty(identifier, &file1)<0) 
	   	                 return -1;	
		       	 	    if ((file1.property&FILE_TYPE_MF)|(file1.property&FILE_TYPE_DF)){  		      	
		      		         offsetcurrentfile_length+=currentfile_length;
		      		         currentlistnum++;		      		 
		      		    }
		      		    else{
		      		    	    offsetcurrentfile_header_length=offsetcurrentfile_length+5;
	                      currentfile_header_length=ucvcardbuf[offsetcurrentfile_header_length];	 
		      		    	    if ((file1.property&FILE_TYPE_EF)&&(file1.property&EF_STRUCTURE_TRANSPARENT)){
		      		    	    	    VcardIndexList[currentlistnum].ptr_filebodylength=&ucvcardbuf[offsetcurrentfile_length+currentfile_header_length+8];
		      		    	    	    VcardIndexList[currentlistnum].ptr_filebodyresponse=&ucvcardbuf[offsetcurrentfile_length+currentfile_header_length+8+2];
  	                          VcardIndexList[currentlistnum].ptr_filebody=&ucvcardbuf[offsetcurrentfile_length+currentfile_header_length+8+2+2];
     	                        offsetcurrentfile_length+=currentfile_length;
		      		                currentlistnum++;
  	      	        	  }
  	      	        	  else{
  	      	        	  	     if ((file1.property&FILE_TYPE_EF)&&(file1.property&EF_STRUCTURE_LINEARFIXED||file1.property&EF_STRUCTURE_CYCLIC)){
                                 
                                   VcardIndexList[currentlistnum].ptr_recordresponse=&ucvcardbuf[offsetcurrentfile_length+currentfile_header_length+8];
		      		    	    	         offsetcurrentrecord=offsetcurrentfile_length+currentfile_header_length+10;
		      		    	    	         while (offsetcurrentrecord<offsetcurrentfile_length+currentfile_length){
		      		    	    	         	     VcardIndexList[currentlistnum].ptr_recordbody[currentrecordnum].ptr_recordserialnumber=&ucvcardbuf[offsetcurrentrecord];
		      		    	    	               VcardIndexList[currentlistnum].ptr_recordbody[currentrecordnum].ptr_recordlength=&ucvcardbuf[offsetcurrentrecord+1];
		      		    	    	               VcardIndexList[currentlistnum].ptr_recordbody[currentrecordnum].ptr_recordcontext=&ucvcardbuf[offsetcurrentrecord+2];
		      		    	    	               currentrecord_length=ucvcardbuf[offsetcurrentrecord+1];
		      		    	    	         	     offsetcurrentrecord=offsetcurrentrecord+ currentrecord_length+2; 
		      		    	    	         	     currentrecordnum++;    		    	    	         	
		      		    	    	         	}	    	    	          
		      		    	    	         if (offsetcurrentrecord==offsetcurrentfile_length+currentfile_length){
		      		    	    	         	     offsetcurrentfile_length+=currentfile_length;
		      		                           currentlistnum++;
		      		                           currentrecordnum=0;
		      		    	    	         	}
		      		    	    	         else	
		      		    	    	         	    return -1;			     		    	    	            	     	   
  	                           }
  	                           else
  	                           	        return -1;
  	      	        	  }		      		    	
		      		    }		      		    		 
		       	 	}		       	 	
		       	}	    
		   }
		   else	 
		       return -1;
	}	
	else
			 return -1;
return 1;
}


//Vcard 索引表中是否存在该identifier
int GetIdentifierIndex(unsigned char identifier[2],vcard_sort_list_t *VcardIndexList){  
int filenum;
    	    for ( int filenum=0;filenum<MAX_VCARDINDEX;filenum++)
    	    	  if (VcardIndexList[filenum].ptr_identifier!=0){
    	    	  	 if ((*VcardIndexList[filenum].ptr_identifier==identifier[0])&&(*(VcardIndexList[filenum].ptr_identifier+1)==identifier[1])){
    	    	  	 	   if (*VcardIndexList[filenum].ptr_access_flag==VCARD_FILE_ACCESS_PROHIBIT)
    	    	   	         return -1;
    	    	   	     else    
    	    	  	 	       return filenum;    	    	  	 	 
    	    	  	 }	   
    	    	  }
    	     return -1;	    	    
    	       	    	      	    	   	   	        	    	    	    
}





/**************************************************************************** 
* 函数名称 : GetFileHeaderContext
* 功能描述 : 获取文件的文件头内容，长度为length， 置于fileheaderbuf
* 参    数 : vcardindexlistserialnumber ：索引表索引号 
* 参    数 : fileheaderbuf 文件头Buf指针
* 参    数 : length 内容长度
* 参    数 : 
* 返 回 值 : 成功 返回 1  不成功 返回 -1
* 作    者 : 王翔
* 设计日期 : 
* 修改日期		  修改人		   修改内容  
 *****************************************************************************/	
int GetFileHeaderContext(int vcardindexlistserialnumber, vcard_sort_list_t *VcardIndexList  ,unsigned char *fileheaderbuf, unsigned char length){ 
	     
	     if (!(vcardindexlistserialnumber>=0)&&(vcardindexlistserialnumber<MAX_VCARDINDEX))
	           return -1;
	     else{ 
	     	    if (VcardIndexList[vcardindexlistserialnumber].ptr_fileheaderlength!=0){
	     	    	  if (*VcardIndexList[vcardindexlistserialnumber].ptr_fileheaderlength>=length)
	     	    	  	      memcpy(fileheaderbuf,VcardIndexList[vcardindexlistserialnumber].ptr_fileheader ,length);	     	    	   
  	    	      else{
	     	    	  	  std::cout<<RED<<"GetFileHeaderContext Fail Length OverFlow"<<RESET<<std::endl<<std::flush;
	     	    	  	  return -1;
	     	    	  }	        	
	     	    	}
	     	    else
	     	    	return -1;   		     	         	
	     } 	
	     return 1;    	        	    	    	    
}



/**************************************************************************** 
* 函数名称 : GetFileBodyLength
* 功能描述 : 获取文件的文件体长度 
* 参    数 : vcardindexlistserialnumber ：索引表索引号 
* 参    数 : 
* 参    数 : 
* 参    数 : 
* 返 回 值 : 成功 返回 长度  不成功 返回 -1
* 作    者 : 王翔
* 设计日期 : 
* 修改日期		  修改人		   修改内容  
 *****************************************************************************/	
int GetFileBodyLength(int vcardindexlistserialnumber,vcard_sort_list_t *VcardIndexList  ){ 
	     
	     if (!(vcardindexlistserialnumber>=0)&&(vcardindexlistserialnumber<MAX_VCARDINDEX))
	           return -1;
	     else{ 
	     	    if (VcardIndexList[vcardindexlistserialnumber].ptr_filebodylength!=0){
	     	    	    return  ((unsigned short) (*VcardIndexList[vcardindexlistserialnumber].ptr_filebodylength)<<8)+
	     	    	            (unsigned short) (*(VcardIndexList[vcardindexlistserialnumber].ptr_filebodylength+1));	
	     	    	}
	     	    else
	     	    	return -1;   		     	         	
	     } 	   	        	    	    	    
}

/**************************************************************************** 
* 函数名称 : GetFileBodyContext
* 功能描述 : 获取文件的文件体内容，长度为length， 置于filebodybuf
* 参    数 : vcardindexlistserialnumber ：索引表索引号 
* 参    数 : filebodybuf 文件体Buf指针
* 参    数 : length 内容长度
* 参    数 : 
* 返 回 值 : 成功 返回 1  不成功 返回 -1
* 作    者 : 王翔
* 设计日期 : 
* 修改日期		  修改人		   修改内容  
 *****************************************************************************/	
int GetFileBodyContext(int vcardindexlistserialnumber,vcard_sort_list_t *VcardIndexList  , unsigned char *filebodybuf, unsigned char length){      
	     if (!(vcardindexlistserialnumber>=0)&&(vcardindexlistserialnumber<MAX_VCARDINDEX))
	           return -1;
	     else{ 
	     	    if (VcardIndexList[vcardindexlistserialnumber].ptr_filebodylength!=0){
	     	    	  if (((unsigned short)*(VcardIndexList[vcardindexlistserialnumber].ptr_filebodylength)<<8)+
	     	    	  	  (unsigned short) (*(VcardIndexList[vcardindexlistserialnumber].ptr_filebodylength+1))>=length)
	     	    	  	      memcpy(filebodybuf,VcardIndexList[vcardindexlistserialnumber].ptr_filebody ,length);	     	    	   
  	    	      else{
	     	    	  	  std::cout<<RED<<"GetFileBodyContext Fail Length OverFlow"<<RESET<<std::endl<<std::flush;
	     	    	  	  return -1;
	     	    	  }	        	
	     	    	}
	     	    else
	     	    	return -1;   		     	         	
	     } 	
	     return 1;    	        	    	    	    
}




/**************************************************************************** 
* 函数名称 : IsIdentifiableTransparentFile
* 功能描述 : 比较透明文件细节与Vcard中对应的同名文件细节是否相同，
* 参    数 : ucvcardbuf ：Vcard Buf ;maxbuflengh: buf最大长度
* 参    数 : identifier 文件名标识；FileHeaderLengthFromSim：从Simcard 返回的文件头长度； PtrFileHeaderFromSim：从Simcard 返回的文件头内容
* 参    数 : FileBodyLengthFromSim：  从Simcard 返回的文件体长度 PtrFileBodyFromSim 返回的文件体内容
* 参    数 : 
* 返 回 值 : 相同 返回 1  不成功 返回 -1
* 作    者 : 王翔
* 设计日期 : 
* 修改日期		  修改人		   修改内容  
 *****************************************************************************/	
int IsIdentifiableTransparentFile (unsigned char ucvcardbuf[] , unsigned long maxbuflengh,unsigned char identifier[2],\
                        unsigned char FileHeaderLengthFromSim,unsigned char *PtrFileHeaderFromSim,\
                        unsigned char FileBodyLengthFromSim,unsigned char *PtrFileBodyFromSim ){ 
                        	
vcard_sort_list_t VcardIndexList[MAX_VCARDINDEX];        
int vcardindexlistserialnumber;
vcard_file_property_t file1;
unsigned char tmpbuf1[APDU_BUF_MAX_LENGTH];
//TODO 补充强壮性
       
   if ((FileHeaderLengthFromSim>APDU_BUF_MAX_LENGTH)||(FileBodyLengthFromSim>APDU_BUF_MAX_LENGTH))
   	    return -1;
   if (GetVcardFileProperty(identifier, &file1)<0) 
	   	   return -1;
	 if (!((file1.property&FILE_TYPE_EF)&&(file1.property&EF_STRUCTURE_TRANSPARENT)))
	 	     return -1; 	   
   if  (GenVcardIndex(ucvcardbuf, VCARD_MAX_LENGTH,VcardIndexList ,MAX_VCARDINDEX)==-1)
    	 return -1;	
   if( (vcardindexlistserialnumber= GetIdentifierIndex(identifier,VcardIndexList))<0) 
   	   return -1;
   if (GetFileHeaderContext( vcardindexlistserialnumber,VcardIndexList, tmpbuf1,FileHeaderLengthFromSim)<0)	   
        return -1;  
   for (unsigned char cmplength=0;cmplength< FileHeaderLengthFromSim;  cmplength++)
        if (tmpbuf1[cmplength]!=PtrFileHeaderFromSim[cmplength])
        	  return -1;                  	     
	 if (GetFileHeaderContext( vcardindexlistserialnumber,VcardIndexList, tmpbuf1,FileHeaderLengthFromSim)<0)	   
        return -1;  
   for (unsigned char cmplength=0;cmplength< FileHeaderLengthFromSim;  cmplength++)
       if (tmpbuf1[cmplength]!=PtrFileHeaderFromSim[cmplength])
        	  return -1;    
   if (GetFileBodyLength(vcardindexlistserialnumber,VcardIndexList)!=(int)FileBodyLengthFromSim)
   	   return -1; 
    
   if (GetFileBodyContext( vcardindexlistserialnumber, VcardIndexList,tmpbuf1,FileBodyLengthFromSim)<0)	   
        return -1;  	
   for (unsigned char cmplength=0;cmplength< FileBodyLengthFromSim;  cmplength++)
       if (tmpbuf1[cmplength]!=PtrFileBodyFromSim[cmplength])
        	  return -1; 
   return 1;      	           	           	    	    	    
}


// 检查buf 中是否含Sim Vcard 和 Usim Vcard Uim
unsigned char CheckUiccInVcard(unsigned char ucvcardbuf[]){
	  return ((ucvcardbuf[OFFSET_VCARD_MAINTAIN_INFORMATION])&(VC_DATA_USIMMODE_MAINTAIN|VC_DATA_SIMMODE_MAINTAIN|VC_DATA_UIMMODE_MAINTAIN));
}				


/**************************************************************************** 
* 函数名称 : ModifyAtr
* 功能描述 : 将初始Atr修改为Emu适用Atr
* 参    数 : 
* 参    数 : sim_atr_ori 原始AtrBuf ，len_ori 原始Atr长度； 
* 参    数 :  *ptr_sim_atr_mod  存放修改后Atr的Buf指针  *ptr_len_mod  指向修改后Atr长度的指针
* 参    数 : 输入参数 EmuAdaptorSpeedLevel EmuAdaptor与Gw模块通信速度级别  0-2 值越大速度越快
* 返 回 值 : 成功 返回 1  不成功 返回 -1
* 作    者 : 王翔
* 设计日期 : 
* 修改日期		  修改人		   修改内容  
 *****************************************************************************/	  

int ModifyAtr(unsigned char sim_atr_ori[BANK_FRAME_MAX_LENGTH],unsigned int len_ori  , unsigned char *ptr_sim_atr_mod,\
              unsigned int *ptr_len_mod,unsigned char EmuAdaptorSpeedLevel)	{
	
	if (len_ori>BANK_FRAME_MAX_LENGTH)
		 return -1;
	if (!((sim_atr_ori[0]==0x3B)||(sim_atr_ori[0]==0x3F)))  //TS
		 return -1;
	else 	
	   ptr_sim_atr_mod[0]=0x3B;  //	全部按照正向来模拟
	   
	unsigned char luc_AtrHistoryLen=sim_atr_ori[1] & 0x0F;;
	unsigned char luc_AtrModifyLenNoHstryByte;
	unsigned char luc_CurrAtrBytePos;
	unsigned char uc_SimT0T1;   
	unsigned char uc_TD1_CurrAtrBytePos;
	unsigned char uc_TD2_CurrAtrBytePos;
	unsigned char uc_TD3_CurrAtrBytePos;
	unsigned char uc_T_equal_15=0;
	unsigned char ucTck;
		 
  if (EmuAdaptorSpeedLevel==EMU_ADAPTOR_SPEED_LEVEL_NORMAL){  //标准速率  	
  	   ptr_sim_atr_mod[1] = sim_atr_ori[1] & 0xEF;//去掉TA1;无论有没有都去掉       //T0       
  	 //  unsigned char luc_AtrHistoryLen = sim_atr_ori[1] & 0x0F;
			 luc_AtrModifyLenNoHstryByte = 2; //不包括history byte
			 luc_CurrAtrBytePos = 2;//point to next to T0
			 if (sim_atr_ori[1] & 0x10) {//如果TA1存在
						luc_CurrAtrBytePos++;//point to next //skip
			 }
	}
	else{   //TA1 Global interface byte  Fi.Di
	if ((EmuAdaptorSpeedLevel==EMU_ADAPTOR_SPEED_LEVEL_F512D8)||(EmuAdaptorSpeedLevel==EMU_ADAPTOR_SPEED_LEVEL_F512D16)){ 
		   ptr_sim_atr_mod[1] = sim_atr_ori[1] | 0x10;//加上TA1;无论有没有都加上       //T0 
		   luc_AtrModifyLenNoHstryByte = 3; //不包括history byte 
		   luc_CurrAtrBytePos = 2;//point to next to T0	
		   if (sim_atr_ori[1] & 0x10) {//如果TA1存在
		        ptr_sim_atr_mod[2]=(EmuAdaptorSpeedLevel==EMU_ADAPTOR_SPEED_LEVEL_F512D8)? 0x94:0x95;
			      luc_CurrAtrBytePos ++;//point to next to T0		       
		    }
  }
  else	
  	return -1;
  }	
		 		// TB1 Global interface byte  deprecated 
			 if (sim_atr_ori[1] & 0x20) {//如果TB1存在
						ptr_sim_atr_mod[luc_AtrModifyLenNoHstryByte] = sim_atr_ori[luc_CurrAtrBytePos];
						luc_AtrModifyLenNoHstryByte++;
						luc_CurrAtrBytePos++;//point to next
			 }
			// TC1 Global interface byte  extra guard time integer
			 if (sim_atr_ori[1] & 0x40) {//如果TC1存在
						ptr_sim_atr_mod[luc_AtrModifyLenNoHstryByte] = sim_atr_ori[luc_CurrAtrBytePos];
						luc_AtrModifyLenNoHstryByte++;
						luc_CurrAtrBytePos++;//point to next
			 }
			 // TD1 Structural, encodes Y2 and T
			 // TA2 Global interface byte  specific mode byte
			 if (HANDLE_ATR_FISRT_TA_FOR_T_EUQAL15){
			 	  if (sim_atr_ori[1] & 0x80) {//如果TD1存在
			 	  	    uc_TD1_CurrAtrBytePos=luc_CurrAtrBytePos;
     	  				ptr_sim_atr_mod[luc_AtrModifyLenNoHstryByte] = sim_atr_ori[luc_CurrAtrBytePos] & 0x8F;//不再支持后面的TA2,TB2,TC2
     	  				if (ptr_sim_atr_mod[luc_AtrModifyLenNoHstryByte] & 1) 
     	  					uc_SimT0T1 = 1;
     	  				else 						
     	  					uc_SimT0T1 = 0;
     	  				luc_AtrModifyLenNoHstryByte++;
     	  				luc_CurrAtrBytePos++;//point to next
     	  				
     	  				if (sim_atr_ori[uc_TD1_CurrAtrBytePos] & 0x10) //如果TA2存在
     	  					 luc_CurrAtrBytePos++;//point to next
     	  				if (sim_atr_ori[uc_TD1_CurrAtrBytePos] & 0x20) //如果TB2存在
     	  					 luc_CurrAtrBytePos++;//point to next	 
     	  				if (sim_atr_ori[uc_TD1_CurrAtrBytePos] & 0x40) //如果TC2存在
     	  					 luc_CurrAtrBytePos++;//point to next	 	 
     	  				if (sim_atr_ori[uc_TD1_CurrAtrBytePos] & 0x80) {//如果TD2存在 保留
     	  					 uc_TD2_CurrAtrBytePos=luc_CurrAtrBytePos;
     	  					 ptr_sim_atr_mod[luc_AtrModifyLenNoHstryByte] = sim_atr_ori[luc_CurrAtrBytePos] & 0x9F;//不再支持后面的TB3,TC3
     	  					
     	  					 if ((ptr_sim_atr_mod[luc_AtrModifyLenNoHstryByte] & 0xf)==0xf){   //TD2_T=15 则TA3 encodes the clock stop indicator (X) and the class indicator (Y)
     	  					 	   	   uc_T_equal_15=1;
     	  					 	   	   luc_AtrModifyLenNoHstryByte++;
						               luc_CurrAtrBytePos++;//point to next
                          if (sim_atr_ori[uc_TD2_CurrAtrBytePos] & 0x10){ //如果TA3存在 保留    	  					 	   		
     	  					 	   		ptr_sim_atr_mod[luc_AtrModifyLenNoHstryByte] = sim_atr_ori[luc_CurrAtrBytePos];
     	  					 	   	//  ptr_sim_atr_mod[luc_AtrModifyLenNoHstryByte] = (sim_atr_ori[luc_CurrAtrBytePos]&0xF)|0x40;
     	  					 	   		luc_AtrModifyLenNoHstryByte++;
     	  					 	   		luc_CurrAtrBytePos++;//point to next	
						            }    					 	   		
     	    	  				  if (sim_atr_ori[uc_TD2_CurrAtrBytePos] & 0x20) //如果TB3存在 舍去
     	  					         luc_CurrAtrBytePos++;//point to next	 
     	  				        if (sim_atr_ori[uc_TD2_CurrAtrBytePos] & 0x40) //如果TC3存在 舍去
     	  					           luc_CurrAtrBytePos++;//point to next	 	 
     	  				        if (sim_atr_ori[uc_TD2_CurrAtrBytePos] & 0x80) //如果TD3存在 舍去
     	  				        	    luc_CurrAtrBytePos++;//point to next	 
                  }
                  else{  // 不再支持后面的TA3,TB3,TC3
                  	    luc_AtrModifyLenNoHstryByte++;
						            luc_CurrAtrBytePos++;//point to next
                  	    if (sim_atr_ori[uc_TD2_CurrAtrBytePos] & 0x10){ //如果TA3存在 舍去     	  					 	   		     	  					 	   		
     	  					 	   		luc_CurrAtrBytePos++;//point to next	
						            }    					 	   		
     	    	  				  if (sim_atr_ori[uc_TD2_CurrAtrBytePos] & 0x20) //如果TB3存在 舍去
     	  					         luc_CurrAtrBytePos++;//point to next	 
     	  				        if (sim_atr_ori[uc_TD2_CurrAtrBytePos] & 0x40) //如果TC3存在 舍去
     	  					           luc_CurrAtrBytePos++;//point to next	 	 
     	  				        if (sim_atr_ori[uc_TD2_CurrAtrBytePos] & 0x80){ //如果TD3存在 保留
     	  				        	    uc_TD3_CurrAtrBytePos=luc_CurrAtrBytePos;
     	  					            ptr_sim_atr_mod[luc_AtrModifyLenNoHstryByte] = sim_atr_ori[luc_CurrAtrBytePos] & 0x9F;//不再支持后面的TB4,TC4
     	  					           
						                  if ((ptr_sim_atr_mod[luc_AtrModifyLenNoHstryByte] & 0xf)==0xf){   //TD3_T=15 则TA4 encodes the clock stop indicator (X) and the class indicator (Y)
     	  					 	   	             luc_AtrModifyLenNoHstryByte++;
						                         luc_CurrAtrBytePos++;//point to next
     	  					 	   	             if (sim_atr_ori[uc_TD3_CurrAtrBytePos] & 0x10){ //如果TA4存在     	  					 	   		
     	  					 	   		               ptr_sim_atr_mod[luc_AtrModifyLenNoHstryByte] = sim_atr_ori[luc_CurrAtrBytePos];
     	  					 	   		               luc_AtrModifyLenNoHstryByte++;
     	  					 	   		               luc_CurrAtrBytePos++;//point to next	
						                         }    					 	   		
     	    	  				               if (sim_atr_ori[uc_TD3_CurrAtrBytePos] & 0x20) //如果TB4存在 舍去
     	  					                          luc_CurrAtrBytePos++;//point to next	 
     	  				                     if (sim_atr_ori[uc_TD3_CurrAtrBytePos] & 0x40) //如果TC4存在 舍去
     	  					                         luc_CurrAtrBytePos++;//point to next	 	 
     	  				                     if (sim_atr_ori[uc_TD3_CurrAtrBytePos] & 0x80) //如果TD4存在 舍去
     	  				        	                 luc_CurrAtrBytePos++;//point to next	 
                              }
                         }                   	                	
                   }                 
     	  				}	  	 
     	  		  }
     	  	   	else 
     	  				uc_SimT0T1 = 0;
			 	}
			 	else{
     	  	    if (sim_atr_ori[1] & 0x80) {//如果TD1存在
     	  				ptr_sim_atr_mod[luc_AtrModifyLenNoHstryByte] = sim_atr_ori[luc_CurrAtrBytePos] & 0x0F;//不再支持后面的TA2
     	  				if (ptr_sim_atr_mod[luc_AtrModifyLenNoHstryByte] & 1) 
     	  					uc_SimT0T1 = 1;
     	  				else 						
     	  					uc_SimT0T1 = 0;
     	  				luc_AtrModifyLenNoHstryByte++;
     	  				luc_CurrAtrBytePos++;//point to next
     	  		  }
     	  	   	else 
     	  				uc_SimT0T1 = 0;
				}		
				*ptr_len_mod = luc_AtrModifyLenNoHstryByte + luc_AtrHistoryLen;
				if (uc_SimT0T1) {//T1 
						memcpy(&(ptr_sim_atr_mod[luc_AtrModifyLenNoHstryByte]), &(sim_atr_ori[len_ori - luc_AtrHistoryLen - 1]), luc_AtrHistoryLen);
						//计算xor
						unsigned char luc_xor = 0;
						for (luc_AtrModifyLenNoHstryByte = 1; luc_AtrModifyLenNoHstryByte < *ptr_len_mod; luc_AtrModifyLenNoHstryByte++) {//from T0
							luc_xor ^= ptr_sim_atr_mod[luc_AtrModifyLenNoHstryByte];
						}
						ptr_sim_atr_mod[*ptr_len_mod] = luc_xor;
						*ptr_len_mod += 1;//加上xor
					}
				else
			  if ((uc_SimT0T1==0)&&(uc_T_equal_15==1)){  //T=0,T=15同时存在，则加上TCK
			  	  memcpy(&(ptr_sim_atr_mod[luc_AtrModifyLenNoHstryByte]), &(sim_atr_ori[len_ori - luc_AtrHistoryLen]), luc_AtrHistoryLen);  //rdr 固件中没有读出TCK 
			  	//计算xor
						unsigned char luc_xor = 0;
						for (luc_AtrModifyLenNoHstryByte = 1; luc_AtrModifyLenNoHstryByte < *ptr_len_mod; luc_AtrModifyLenNoHstryByte++) {//from T0
							luc_xor ^= ptr_sim_atr_mod[luc_AtrModifyLenNoHstryByte];
						}
						ptr_sim_atr_mod[*ptr_len_mod] = luc_xor;
						*ptr_len_mod += 1;//加上xor											
			  }  
				else {
						memcpy(&(ptr_sim_atr_mod[luc_AtrModifyLenNoHstryByte]), &(sim_atr_ori[len_ori - luc_AtrHistoryLen]), luc_AtrHistoryLen);												
				}	
			  ptr_sim_atr_mod[*ptr_len_mod] = uc_SimT0T1;//末尾加上T0T1, 准备发送给EMU
					*ptr_len_mod = *ptr_len_mod + 1;
  	
	return 1;
	} 


