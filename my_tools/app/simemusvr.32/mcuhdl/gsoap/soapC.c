/* soapC.c
   Generated by gSOAP 2.8.17 from /home/peng/wg32_dev/my_tools/app/simemusvr.32/mcuhdl/gsoap/gsm_mcu_hdl.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.8.17 2017-09-25 07:39:49 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = (struct SOAP_ENV__Header*)soap_malloc(soap, sizeof(struct SOAP_ENV__Header))))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_ns__gsm_mcu_reg_write:
		return soap_in_ns__gsm_mcu_reg_write(soap, NULL, NULL, "ns:gsm-mcu-reg-write");
	case SOAP_TYPE_ns__gsm_mcu_reg_writeResponse:
		return soap_in_ns__gsm_mcu_reg_writeResponse(soap, NULL, NULL, "ns:gsm-mcu-reg-writeResponse");
	case SOAP_TYPE_ns__gsm_mcu_reg_read:
		return soap_in_ns__gsm_mcu_reg_read(soap, NULL, NULL, "ns:gsm-mcu-reg-read");
	case SOAP_TYPE_ns__gsm_mcu_reg_readResponse:
		return soap_in_ns__gsm_mcu_reg_readResponse(soap, NULL, NULL, "ns:gsm-mcu-reg-readResponse");
	case SOAP_TYPE_ns__gsm_get_restore_event:
		return soap_in_ns__gsm_get_restore_event(soap, NULL, NULL, "ns:gsm-get-restore-event");
	case SOAP_TYPE_ns__gsm_get_restore_eventResponse:
		return soap_in_ns__gsm_get_restore_eventResponse(soap, NULL, NULL, "ns:gsm-get-restore-eventResponse");
	case SOAP_TYPE_ns__gsm_get_mcu_help:
		return soap_in_ns__gsm_get_mcu_help(soap, NULL, NULL, "ns:gsm-get-mcu-help");
	case SOAP_TYPE_ns__gsm_get_mcu_helpResponse:
		return soap_in_ns__gsm_get_mcu_helpResponse(soap, NULL, NULL, "ns:gsm-get-mcu-helpResponse");
	case SOAP_TYPE_ns__gsm_get_mcu_version:
		return soap_in_ns__gsm_get_mcu_version(soap, NULL, NULL, "ns:gsm-get-mcu-version");
	case SOAP_TYPE_ns__gsm_get_mcu_versionResponse:
		return soap_in_ns__gsm_get_mcu_versionResponse(soap, NULL, NULL, "ns:gsm-get-mcu-versionResponse");
	case SOAP_TYPE_ns__gsm_set_led_control:
		return soap_in_ns__gsm_set_led_control(soap, NULL, NULL, "ns:gsm-set-led-control");
	case SOAP_TYPE_ns__gsm_set_led_controlResponse:
		return soap_in_ns__gsm_set_led_controlResponse(soap, NULL, NULL, "ns:gsm-set-led-controlResponse");
	case SOAP_TYPE_ns__gsm_get_gsmboard_insert_status:
		return soap_in_ns__gsm_get_gsmboard_insert_status(soap, NULL, NULL, "ns:gsm-get-gsmboard-insert-status");
	case SOAP_TYPE_ns__gsm_get_simcard_insert_status:
		return soap_in_ns__gsm_get_simcard_insert_status(soap, NULL, NULL, "ns:gsm-get-simcard-insert-status");
	case SOAP_TYPE_ns__gsm_get_module_status:
		return soap_in_ns__gsm_get_module_status(soap, NULL, NULL, "ns:gsm-get-module-status");
	case SOAP_TYPE_ns__gsm_module_off:
		return soap_in_ns__gsm_module_off(soap, NULL, NULL, "ns:gsm-module-off");
	case SOAP_TYPE_ns__gsm_module_offResponse:
		return soap_in_ns__gsm_module_offResponse(soap, NULL, NULL, "ns:gsm-module-offResponse");
	case SOAP_TYPE_ns__gsm_module_on:
		return soap_in_ns__gsm_module_on(soap, NULL, NULL, "ns:gsm-module-on");
	case SOAP_TYPE_ns__gsm_module_onResponse:
		return soap_in_ns__gsm_module_onResponse(soap, NULL, NULL, "ns:gsm-module-onResponse");
	case SOAP_TYPE_ns__gsm_module_emerg_off:
		return soap_in_ns__gsm_module_emerg_off(soap, NULL, NULL, "ns:gsm-module-emerg-off");
	case SOAP_TYPE_ns__gsm_module_emerg_offResponse:
		return soap_in_ns__gsm_module_emerg_offResponse(soap, NULL, NULL, "ns:gsm-module-emerg-offResponse");
	case SOAP_TYPE_ns__gsm_get_module_power_status:
		return soap_in_ns__gsm_get_module_power_status(soap, NULL, NULL, "ns:gsm-get-module-power-status");
	case SOAP_TYPE_ns__gsm_module_power_off:
		return soap_in_ns__gsm_module_power_off(soap, NULL, NULL, "ns:gsm-module-power-off");
	case SOAP_TYPE_ns__gsm_module_power_offResponse:
		return soap_in_ns__gsm_module_power_offResponse(soap, NULL, NULL, "ns:gsm-module-power-offResponse");
	case SOAP_TYPE_ns__gsm_module_power_on:
		return soap_in_ns__gsm_module_power_on(soap, NULL, NULL, "ns:gsm-module-power-on");
	case SOAP_TYPE_ns__gsm_module_power_onResponse:
		return soap_in_ns__gsm_module_power_onResponse(soap, NULL, NULL, "ns:gsm-module-power-onResponse");
	case SOAP_TYPE_ns__gsm_get_simcard_status:
		return soap_in_ns__gsm_get_simcard_status(soap, NULL, NULL, "ns:gsm-get-simcard-status");
	case SOAP_TYPE_ns__gsm_simcard_disable:
		return soap_in_ns__gsm_simcard_disable(soap, NULL, NULL, "ns:gsm-simcard-disable");
	case SOAP_TYPE_ns__gsm_simcard_disableResponse:
		return soap_in_ns__gsm_simcard_disableResponse(soap, NULL, NULL, "ns:gsm-simcard-disableResponse");
	case SOAP_TYPE_ns__gsm_simcard_enable:
		return soap_in_ns__gsm_simcard_enable(soap, NULL, NULL, "ns:gsm-simcard-enable");
	case SOAP_TYPE_ns__gsm_simcard_enableResponse:
		return soap_in_ns__gsm_simcard_enableResponse(soap, NULL, NULL, "ns:gsm-simcard-enableResponse");
	case SOAP_TYPE_ns__gsm_mcu_rsp_t:
		return soap_in_ns__gsm_mcu_rsp_t(soap, NULL, NULL, "ns:gsm-mcu-rsp-t");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTons__gsm_mcu_rsp_t:
		return soap_in_PointerTons__gsm_mcu_rsp_t(soap, NULL, NULL, "ns:gsm-mcu-rsp-t");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:gsm-mcu-reg-write"))
		{	*type = SOAP_TYPE_ns__gsm_mcu_reg_write;
			return soap_in_ns__gsm_mcu_reg_write(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:gsm-mcu-reg-writeResponse"))
		{	*type = SOAP_TYPE_ns__gsm_mcu_reg_writeResponse;
			return soap_in_ns__gsm_mcu_reg_writeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:gsm-mcu-reg-read"))
		{	*type = SOAP_TYPE_ns__gsm_mcu_reg_read;
			return soap_in_ns__gsm_mcu_reg_read(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:gsm-mcu-reg-readResponse"))
		{	*type = SOAP_TYPE_ns__gsm_mcu_reg_readResponse;
			return soap_in_ns__gsm_mcu_reg_readResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:gsm-get-restore-event"))
		{	*type = SOAP_TYPE_ns__gsm_get_restore_event;
			return soap_in_ns__gsm_get_restore_event(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:gsm-get-restore-eventResponse"))
		{	*type = SOAP_TYPE_ns__gsm_get_restore_eventResponse;
			return soap_in_ns__gsm_get_restore_eventResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:gsm-get-mcu-help"))
		{	*type = SOAP_TYPE_ns__gsm_get_mcu_help;
			return soap_in_ns__gsm_get_mcu_help(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:gsm-get-mcu-helpResponse"))
		{	*type = SOAP_TYPE_ns__gsm_get_mcu_helpResponse;
			return soap_in_ns__gsm_get_mcu_helpResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:gsm-get-mcu-version"))
		{	*type = SOAP_TYPE_ns__gsm_get_mcu_version;
			return soap_in_ns__gsm_get_mcu_version(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:gsm-get-mcu-versionResponse"))
		{	*type = SOAP_TYPE_ns__gsm_get_mcu_versionResponse;
			return soap_in_ns__gsm_get_mcu_versionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:gsm-set-led-control"))
		{	*type = SOAP_TYPE_ns__gsm_set_led_control;
			return soap_in_ns__gsm_set_led_control(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:gsm-set-led-controlResponse"))
		{	*type = SOAP_TYPE_ns__gsm_set_led_controlResponse;
			return soap_in_ns__gsm_set_led_controlResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:gsm-get-gsmboard-insert-status"))
		{	*type = SOAP_TYPE_ns__gsm_get_gsmboard_insert_status;
			return soap_in_ns__gsm_get_gsmboard_insert_status(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:gsm-get-simcard-insert-status"))
		{	*type = SOAP_TYPE_ns__gsm_get_simcard_insert_status;
			return soap_in_ns__gsm_get_simcard_insert_status(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:gsm-get-module-status"))
		{	*type = SOAP_TYPE_ns__gsm_get_module_status;
			return soap_in_ns__gsm_get_module_status(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:gsm-module-off"))
		{	*type = SOAP_TYPE_ns__gsm_module_off;
			return soap_in_ns__gsm_module_off(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:gsm-module-offResponse"))
		{	*type = SOAP_TYPE_ns__gsm_module_offResponse;
			return soap_in_ns__gsm_module_offResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:gsm-module-on"))
		{	*type = SOAP_TYPE_ns__gsm_module_on;
			return soap_in_ns__gsm_module_on(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:gsm-module-onResponse"))
		{	*type = SOAP_TYPE_ns__gsm_module_onResponse;
			return soap_in_ns__gsm_module_onResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:gsm-module-emerg-off"))
		{	*type = SOAP_TYPE_ns__gsm_module_emerg_off;
			return soap_in_ns__gsm_module_emerg_off(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:gsm-module-emerg-offResponse"))
		{	*type = SOAP_TYPE_ns__gsm_module_emerg_offResponse;
			return soap_in_ns__gsm_module_emerg_offResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:gsm-get-module-power-status"))
		{	*type = SOAP_TYPE_ns__gsm_get_module_power_status;
			return soap_in_ns__gsm_get_module_power_status(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:gsm-module-power-off"))
		{	*type = SOAP_TYPE_ns__gsm_module_power_off;
			return soap_in_ns__gsm_module_power_off(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:gsm-module-power-offResponse"))
		{	*type = SOAP_TYPE_ns__gsm_module_power_offResponse;
			return soap_in_ns__gsm_module_power_offResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:gsm-module-power-on"))
		{	*type = SOAP_TYPE_ns__gsm_module_power_on;
			return soap_in_ns__gsm_module_power_on(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:gsm-module-power-onResponse"))
		{	*type = SOAP_TYPE_ns__gsm_module_power_onResponse;
			return soap_in_ns__gsm_module_power_onResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:gsm-get-simcard-status"))
		{	*type = SOAP_TYPE_ns__gsm_get_simcard_status;
			return soap_in_ns__gsm_get_simcard_status(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:gsm-simcard-disable"))
		{	*type = SOAP_TYPE_ns__gsm_simcard_disable;
			return soap_in_ns__gsm_simcard_disable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:gsm-simcard-disableResponse"))
		{	*type = SOAP_TYPE_ns__gsm_simcard_disableResponse;
			return soap_in_ns__gsm_simcard_disableResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:gsm-simcard-enable"))
		{	*type = SOAP_TYPE_ns__gsm_simcard_enable;
			return soap_in_ns__gsm_simcard_enable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:gsm-simcard-enableResponse"))
		{	*type = SOAP_TYPE_ns__gsm_simcard_enableResponse;
			return soap_in_ns__gsm_simcard_enableResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:gsm-mcu-rsp-t"))
		{	*type = SOAP_TYPE_ns__gsm_mcu_rsp_t;
			return soap_in_ns__gsm_mcu_rsp_t(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_ns__gsm_mcu_reg_write:
		return soap_out_ns__gsm_mcu_reg_write(soap, tag, id, (const struct ns__gsm_mcu_reg_write *)ptr, "ns:gsm-mcu-reg-write");
	case SOAP_TYPE_ns__gsm_mcu_reg_writeResponse:
		return soap_out_ns__gsm_mcu_reg_writeResponse(soap, tag, id, (const struct ns__gsm_mcu_reg_writeResponse *)ptr, "ns:gsm-mcu-reg-writeResponse");
	case SOAP_TYPE_ns__gsm_mcu_reg_read:
		return soap_out_ns__gsm_mcu_reg_read(soap, tag, id, (const struct ns__gsm_mcu_reg_read *)ptr, "ns:gsm-mcu-reg-read");
	case SOAP_TYPE_ns__gsm_mcu_reg_readResponse:
		return soap_out_ns__gsm_mcu_reg_readResponse(soap, tag, id, (const struct ns__gsm_mcu_reg_readResponse *)ptr, "ns:gsm-mcu-reg-readResponse");
	case SOAP_TYPE_ns__gsm_get_restore_event:
		return soap_out_ns__gsm_get_restore_event(soap, tag, id, (const struct ns__gsm_get_restore_event *)ptr, "ns:gsm-get-restore-event");
	case SOAP_TYPE_ns__gsm_get_restore_eventResponse:
		return soap_out_ns__gsm_get_restore_eventResponse(soap, tag, id, (const struct ns__gsm_get_restore_eventResponse *)ptr, "ns:gsm-get-restore-eventResponse");
	case SOAP_TYPE_ns__gsm_get_mcu_help:
		return soap_out_ns__gsm_get_mcu_help(soap, tag, id, (const struct ns__gsm_get_mcu_help *)ptr, "ns:gsm-get-mcu-help");
	case SOAP_TYPE_ns__gsm_get_mcu_helpResponse:
		return soap_out_ns__gsm_get_mcu_helpResponse(soap, tag, id, (const struct ns__gsm_get_mcu_helpResponse *)ptr, "ns:gsm-get-mcu-helpResponse");
	case SOAP_TYPE_ns__gsm_get_mcu_version:
		return soap_out_ns__gsm_get_mcu_version(soap, tag, id, (const struct ns__gsm_get_mcu_version *)ptr, "ns:gsm-get-mcu-version");
	case SOAP_TYPE_ns__gsm_get_mcu_versionResponse:
		return soap_out_ns__gsm_get_mcu_versionResponse(soap, tag, id, (const struct ns__gsm_get_mcu_versionResponse *)ptr, "ns:gsm-get-mcu-versionResponse");
	case SOAP_TYPE_ns__gsm_set_led_control:
		return soap_out_ns__gsm_set_led_control(soap, tag, id, (const struct ns__gsm_set_led_control *)ptr, "ns:gsm-set-led-control");
	case SOAP_TYPE_ns__gsm_set_led_controlResponse:
		return soap_out_ns__gsm_set_led_controlResponse(soap, tag, id, (const struct ns__gsm_set_led_controlResponse *)ptr, "ns:gsm-set-led-controlResponse");
	case SOAP_TYPE_ns__gsm_get_gsmboard_insert_status:
		return soap_out_ns__gsm_get_gsmboard_insert_status(soap, tag, id, (const struct ns__gsm_get_gsmboard_insert_status *)ptr, "ns:gsm-get-gsmboard-insert-status");
	case SOAP_TYPE_ns__gsm_get_simcard_insert_status:
		return soap_out_ns__gsm_get_simcard_insert_status(soap, tag, id, (const struct ns__gsm_get_simcard_insert_status *)ptr, "ns:gsm-get-simcard-insert-status");
	case SOAP_TYPE_ns__gsm_get_module_status:
		return soap_out_ns__gsm_get_module_status(soap, tag, id, (const struct ns__gsm_get_module_status *)ptr, "ns:gsm-get-module-status");
	case SOAP_TYPE_ns__gsm_module_off:
		return soap_out_ns__gsm_module_off(soap, tag, id, (const struct ns__gsm_module_off *)ptr, "ns:gsm-module-off");
	case SOAP_TYPE_ns__gsm_module_offResponse:
		return soap_out_ns__gsm_module_offResponse(soap, tag, id, (const struct ns__gsm_module_offResponse *)ptr, "ns:gsm-module-offResponse");
	case SOAP_TYPE_ns__gsm_module_on:
		return soap_out_ns__gsm_module_on(soap, tag, id, (const struct ns__gsm_module_on *)ptr, "ns:gsm-module-on");
	case SOAP_TYPE_ns__gsm_module_onResponse:
		return soap_out_ns__gsm_module_onResponse(soap, tag, id, (const struct ns__gsm_module_onResponse *)ptr, "ns:gsm-module-onResponse");
	case SOAP_TYPE_ns__gsm_module_emerg_off:
		return soap_out_ns__gsm_module_emerg_off(soap, tag, id, (const struct ns__gsm_module_emerg_off *)ptr, "ns:gsm-module-emerg-off");
	case SOAP_TYPE_ns__gsm_module_emerg_offResponse:
		return soap_out_ns__gsm_module_emerg_offResponse(soap, tag, id, (const struct ns__gsm_module_emerg_offResponse *)ptr, "ns:gsm-module-emerg-offResponse");
	case SOAP_TYPE_ns__gsm_get_module_power_status:
		return soap_out_ns__gsm_get_module_power_status(soap, tag, id, (const struct ns__gsm_get_module_power_status *)ptr, "ns:gsm-get-module-power-status");
	case SOAP_TYPE_ns__gsm_module_power_off:
		return soap_out_ns__gsm_module_power_off(soap, tag, id, (const struct ns__gsm_module_power_off *)ptr, "ns:gsm-module-power-off");
	case SOAP_TYPE_ns__gsm_module_power_offResponse:
		return soap_out_ns__gsm_module_power_offResponse(soap, tag, id, (const struct ns__gsm_module_power_offResponse *)ptr, "ns:gsm-module-power-offResponse");
	case SOAP_TYPE_ns__gsm_module_power_on:
		return soap_out_ns__gsm_module_power_on(soap, tag, id, (const struct ns__gsm_module_power_on *)ptr, "ns:gsm-module-power-on");
	case SOAP_TYPE_ns__gsm_module_power_onResponse:
		return soap_out_ns__gsm_module_power_onResponse(soap, tag, id, (const struct ns__gsm_module_power_onResponse *)ptr, "ns:gsm-module-power-onResponse");
	case SOAP_TYPE_ns__gsm_get_simcard_status:
		return soap_out_ns__gsm_get_simcard_status(soap, tag, id, (const struct ns__gsm_get_simcard_status *)ptr, "ns:gsm-get-simcard-status");
	case SOAP_TYPE_ns__gsm_simcard_disable:
		return soap_out_ns__gsm_simcard_disable(soap, tag, id, (const struct ns__gsm_simcard_disable *)ptr, "ns:gsm-simcard-disable");
	case SOAP_TYPE_ns__gsm_simcard_disableResponse:
		return soap_out_ns__gsm_simcard_disableResponse(soap, tag, id, (const struct ns__gsm_simcard_disableResponse *)ptr, "ns:gsm-simcard-disableResponse");
	case SOAP_TYPE_ns__gsm_simcard_enable:
		return soap_out_ns__gsm_simcard_enable(soap, tag, id, (const struct ns__gsm_simcard_enable *)ptr, "ns:gsm-simcard-enable");
	case SOAP_TYPE_ns__gsm_simcard_enableResponse:
		return soap_out_ns__gsm_simcard_enableResponse(soap, tag, id, (const struct ns__gsm_simcard_enableResponse *)ptr, "ns:gsm-simcard-enableResponse");
	case SOAP_TYPE_ns__gsm_mcu_rsp_t:
		return soap_out_ns__gsm_mcu_rsp_t(soap, tag, id, (const struct ns__gsm_mcu_rsp_t *)ptr, "ns:gsm-mcu-rsp-t");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTons__gsm_mcu_rsp_t:
		return soap_out_PointerTons__gsm_mcu_rsp_t(soap, tag, id, (struct ns__gsm_mcu_rsp_t *const*)ptr, "ns:gsm-mcu-rsp-t");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ns__gsm_mcu_reg_write:
		soap_serialize_ns__gsm_mcu_reg_write(soap, (const struct ns__gsm_mcu_reg_write *)ptr);
		break;
	case SOAP_TYPE_ns__gsm_mcu_reg_writeResponse:
		soap_serialize_ns__gsm_mcu_reg_writeResponse(soap, (const struct ns__gsm_mcu_reg_writeResponse *)ptr);
		break;
	case SOAP_TYPE_ns__gsm_mcu_reg_read:
		soap_serialize_ns__gsm_mcu_reg_read(soap, (const struct ns__gsm_mcu_reg_read *)ptr);
		break;
	case SOAP_TYPE_ns__gsm_mcu_reg_readResponse:
		soap_serialize_ns__gsm_mcu_reg_readResponse(soap, (const struct ns__gsm_mcu_reg_readResponse *)ptr);
		break;
	case SOAP_TYPE_ns__gsm_get_restore_event:
		soap_serialize_ns__gsm_get_restore_event(soap, (const struct ns__gsm_get_restore_event *)ptr);
		break;
	case SOAP_TYPE_ns__gsm_get_restore_eventResponse:
		soap_serialize_ns__gsm_get_restore_eventResponse(soap, (const struct ns__gsm_get_restore_eventResponse *)ptr);
		break;
	case SOAP_TYPE_ns__gsm_get_mcu_help:
		soap_serialize_ns__gsm_get_mcu_help(soap, (const struct ns__gsm_get_mcu_help *)ptr);
		break;
	case SOAP_TYPE_ns__gsm_get_mcu_helpResponse:
		soap_serialize_ns__gsm_get_mcu_helpResponse(soap, (const struct ns__gsm_get_mcu_helpResponse *)ptr);
		break;
	case SOAP_TYPE_ns__gsm_get_mcu_version:
		soap_serialize_ns__gsm_get_mcu_version(soap, (const struct ns__gsm_get_mcu_version *)ptr);
		break;
	case SOAP_TYPE_ns__gsm_get_mcu_versionResponse:
		soap_serialize_ns__gsm_get_mcu_versionResponse(soap, (const struct ns__gsm_get_mcu_versionResponse *)ptr);
		break;
	case SOAP_TYPE_ns__gsm_set_led_control:
		soap_serialize_ns__gsm_set_led_control(soap, (const struct ns__gsm_set_led_control *)ptr);
		break;
	case SOAP_TYPE_ns__gsm_set_led_controlResponse:
		soap_serialize_ns__gsm_set_led_controlResponse(soap, (const struct ns__gsm_set_led_controlResponse *)ptr);
		break;
	case SOAP_TYPE_ns__gsm_get_gsmboard_insert_status:
		soap_serialize_ns__gsm_get_gsmboard_insert_status(soap, (const struct ns__gsm_get_gsmboard_insert_status *)ptr);
		break;
	case SOAP_TYPE_ns__gsm_get_simcard_insert_status:
		soap_serialize_ns__gsm_get_simcard_insert_status(soap, (const struct ns__gsm_get_simcard_insert_status *)ptr);
		break;
	case SOAP_TYPE_ns__gsm_get_module_status:
		soap_serialize_ns__gsm_get_module_status(soap, (const struct ns__gsm_get_module_status *)ptr);
		break;
	case SOAP_TYPE_ns__gsm_module_off:
		soap_serialize_ns__gsm_module_off(soap, (const struct ns__gsm_module_off *)ptr);
		break;
	case SOAP_TYPE_ns__gsm_module_offResponse:
		soap_serialize_ns__gsm_module_offResponse(soap, (const struct ns__gsm_module_offResponse *)ptr);
		break;
	case SOAP_TYPE_ns__gsm_module_on:
		soap_serialize_ns__gsm_module_on(soap, (const struct ns__gsm_module_on *)ptr);
		break;
	case SOAP_TYPE_ns__gsm_module_onResponse:
		soap_serialize_ns__gsm_module_onResponse(soap, (const struct ns__gsm_module_onResponse *)ptr);
		break;
	case SOAP_TYPE_ns__gsm_module_emerg_off:
		soap_serialize_ns__gsm_module_emerg_off(soap, (const struct ns__gsm_module_emerg_off *)ptr);
		break;
	case SOAP_TYPE_ns__gsm_module_emerg_offResponse:
		soap_serialize_ns__gsm_module_emerg_offResponse(soap, (const struct ns__gsm_module_emerg_offResponse *)ptr);
		break;
	case SOAP_TYPE_ns__gsm_get_module_power_status:
		soap_serialize_ns__gsm_get_module_power_status(soap, (const struct ns__gsm_get_module_power_status *)ptr);
		break;
	case SOAP_TYPE_ns__gsm_module_power_off:
		soap_serialize_ns__gsm_module_power_off(soap, (const struct ns__gsm_module_power_off *)ptr);
		break;
	case SOAP_TYPE_ns__gsm_module_power_offResponse:
		soap_serialize_ns__gsm_module_power_offResponse(soap, (const struct ns__gsm_module_power_offResponse *)ptr);
		break;
	case SOAP_TYPE_ns__gsm_module_power_on:
		soap_serialize_ns__gsm_module_power_on(soap, (const struct ns__gsm_module_power_on *)ptr);
		break;
	case SOAP_TYPE_ns__gsm_module_power_onResponse:
		soap_serialize_ns__gsm_module_power_onResponse(soap, (const struct ns__gsm_module_power_onResponse *)ptr);
		break;
	case SOAP_TYPE_ns__gsm_get_simcard_status:
		soap_serialize_ns__gsm_get_simcard_status(soap, (const struct ns__gsm_get_simcard_status *)ptr);
		break;
	case SOAP_TYPE_ns__gsm_simcard_disable:
		soap_serialize_ns__gsm_simcard_disable(soap, (const struct ns__gsm_simcard_disable *)ptr);
		break;
	case SOAP_TYPE_ns__gsm_simcard_disableResponse:
		soap_serialize_ns__gsm_simcard_disableResponse(soap, (const struct ns__gsm_simcard_disableResponse *)ptr);
		break;
	case SOAP_TYPE_ns__gsm_simcard_enable:
		soap_serialize_ns__gsm_simcard_enable(soap, (const struct ns__gsm_simcard_enable *)ptr);
		break;
	case SOAP_TYPE_ns__gsm_simcard_enableResponse:
		soap_serialize_ns__gsm_simcard_enableResponse(soap, (const struct ns__gsm_simcard_enableResponse *)ptr);
		break;
	case SOAP_TYPE_ns__gsm_mcu_rsp_t:
		soap_serialize_ns__gsm_mcu_rsp_t(soap, (const struct ns__gsm_mcu_rsp_t *)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons__gsm_mcu_rsp_t:
		soap_serialize_PointerTons__gsm_mcu_rsp_t(soap, (struct ns__gsm_mcu_rsp_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{	unsigned char *p;
	p = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedByte);
	if (soap_out_unsignedByte(soap, tag?tag:"unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{	unsigned int *p;
	p = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag?tag:"unsignedInt", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__gsm_mcu_reg_write(struct soap *soap, struct ns__gsm_mcu_reg_write *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->brd);
	soap_default_int(soap, &a->reg);
	soap_default_unsignedByte(soap, &a->val);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__gsm_mcu_reg_write(struct soap *soap, const struct ns__gsm_mcu_reg_write *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->brd, SOAP_TYPE_int);
	soap_embedded(soap, &a->reg, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__gsm_mcu_reg_write(struct soap *soap, const char *tag, int id, const struct ns__gsm_mcu_reg_write *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__gsm_mcu_reg_write), type))
		return soap->error;
	if (soap_out_int(soap, "brd", -1, &a->brd, ""))
		return soap->error;
	if (soap_out_int(soap, "reg", -1, &a->reg, ""))
		return soap->error;
	if (soap_out_unsignedByte(soap, "val", -1, &a->val, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__gsm_mcu_reg_write * SOAP_FMAC4 soap_in_ns__gsm_mcu_reg_write(struct soap *soap, const char *tag, struct ns__gsm_mcu_reg_write *a, const char *type)
{
	size_t soap_flag_brd = 1;
	size_t soap_flag_reg = 1;
	size_t soap_flag_val = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__gsm_mcu_reg_write *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__gsm_mcu_reg_write, sizeof(struct ns__gsm_mcu_reg_write), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__gsm_mcu_reg_write(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_brd && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "brd", &a->brd, "xsd:int"))
				{	soap_flag_brd--;
					continue;
				}
			if (soap_flag_reg && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "reg", &a->reg, "xsd:int"))
				{	soap_flag_reg--;
					continue;
				}
			if (soap_flag_val && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedByte(soap, "val", &a->val, "xsd:unsignedByte"))
				{	soap_flag_val--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__gsm_mcu_reg_write *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__gsm_mcu_reg_write, 0, sizeof(struct ns__gsm_mcu_reg_write), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_brd > 0 || soap_flag_reg > 0 || soap_flag_val > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__gsm_mcu_reg_write(struct soap *soap, const struct ns__gsm_mcu_reg_write *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__gsm_mcu_reg_write);
	if (soap_out_ns__gsm_mcu_reg_write(soap, tag?tag:"ns:gsm-mcu-reg-write", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__gsm_mcu_reg_write * SOAP_FMAC4 soap_get_ns__gsm_mcu_reg_write(struct soap *soap, struct ns__gsm_mcu_reg_write *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__gsm_mcu_reg_write(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__gsm_mcu_reg_writeResponse(struct soap *soap, struct ns__gsm_mcu_reg_writeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__gsm_mcu_reg_writeResponse(struct soap *soap, const struct ns__gsm_mcu_reg_writeResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->result);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__gsm_mcu_reg_writeResponse(struct soap *soap, const char *tag, int id, const struct ns__gsm_mcu_reg_writeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__gsm_mcu_reg_writeResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__gsm_mcu_reg_writeResponse * SOAP_FMAC4 soap_in_ns__gsm_mcu_reg_writeResponse(struct soap *soap, const char *tag, struct ns__gsm_mcu_reg_writeResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__gsm_mcu_reg_writeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__gsm_mcu_reg_writeResponse, sizeof(struct ns__gsm_mcu_reg_writeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__gsm_mcu_reg_writeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__gsm_mcu_reg_writeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__gsm_mcu_reg_writeResponse, 0, sizeof(struct ns__gsm_mcu_reg_writeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__gsm_mcu_reg_writeResponse(struct soap *soap, const struct ns__gsm_mcu_reg_writeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__gsm_mcu_reg_writeResponse);
	if (soap_out_ns__gsm_mcu_reg_writeResponse(soap, tag?tag:"ns:gsm-mcu-reg-writeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__gsm_mcu_reg_writeResponse * SOAP_FMAC4 soap_get_ns__gsm_mcu_reg_writeResponse(struct soap *soap, struct ns__gsm_mcu_reg_writeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__gsm_mcu_reg_writeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__gsm_mcu_reg_read(struct soap *soap, struct ns__gsm_mcu_reg_read *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->brd);
	soap_default_int(soap, &a->reg);
	soap_default_int(soap, &a->num);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__gsm_mcu_reg_read(struct soap *soap, const struct ns__gsm_mcu_reg_read *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->brd, SOAP_TYPE_int);
	soap_embedded(soap, &a->reg, SOAP_TYPE_int);
	soap_embedded(soap, &a->num, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__gsm_mcu_reg_read(struct soap *soap, const char *tag, int id, const struct ns__gsm_mcu_reg_read *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__gsm_mcu_reg_read), type))
		return soap->error;
	if (soap_out_int(soap, "brd", -1, &a->brd, ""))
		return soap->error;
	if (soap_out_int(soap, "reg", -1, &a->reg, ""))
		return soap->error;
	if (soap_out_int(soap, "num", -1, &a->num, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__gsm_mcu_reg_read * SOAP_FMAC4 soap_in_ns__gsm_mcu_reg_read(struct soap *soap, const char *tag, struct ns__gsm_mcu_reg_read *a, const char *type)
{
	size_t soap_flag_brd = 1;
	size_t soap_flag_reg = 1;
	size_t soap_flag_num = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__gsm_mcu_reg_read *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__gsm_mcu_reg_read, sizeof(struct ns__gsm_mcu_reg_read), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__gsm_mcu_reg_read(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_brd && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "brd", &a->brd, "xsd:int"))
				{	soap_flag_brd--;
					continue;
				}
			if (soap_flag_reg && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "reg", &a->reg, "xsd:int"))
				{	soap_flag_reg--;
					continue;
				}
			if (soap_flag_num && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "num", &a->num, "xsd:int"))
				{	soap_flag_num--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__gsm_mcu_reg_read *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__gsm_mcu_reg_read, 0, sizeof(struct ns__gsm_mcu_reg_read), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_brd > 0 || soap_flag_reg > 0 || soap_flag_num > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__gsm_mcu_reg_read(struct soap *soap, const struct ns__gsm_mcu_reg_read *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__gsm_mcu_reg_read);
	if (soap_out_ns__gsm_mcu_reg_read(soap, tag?tag:"ns:gsm-mcu-reg-read", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__gsm_mcu_reg_read * SOAP_FMAC4 soap_get_ns__gsm_mcu_reg_read(struct soap *soap, struct ns__gsm_mcu_reg_read *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__gsm_mcu_reg_read(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__gsm_mcu_reg_readResponse(struct soap *soap, struct ns__gsm_mcu_reg_readResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__gsm_mcu_reg_readResponse(struct soap *soap, const struct ns__gsm_mcu_reg_readResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->result);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__gsm_mcu_reg_readResponse(struct soap *soap, const char *tag, int id, const struct ns__gsm_mcu_reg_readResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__gsm_mcu_reg_readResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__gsm_mcu_reg_readResponse * SOAP_FMAC4 soap_in_ns__gsm_mcu_reg_readResponse(struct soap *soap, const char *tag, struct ns__gsm_mcu_reg_readResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__gsm_mcu_reg_readResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__gsm_mcu_reg_readResponse, sizeof(struct ns__gsm_mcu_reg_readResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__gsm_mcu_reg_readResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__gsm_mcu_reg_readResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__gsm_mcu_reg_readResponse, 0, sizeof(struct ns__gsm_mcu_reg_readResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__gsm_mcu_reg_readResponse(struct soap *soap, const struct ns__gsm_mcu_reg_readResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__gsm_mcu_reg_readResponse);
	if (soap_out_ns__gsm_mcu_reg_readResponse(soap, tag?tag:"ns:gsm-mcu-reg-readResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__gsm_mcu_reg_readResponse * SOAP_FMAC4 soap_get_ns__gsm_mcu_reg_readResponse(struct soap *soap, struct ns__gsm_mcu_reg_readResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__gsm_mcu_reg_readResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__gsm_get_restore_event(struct soap *soap, struct ns__gsm_get_restore_event *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__gsm_get_restore_event(struct soap *soap, const struct ns__gsm_get_restore_event *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__gsm_get_restore_event(struct soap *soap, const char *tag, int id, const struct ns__gsm_get_restore_event *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__gsm_get_restore_event), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__gsm_get_restore_event * SOAP_FMAC4 soap_in_ns__gsm_get_restore_event(struct soap *soap, const char *tag, struct ns__gsm_get_restore_event *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__gsm_get_restore_event *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__gsm_get_restore_event, sizeof(struct ns__gsm_get_restore_event), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__gsm_get_restore_event(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__gsm_get_restore_event *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__gsm_get_restore_event, 0, sizeof(struct ns__gsm_get_restore_event), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__gsm_get_restore_event(struct soap *soap, const struct ns__gsm_get_restore_event *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__gsm_get_restore_event);
	if (soap_out_ns__gsm_get_restore_event(soap, tag?tag:"ns:gsm-get-restore-event", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__gsm_get_restore_event * SOAP_FMAC4 soap_get_ns__gsm_get_restore_event(struct soap *soap, struct ns__gsm_get_restore_event *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__gsm_get_restore_event(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__gsm_get_restore_eventResponse(struct soap *soap, struct ns__gsm_get_restore_eventResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__gsm_get_restore_eventResponse(struct soap *soap, const struct ns__gsm_get_restore_eventResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->result);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__gsm_get_restore_eventResponse(struct soap *soap, const char *tag, int id, const struct ns__gsm_get_restore_eventResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__gsm_get_restore_eventResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__gsm_get_restore_eventResponse * SOAP_FMAC4 soap_in_ns__gsm_get_restore_eventResponse(struct soap *soap, const char *tag, struct ns__gsm_get_restore_eventResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__gsm_get_restore_eventResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__gsm_get_restore_eventResponse, sizeof(struct ns__gsm_get_restore_eventResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__gsm_get_restore_eventResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__gsm_get_restore_eventResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__gsm_get_restore_eventResponse, 0, sizeof(struct ns__gsm_get_restore_eventResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__gsm_get_restore_eventResponse(struct soap *soap, const struct ns__gsm_get_restore_eventResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__gsm_get_restore_eventResponse);
	if (soap_out_ns__gsm_get_restore_eventResponse(soap, tag?tag:"ns:gsm-get-restore-eventResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__gsm_get_restore_eventResponse * SOAP_FMAC4 soap_get_ns__gsm_get_restore_eventResponse(struct soap *soap, struct ns__gsm_get_restore_eventResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__gsm_get_restore_eventResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__gsm_get_mcu_help(struct soap *soap, struct ns__gsm_get_mcu_help *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__gsm_get_mcu_help(struct soap *soap, const struct ns__gsm_get_mcu_help *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__gsm_get_mcu_help(struct soap *soap, const char *tag, int id, const struct ns__gsm_get_mcu_help *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__gsm_get_mcu_help), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__gsm_get_mcu_help * SOAP_FMAC4 soap_in_ns__gsm_get_mcu_help(struct soap *soap, const char *tag, struct ns__gsm_get_mcu_help *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__gsm_get_mcu_help *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__gsm_get_mcu_help, sizeof(struct ns__gsm_get_mcu_help), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__gsm_get_mcu_help(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__gsm_get_mcu_help *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__gsm_get_mcu_help, 0, sizeof(struct ns__gsm_get_mcu_help), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__gsm_get_mcu_help(struct soap *soap, const struct ns__gsm_get_mcu_help *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__gsm_get_mcu_help);
	if (soap_out_ns__gsm_get_mcu_help(soap, tag?tag:"ns:gsm-get-mcu-help", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__gsm_get_mcu_help * SOAP_FMAC4 soap_get_ns__gsm_get_mcu_help(struct soap *soap, struct ns__gsm_get_mcu_help *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__gsm_get_mcu_help(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__gsm_get_mcu_helpResponse(struct soap *soap, struct ns__gsm_get_mcu_helpResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__gsm_get_mcu_helpResponse(struct soap *soap, const struct ns__gsm_get_mcu_helpResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->result);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__gsm_get_mcu_helpResponse(struct soap *soap, const char *tag, int id, const struct ns__gsm_get_mcu_helpResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__gsm_get_mcu_helpResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__gsm_get_mcu_helpResponse * SOAP_FMAC4 soap_in_ns__gsm_get_mcu_helpResponse(struct soap *soap, const char *tag, struct ns__gsm_get_mcu_helpResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__gsm_get_mcu_helpResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__gsm_get_mcu_helpResponse, sizeof(struct ns__gsm_get_mcu_helpResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__gsm_get_mcu_helpResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__gsm_get_mcu_helpResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__gsm_get_mcu_helpResponse, 0, sizeof(struct ns__gsm_get_mcu_helpResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__gsm_get_mcu_helpResponse(struct soap *soap, const struct ns__gsm_get_mcu_helpResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__gsm_get_mcu_helpResponse);
	if (soap_out_ns__gsm_get_mcu_helpResponse(soap, tag?tag:"ns:gsm-get-mcu-helpResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__gsm_get_mcu_helpResponse * SOAP_FMAC4 soap_get_ns__gsm_get_mcu_helpResponse(struct soap *soap, struct ns__gsm_get_mcu_helpResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__gsm_get_mcu_helpResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__gsm_get_mcu_version(struct soap *soap, struct ns__gsm_get_mcu_version *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__gsm_get_mcu_version(struct soap *soap, const struct ns__gsm_get_mcu_version *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__gsm_get_mcu_version(struct soap *soap, const char *tag, int id, const struct ns__gsm_get_mcu_version *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__gsm_get_mcu_version), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__gsm_get_mcu_version * SOAP_FMAC4 soap_in_ns__gsm_get_mcu_version(struct soap *soap, const char *tag, struct ns__gsm_get_mcu_version *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__gsm_get_mcu_version *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__gsm_get_mcu_version, sizeof(struct ns__gsm_get_mcu_version), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__gsm_get_mcu_version(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__gsm_get_mcu_version *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__gsm_get_mcu_version, 0, sizeof(struct ns__gsm_get_mcu_version), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__gsm_get_mcu_version(struct soap *soap, const struct ns__gsm_get_mcu_version *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__gsm_get_mcu_version);
	if (soap_out_ns__gsm_get_mcu_version(soap, tag?tag:"ns:gsm-get-mcu-version", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__gsm_get_mcu_version * SOAP_FMAC4 soap_get_ns__gsm_get_mcu_version(struct soap *soap, struct ns__gsm_get_mcu_version *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__gsm_get_mcu_version(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__gsm_get_mcu_versionResponse(struct soap *soap, struct ns__gsm_get_mcu_versionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__gsm_get_mcu_versionResponse(struct soap *soap, const struct ns__gsm_get_mcu_versionResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->result);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__gsm_get_mcu_versionResponse(struct soap *soap, const char *tag, int id, const struct ns__gsm_get_mcu_versionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__gsm_get_mcu_versionResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__gsm_get_mcu_versionResponse * SOAP_FMAC4 soap_in_ns__gsm_get_mcu_versionResponse(struct soap *soap, const char *tag, struct ns__gsm_get_mcu_versionResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__gsm_get_mcu_versionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__gsm_get_mcu_versionResponse, sizeof(struct ns__gsm_get_mcu_versionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__gsm_get_mcu_versionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__gsm_get_mcu_versionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__gsm_get_mcu_versionResponse, 0, sizeof(struct ns__gsm_get_mcu_versionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__gsm_get_mcu_versionResponse(struct soap *soap, const struct ns__gsm_get_mcu_versionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__gsm_get_mcu_versionResponse);
	if (soap_out_ns__gsm_get_mcu_versionResponse(soap, tag?tag:"ns:gsm-get-mcu-versionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__gsm_get_mcu_versionResponse * SOAP_FMAC4 soap_get_ns__gsm_get_mcu_versionResponse(struct soap *soap, struct ns__gsm_get_mcu_versionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__gsm_get_mcu_versionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__gsm_set_led_control(struct soap *soap, struct ns__gsm_set_led_control *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->buf);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__gsm_set_led_control(struct soap *soap, const struct ns__gsm_set_led_control *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->buf);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__gsm_set_led_control(struct soap *soap, const char *tag, int id, const struct ns__gsm_set_led_control *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__gsm_set_led_control), type))
		return soap->error;
	if (soap_out_string(soap, "buf", -1, &a->buf, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__gsm_set_led_control * SOAP_FMAC4 soap_in_ns__gsm_set_led_control(struct soap *soap, const char *tag, struct ns__gsm_set_led_control *a, const char *type)
{
	size_t soap_flag_buf = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__gsm_set_led_control *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__gsm_set_led_control, sizeof(struct ns__gsm_set_led_control), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__gsm_set_led_control(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_buf && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "buf", &a->buf, "xsd:string"))
				{	soap_flag_buf--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__gsm_set_led_control *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__gsm_set_led_control, 0, sizeof(struct ns__gsm_set_led_control), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__gsm_set_led_control(struct soap *soap, const struct ns__gsm_set_led_control *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__gsm_set_led_control);
	if (soap_out_ns__gsm_set_led_control(soap, tag?tag:"ns:gsm-set-led-control", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__gsm_set_led_control * SOAP_FMAC4 soap_get_ns__gsm_set_led_control(struct soap *soap, struct ns__gsm_set_led_control *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__gsm_set_led_control(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__gsm_set_led_controlResponse(struct soap *soap, struct ns__gsm_set_led_controlResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__gsm_set_led_controlResponse(struct soap *soap, const struct ns__gsm_set_led_controlResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->result);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__gsm_set_led_controlResponse(struct soap *soap, const char *tag, int id, const struct ns__gsm_set_led_controlResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__gsm_set_led_controlResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__gsm_set_led_controlResponse * SOAP_FMAC4 soap_in_ns__gsm_set_led_controlResponse(struct soap *soap, const char *tag, struct ns__gsm_set_led_controlResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__gsm_set_led_controlResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__gsm_set_led_controlResponse, sizeof(struct ns__gsm_set_led_controlResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__gsm_set_led_controlResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__gsm_set_led_controlResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__gsm_set_led_controlResponse, 0, sizeof(struct ns__gsm_set_led_controlResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__gsm_set_led_controlResponse(struct soap *soap, const struct ns__gsm_set_led_controlResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__gsm_set_led_controlResponse);
	if (soap_out_ns__gsm_set_led_controlResponse(soap, tag?tag:"ns:gsm-set-led-controlResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__gsm_set_led_controlResponse * SOAP_FMAC4 soap_get_ns__gsm_set_led_controlResponse(struct soap *soap, struct ns__gsm_set_led_controlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__gsm_set_led_controlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__gsm_get_gsmboard_insert_status(struct soap *soap, struct ns__gsm_get_gsmboard_insert_status *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->chn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__gsm_get_gsmboard_insert_status(struct soap *soap, const struct ns__gsm_get_gsmboard_insert_status *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->chn, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__gsm_get_gsmboard_insert_status(struct soap *soap, const char *tag, int id, const struct ns__gsm_get_gsmboard_insert_status *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__gsm_get_gsmboard_insert_status), type))
		return soap->error;
	if (soap_out_int(soap, "chn", -1, &a->chn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__gsm_get_gsmboard_insert_status * SOAP_FMAC4 soap_in_ns__gsm_get_gsmboard_insert_status(struct soap *soap, const char *tag, struct ns__gsm_get_gsmboard_insert_status *a, const char *type)
{
	size_t soap_flag_chn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__gsm_get_gsmboard_insert_status *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__gsm_get_gsmboard_insert_status, sizeof(struct ns__gsm_get_gsmboard_insert_status), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__gsm_get_gsmboard_insert_status(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_chn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "chn", &a->chn, "xsd:int"))
				{	soap_flag_chn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__gsm_get_gsmboard_insert_status *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__gsm_get_gsmboard_insert_status, 0, sizeof(struct ns__gsm_get_gsmboard_insert_status), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_chn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__gsm_get_gsmboard_insert_status(struct soap *soap, const struct ns__gsm_get_gsmboard_insert_status *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__gsm_get_gsmboard_insert_status);
	if (soap_out_ns__gsm_get_gsmboard_insert_status(soap, tag?tag:"ns:gsm-get-gsmboard-insert-status", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__gsm_get_gsmboard_insert_status * SOAP_FMAC4 soap_get_ns__gsm_get_gsmboard_insert_status(struct soap *soap, struct ns__gsm_get_gsmboard_insert_status *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__gsm_get_gsmboard_insert_status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__gsm_get_simcard_insert_status(struct soap *soap, struct ns__gsm_get_simcard_insert_status *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->chn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__gsm_get_simcard_insert_status(struct soap *soap, const struct ns__gsm_get_simcard_insert_status *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->chn, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__gsm_get_simcard_insert_status(struct soap *soap, const char *tag, int id, const struct ns__gsm_get_simcard_insert_status *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__gsm_get_simcard_insert_status), type))
		return soap->error;
	if (soap_out_int(soap, "chn", -1, &a->chn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__gsm_get_simcard_insert_status * SOAP_FMAC4 soap_in_ns__gsm_get_simcard_insert_status(struct soap *soap, const char *tag, struct ns__gsm_get_simcard_insert_status *a, const char *type)
{
	size_t soap_flag_chn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__gsm_get_simcard_insert_status *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__gsm_get_simcard_insert_status, sizeof(struct ns__gsm_get_simcard_insert_status), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__gsm_get_simcard_insert_status(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_chn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "chn", &a->chn, "xsd:int"))
				{	soap_flag_chn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__gsm_get_simcard_insert_status *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__gsm_get_simcard_insert_status, 0, sizeof(struct ns__gsm_get_simcard_insert_status), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_chn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__gsm_get_simcard_insert_status(struct soap *soap, const struct ns__gsm_get_simcard_insert_status *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__gsm_get_simcard_insert_status);
	if (soap_out_ns__gsm_get_simcard_insert_status(soap, tag?tag:"ns:gsm-get-simcard-insert-status", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__gsm_get_simcard_insert_status * SOAP_FMAC4 soap_get_ns__gsm_get_simcard_insert_status(struct soap *soap, struct ns__gsm_get_simcard_insert_status *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__gsm_get_simcard_insert_status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__gsm_get_module_status(struct soap *soap, struct ns__gsm_get_module_status *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->chn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__gsm_get_module_status(struct soap *soap, const struct ns__gsm_get_module_status *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->chn, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__gsm_get_module_status(struct soap *soap, const char *tag, int id, const struct ns__gsm_get_module_status *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__gsm_get_module_status), type))
		return soap->error;
	if (soap_out_int(soap, "chn", -1, &a->chn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__gsm_get_module_status * SOAP_FMAC4 soap_in_ns__gsm_get_module_status(struct soap *soap, const char *tag, struct ns__gsm_get_module_status *a, const char *type)
{
	size_t soap_flag_chn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__gsm_get_module_status *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__gsm_get_module_status, sizeof(struct ns__gsm_get_module_status), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__gsm_get_module_status(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_chn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "chn", &a->chn, "xsd:int"))
				{	soap_flag_chn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__gsm_get_module_status *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__gsm_get_module_status, 0, sizeof(struct ns__gsm_get_module_status), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_chn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__gsm_get_module_status(struct soap *soap, const struct ns__gsm_get_module_status *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__gsm_get_module_status);
	if (soap_out_ns__gsm_get_module_status(soap, tag?tag:"ns:gsm-get-module-status", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__gsm_get_module_status * SOAP_FMAC4 soap_get_ns__gsm_get_module_status(struct soap *soap, struct ns__gsm_get_module_status *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__gsm_get_module_status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__gsm_module_off(struct soap *soap, struct ns__gsm_module_off *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->chn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__gsm_module_off(struct soap *soap, const struct ns__gsm_module_off *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->chn, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__gsm_module_off(struct soap *soap, const char *tag, int id, const struct ns__gsm_module_off *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__gsm_module_off), type))
		return soap->error;
	if (soap_out_int(soap, "chn", -1, &a->chn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__gsm_module_off * SOAP_FMAC4 soap_in_ns__gsm_module_off(struct soap *soap, const char *tag, struct ns__gsm_module_off *a, const char *type)
{
	size_t soap_flag_chn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__gsm_module_off *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__gsm_module_off, sizeof(struct ns__gsm_module_off), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__gsm_module_off(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_chn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "chn", &a->chn, "xsd:int"))
				{	soap_flag_chn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__gsm_module_off *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__gsm_module_off, 0, sizeof(struct ns__gsm_module_off), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_chn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__gsm_module_off(struct soap *soap, const struct ns__gsm_module_off *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__gsm_module_off);
	if (soap_out_ns__gsm_module_off(soap, tag?tag:"ns:gsm-module-off", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__gsm_module_off * SOAP_FMAC4 soap_get_ns__gsm_module_off(struct soap *soap, struct ns__gsm_module_off *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__gsm_module_off(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__gsm_module_offResponse(struct soap *soap, struct ns__gsm_module_offResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__gsm_module_offResponse(struct soap *soap, const struct ns__gsm_module_offResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->result);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__gsm_module_offResponse(struct soap *soap, const char *tag, int id, const struct ns__gsm_module_offResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__gsm_module_offResponse), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__gsm_module_offResponse * SOAP_FMAC4 soap_in_ns__gsm_module_offResponse(struct soap *soap, const char *tag, struct ns__gsm_module_offResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__gsm_module_offResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__gsm_module_offResponse, sizeof(struct ns__gsm_module_offResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__gsm_module_offResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__gsm_module_offResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__gsm_module_offResponse, 0, sizeof(struct ns__gsm_module_offResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__gsm_module_offResponse(struct soap *soap, const struct ns__gsm_module_offResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__gsm_module_offResponse);
	if (soap_out_ns__gsm_module_offResponse(soap, tag?tag:"ns:gsm-module-offResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__gsm_module_offResponse * SOAP_FMAC4 soap_get_ns__gsm_module_offResponse(struct soap *soap, struct ns__gsm_module_offResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__gsm_module_offResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__gsm_module_on(struct soap *soap, struct ns__gsm_module_on *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->chn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__gsm_module_on(struct soap *soap, const struct ns__gsm_module_on *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->chn, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__gsm_module_on(struct soap *soap, const char *tag, int id, const struct ns__gsm_module_on *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__gsm_module_on), type))
		return soap->error;
	if (soap_out_int(soap, "chn", -1, &a->chn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__gsm_module_on * SOAP_FMAC4 soap_in_ns__gsm_module_on(struct soap *soap, const char *tag, struct ns__gsm_module_on *a, const char *type)
{
	size_t soap_flag_chn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__gsm_module_on *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__gsm_module_on, sizeof(struct ns__gsm_module_on), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__gsm_module_on(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_chn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "chn", &a->chn, "xsd:int"))
				{	soap_flag_chn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__gsm_module_on *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__gsm_module_on, 0, sizeof(struct ns__gsm_module_on), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_chn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__gsm_module_on(struct soap *soap, const struct ns__gsm_module_on *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__gsm_module_on);
	if (soap_out_ns__gsm_module_on(soap, tag?tag:"ns:gsm-module-on", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__gsm_module_on * SOAP_FMAC4 soap_get_ns__gsm_module_on(struct soap *soap, struct ns__gsm_module_on *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__gsm_module_on(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__gsm_module_onResponse(struct soap *soap, struct ns__gsm_module_onResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__gsm_module_onResponse(struct soap *soap, const struct ns__gsm_module_onResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->result);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__gsm_module_onResponse(struct soap *soap, const char *tag, int id, const struct ns__gsm_module_onResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__gsm_module_onResponse), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__gsm_module_onResponse * SOAP_FMAC4 soap_in_ns__gsm_module_onResponse(struct soap *soap, const char *tag, struct ns__gsm_module_onResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__gsm_module_onResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__gsm_module_onResponse, sizeof(struct ns__gsm_module_onResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__gsm_module_onResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__gsm_module_onResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__gsm_module_onResponse, 0, sizeof(struct ns__gsm_module_onResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__gsm_module_onResponse(struct soap *soap, const struct ns__gsm_module_onResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__gsm_module_onResponse);
	if (soap_out_ns__gsm_module_onResponse(soap, tag?tag:"ns:gsm-module-onResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__gsm_module_onResponse * SOAP_FMAC4 soap_get_ns__gsm_module_onResponse(struct soap *soap, struct ns__gsm_module_onResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__gsm_module_onResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__gsm_module_emerg_off(struct soap *soap, struct ns__gsm_module_emerg_off *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->chn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__gsm_module_emerg_off(struct soap *soap, const struct ns__gsm_module_emerg_off *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->chn, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__gsm_module_emerg_off(struct soap *soap, const char *tag, int id, const struct ns__gsm_module_emerg_off *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__gsm_module_emerg_off), type))
		return soap->error;
	if (soap_out_int(soap, "chn", -1, &a->chn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__gsm_module_emerg_off * SOAP_FMAC4 soap_in_ns__gsm_module_emerg_off(struct soap *soap, const char *tag, struct ns__gsm_module_emerg_off *a, const char *type)
{
	size_t soap_flag_chn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__gsm_module_emerg_off *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__gsm_module_emerg_off, sizeof(struct ns__gsm_module_emerg_off), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__gsm_module_emerg_off(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_chn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "chn", &a->chn, "xsd:int"))
				{	soap_flag_chn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__gsm_module_emerg_off *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__gsm_module_emerg_off, 0, sizeof(struct ns__gsm_module_emerg_off), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_chn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__gsm_module_emerg_off(struct soap *soap, const struct ns__gsm_module_emerg_off *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__gsm_module_emerg_off);
	if (soap_out_ns__gsm_module_emerg_off(soap, tag?tag:"ns:gsm-module-emerg-off", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__gsm_module_emerg_off * SOAP_FMAC4 soap_get_ns__gsm_module_emerg_off(struct soap *soap, struct ns__gsm_module_emerg_off *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__gsm_module_emerg_off(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__gsm_module_emerg_offResponse(struct soap *soap, struct ns__gsm_module_emerg_offResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__gsm_module_emerg_offResponse(struct soap *soap, const struct ns__gsm_module_emerg_offResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->result);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__gsm_module_emerg_offResponse(struct soap *soap, const char *tag, int id, const struct ns__gsm_module_emerg_offResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__gsm_module_emerg_offResponse), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__gsm_module_emerg_offResponse * SOAP_FMAC4 soap_in_ns__gsm_module_emerg_offResponse(struct soap *soap, const char *tag, struct ns__gsm_module_emerg_offResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__gsm_module_emerg_offResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__gsm_module_emerg_offResponse, sizeof(struct ns__gsm_module_emerg_offResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__gsm_module_emerg_offResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__gsm_module_emerg_offResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__gsm_module_emerg_offResponse, 0, sizeof(struct ns__gsm_module_emerg_offResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__gsm_module_emerg_offResponse(struct soap *soap, const struct ns__gsm_module_emerg_offResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__gsm_module_emerg_offResponse);
	if (soap_out_ns__gsm_module_emerg_offResponse(soap, tag?tag:"ns:gsm-module-emerg-offResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__gsm_module_emerg_offResponse * SOAP_FMAC4 soap_get_ns__gsm_module_emerg_offResponse(struct soap *soap, struct ns__gsm_module_emerg_offResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__gsm_module_emerg_offResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__gsm_get_module_power_status(struct soap *soap, struct ns__gsm_get_module_power_status *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->chn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__gsm_get_module_power_status(struct soap *soap, const struct ns__gsm_get_module_power_status *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->chn, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__gsm_get_module_power_status(struct soap *soap, const char *tag, int id, const struct ns__gsm_get_module_power_status *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__gsm_get_module_power_status), type))
		return soap->error;
	if (soap_out_int(soap, "chn", -1, &a->chn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__gsm_get_module_power_status * SOAP_FMAC4 soap_in_ns__gsm_get_module_power_status(struct soap *soap, const char *tag, struct ns__gsm_get_module_power_status *a, const char *type)
{
	size_t soap_flag_chn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__gsm_get_module_power_status *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__gsm_get_module_power_status, sizeof(struct ns__gsm_get_module_power_status), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__gsm_get_module_power_status(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_chn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "chn", &a->chn, "xsd:int"))
				{	soap_flag_chn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__gsm_get_module_power_status *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__gsm_get_module_power_status, 0, sizeof(struct ns__gsm_get_module_power_status), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_chn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__gsm_get_module_power_status(struct soap *soap, const struct ns__gsm_get_module_power_status *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__gsm_get_module_power_status);
	if (soap_out_ns__gsm_get_module_power_status(soap, tag?tag:"ns:gsm-get-module-power-status", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__gsm_get_module_power_status * SOAP_FMAC4 soap_get_ns__gsm_get_module_power_status(struct soap *soap, struct ns__gsm_get_module_power_status *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__gsm_get_module_power_status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__gsm_module_power_off(struct soap *soap, struct ns__gsm_module_power_off *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->chn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__gsm_module_power_off(struct soap *soap, const struct ns__gsm_module_power_off *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->chn, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__gsm_module_power_off(struct soap *soap, const char *tag, int id, const struct ns__gsm_module_power_off *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__gsm_module_power_off), type))
		return soap->error;
	if (soap_out_int(soap, "chn", -1, &a->chn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__gsm_module_power_off * SOAP_FMAC4 soap_in_ns__gsm_module_power_off(struct soap *soap, const char *tag, struct ns__gsm_module_power_off *a, const char *type)
{
	size_t soap_flag_chn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__gsm_module_power_off *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__gsm_module_power_off, sizeof(struct ns__gsm_module_power_off), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__gsm_module_power_off(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_chn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "chn", &a->chn, "xsd:int"))
				{	soap_flag_chn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__gsm_module_power_off *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__gsm_module_power_off, 0, sizeof(struct ns__gsm_module_power_off), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_chn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__gsm_module_power_off(struct soap *soap, const struct ns__gsm_module_power_off *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__gsm_module_power_off);
	if (soap_out_ns__gsm_module_power_off(soap, tag?tag:"ns:gsm-module-power-off", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__gsm_module_power_off * SOAP_FMAC4 soap_get_ns__gsm_module_power_off(struct soap *soap, struct ns__gsm_module_power_off *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__gsm_module_power_off(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__gsm_module_power_offResponse(struct soap *soap, struct ns__gsm_module_power_offResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__gsm_module_power_offResponse(struct soap *soap, const struct ns__gsm_module_power_offResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->result);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__gsm_module_power_offResponse(struct soap *soap, const char *tag, int id, const struct ns__gsm_module_power_offResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__gsm_module_power_offResponse), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__gsm_module_power_offResponse * SOAP_FMAC4 soap_in_ns__gsm_module_power_offResponse(struct soap *soap, const char *tag, struct ns__gsm_module_power_offResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__gsm_module_power_offResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__gsm_module_power_offResponse, sizeof(struct ns__gsm_module_power_offResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__gsm_module_power_offResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__gsm_module_power_offResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__gsm_module_power_offResponse, 0, sizeof(struct ns__gsm_module_power_offResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__gsm_module_power_offResponse(struct soap *soap, const struct ns__gsm_module_power_offResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__gsm_module_power_offResponse);
	if (soap_out_ns__gsm_module_power_offResponse(soap, tag?tag:"ns:gsm-module-power-offResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__gsm_module_power_offResponse * SOAP_FMAC4 soap_get_ns__gsm_module_power_offResponse(struct soap *soap, struct ns__gsm_module_power_offResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__gsm_module_power_offResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__gsm_module_power_on(struct soap *soap, struct ns__gsm_module_power_on *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->chn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__gsm_module_power_on(struct soap *soap, const struct ns__gsm_module_power_on *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->chn, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__gsm_module_power_on(struct soap *soap, const char *tag, int id, const struct ns__gsm_module_power_on *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__gsm_module_power_on), type))
		return soap->error;
	if (soap_out_int(soap, "chn", -1, &a->chn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__gsm_module_power_on * SOAP_FMAC4 soap_in_ns__gsm_module_power_on(struct soap *soap, const char *tag, struct ns__gsm_module_power_on *a, const char *type)
{
	size_t soap_flag_chn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__gsm_module_power_on *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__gsm_module_power_on, sizeof(struct ns__gsm_module_power_on), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__gsm_module_power_on(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_chn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "chn", &a->chn, "xsd:int"))
				{	soap_flag_chn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__gsm_module_power_on *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__gsm_module_power_on, 0, sizeof(struct ns__gsm_module_power_on), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_chn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__gsm_module_power_on(struct soap *soap, const struct ns__gsm_module_power_on *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__gsm_module_power_on);
	if (soap_out_ns__gsm_module_power_on(soap, tag?tag:"ns:gsm-module-power-on", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__gsm_module_power_on * SOAP_FMAC4 soap_get_ns__gsm_module_power_on(struct soap *soap, struct ns__gsm_module_power_on *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__gsm_module_power_on(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__gsm_module_power_onResponse(struct soap *soap, struct ns__gsm_module_power_onResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__gsm_module_power_onResponse(struct soap *soap, const struct ns__gsm_module_power_onResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->result);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__gsm_module_power_onResponse(struct soap *soap, const char *tag, int id, const struct ns__gsm_module_power_onResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__gsm_module_power_onResponse), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__gsm_module_power_onResponse * SOAP_FMAC4 soap_in_ns__gsm_module_power_onResponse(struct soap *soap, const char *tag, struct ns__gsm_module_power_onResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__gsm_module_power_onResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__gsm_module_power_onResponse, sizeof(struct ns__gsm_module_power_onResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__gsm_module_power_onResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__gsm_module_power_onResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__gsm_module_power_onResponse, 0, sizeof(struct ns__gsm_module_power_onResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__gsm_module_power_onResponse(struct soap *soap, const struct ns__gsm_module_power_onResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__gsm_module_power_onResponse);
	if (soap_out_ns__gsm_module_power_onResponse(soap, tag?tag:"ns:gsm-module-power-onResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__gsm_module_power_onResponse * SOAP_FMAC4 soap_get_ns__gsm_module_power_onResponse(struct soap *soap, struct ns__gsm_module_power_onResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__gsm_module_power_onResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__gsm_get_simcard_status(struct soap *soap, struct ns__gsm_get_simcard_status *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->chn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__gsm_get_simcard_status(struct soap *soap, const struct ns__gsm_get_simcard_status *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->chn, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__gsm_get_simcard_status(struct soap *soap, const char *tag, int id, const struct ns__gsm_get_simcard_status *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__gsm_get_simcard_status), type))
		return soap->error;
	if (soap_out_int(soap, "chn", -1, &a->chn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__gsm_get_simcard_status * SOAP_FMAC4 soap_in_ns__gsm_get_simcard_status(struct soap *soap, const char *tag, struct ns__gsm_get_simcard_status *a, const char *type)
{
	size_t soap_flag_chn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__gsm_get_simcard_status *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__gsm_get_simcard_status, sizeof(struct ns__gsm_get_simcard_status), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__gsm_get_simcard_status(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_chn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "chn", &a->chn, "xsd:int"))
				{	soap_flag_chn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__gsm_get_simcard_status *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__gsm_get_simcard_status, 0, sizeof(struct ns__gsm_get_simcard_status), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_chn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__gsm_get_simcard_status(struct soap *soap, const struct ns__gsm_get_simcard_status *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__gsm_get_simcard_status);
	if (soap_out_ns__gsm_get_simcard_status(soap, tag?tag:"ns:gsm-get-simcard-status", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__gsm_get_simcard_status * SOAP_FMAC4 soap_get_ns__gsm_get_simcard_status(struct soap *soap, struct ns__gsm_get_simcard_status *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__gsm_get_simcard_status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__gsm_simcard_disable(struct soap *soap, struct ns__gsm_simcard_disable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->chn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__gsm_simcard_disable(struct soap *soap, const struct ns__gsm_simcard_disable *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->chn, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__gsm_simcard_disable(struct soap *soap, const char *tag, int id, const struct ns__gsm_simcard_disable *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__gsm_simcard_disable), type))
		return soap->error;
	if (soap_out_int(soap, "chn", -1, &a->chn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__gsm_simcard_disable * SOAP_FMAC4 soap_in_ns__gsm_simcard_disable(struct soap *soap, const char *tag, struct ns__gsm_simcard_disable *a, const char *type)
{
	size_t soap_flag_chn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__gsm_simcard_disable *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__gsm_simcard_disable, sizeof(struct ns__gsm_simcard_disable), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__gsm_simcard_disable(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_chn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "chn", &a->chn, "xsd:int"))
				{	soap_flag_chn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__gsm_simcard_disable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__gsm_simcard_disable, 0, sizeof(struct ns__gsm_simcard_disable), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_chn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__gsm_simcard_disable(struct soap *soap, const struct ns__gsm_simcard_disable *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__gsm_simcard_disable);
	if (soap_out_ns__gsm_simcard_disable(soap, tag?tag:"ns:gsm-simcard-disable", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__gsm_simcard_disable * SOAP_FMAC4 soap_get_ns__gsm_simcard_disable(struct soap *soap, struct ns__gsm_simcard_disable *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__gsm_simcard_disable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__gsm_simcard_disableResponse(struct soap *soap, struct ns__gsm_simcard_disableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__gsm_simcard_disableResponse(struct soap *soap, const struct ns__gsm_simcard_disableResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->result);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__gsm_simcard_disableResponse(struct soap *soap, const char *tag, int id, const struct ns__gsm_simcard_disableResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__gsm_simcard_disableResponse), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__gsm_simcard_disableResponse * SOAP_FMAC4 soap_in_ns__gsm_simcard_disableResponse(struct soap *soap, const char *tag, struct ns__gsm_simcard_disableResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__gsm_simcard_disableResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__gsm_simcard_disableResponse, sizeof(struct ns__gsm_simcard_disableResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__gsm_simcard_disableResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__gsm_simcard_disableResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__gsm_simcard_disableResponse, 0, sizeof(struct ns__gsm_simcard_disableResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__gsm_simcard_disableResponse(struct soap *soap, const struct ns__gsm_simcard_disableResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__gsm_simcard_disableResponse);
	if (soap_out_ns__gsm_simcard_disableResponse(soap, tag?tag:"ns:gsm-simcard-disableResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__gsm_simcard_disableResponse * SOAP_FMAC4 soap_get_ns__gsm_simcard_disableResponse(struct soap *soap, struct ns__gsm_simcard_disableResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__gsm_simcard_disableResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__gsm_simcard_enable(struct soap *soap, struct ns__gsm_simcard_enable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->chn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__gsm_simcard_enable(struct soap *soap, const struct ns__gsm_simcard_enable *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->chn, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__gsm_simcard_enable(struct soap *soap, const char *tag, int id, const struct ns__gsm_simcard_enable *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__gsm_simcard_enable), type))
		return soap->error;
	if (soap_out_int(soap, "chn", -1, &a->chn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__gsm_simcard_enable * SOAP_FMAC4 soap_in_ns__gsm_simcard_enable(struct soap *soap, const char *tag, struct ns__gsm_simcard_enable *a, const char *type)
{
	size_t soap_flag_chn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__gsm_simcard_enable *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__gsm_simcard_enable, sizeof(struct ns__gsm_simcard_enable), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__gsm_simcard_enable(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_chn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "chn", &a->chn, "xsd:int"))
				{	soap_flag_chn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__gsm_simcard_enable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__gsm_simcard_enable, 0, sizeof(struct ns__gsm_simcard_enable), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_chn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__gsm_simcard_enable(struct soap *soap, const struct ns__gsm_simcard_enable *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__gsm_simcard_enable);
	if (soap_out_ns__gsm_simcard_enable(soap, tag?tag:"ns:gsm-simcard-enable", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__gsm_simcard_enable * SOAP_FMAC4 soap_get_ns__gsm_simcard_enable(struct soap *soap, struct ns__gsm_simcard_enable *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__gsm_simcard_enable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__gsm_simcard_enableResponse(struct soap *soap, struct ns__gsm_simcard_enableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__gsm_simcard_enableResponse(struct soap *soap, const struct ns__gsm_simcard_enableResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->result);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__gsm_simcard_enableResponse(struct soap *soap, const char *tag, int id, const struct ns__gsm_simcard_enableResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__gsm_simcard_enableResponse), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__gsm_simcard_enableResponse * SOAP_FMAC4 soap_in_ns__gsm_simcard_enableResponse(struct soap *soap, const char *tag, struct ns__gsm_simcard_enableResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__gsm_simcard_enableResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__gsm_simcard_enableResponse, sizeof(struct ns__gsm_simcard_enableResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__gsm_simcard_enableResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__gsm_simcard_enableResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__gsm_simcard_enableResponse, 0, sizeof(struct ns__gsm_simcard_enableResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__gsm_simcard_enableResponse(struct soap *soap, const struct ns__gsm_simcard_enableResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__gsm_simcard_enableResponse);
	if (soap_out_ns__gsm_simcard_enableResponse(soap, tag?tag:"ns:gsm-simcard-enableResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__gsm_simcard_enableResponse * SOAP_FMAC4 soap_get_ns__gsm_simcard_enableResponse(struct soap *soap, struct ns__gsm_simcard_enableResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__gsm_simcard_enableResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__gsm_mcu_rsp_t(struct soap *soap, struct ns__gsm_mcu_rsp_t *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
	soap_default_int(soap, &a->cnt);
	soap_default_string(soap, &a->value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__gsm_mcu_rsp_t(struct soap *soap, const struct ns__gsm_mcu_rsp_t *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
	soap_embedded(soap, &a->cnt, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->value);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__gsm_mcu_rsp_t(struct soap *soap, const char *tag, int id, const struct ns__gsm_mcu_rsp_t *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__gsm_mcu_rsp_t), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_int(soap, "cnt", -1, &a->cnt, ""))
		return soap->error;
	if (soap_out_string(soap, "value", -1, &a->value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__gsm_mcu_rsp_t * SOAP_FMAC4 soap_in_ns__gsm_mcu_rsp_t(struct soap *soap, const char *tag, struct ns__gsm_mcu_rsp_t *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_cnt = 1;
	size_t soap_flag_value = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__gsm_mcu_rsp_t *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__gsm_mcu_rsp_t, sizeof(struct ns__gsm_mcu_rsp_t), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__gsm_mcu_rsp_t(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_cnt && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "cnt", &a->cnt, "xsd:int"))
				{	soap_flag_cnt--;
					continue;
				}
			if (soap_flag_value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "value", &a->value, "xsd:string"))
				{	soap_flag_value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__gsm_mcu_rsp_t *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__gsm_mcu_rsp_t, 0, sizeof(struct ns__gsm_mcu_rsp_t), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0 || soap_flag_cnt > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__gsm_mcu_rsp_t(struct soap *soap, const struct ns__gsm_mcu_rsp_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__gsm_mcu_rsp_t);
	if (soap_out_ns__gsm_mcu_rsp_t(soap, tag?tag:"ns:gsm-mcu-rsp-t", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__gsm_mcu_rsp_t * SOAP_FMAC4 soap_get_ns__gsm_mcu_rsp_t(struct soap *soap, struct ns__gsm_mcu_rsp_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__gsm_mcu_rsp_t(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
	if (soap_out_PointerTostring(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__gsm_mcu_rsp_t(struct soap *soap, struct ns__gsm_mcu_rsp_t *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__gsm_mcu_rsp_t))
		soap_serialize_ns__gsm_mcu_rsp_t(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__gsm_mcu_rsp_t(struct soap *soap, const char *tag, int id, struct ns__gsm_mcu_rsp_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__gsm_mcu_rsp_t);
	if (id < 0)
		return soap->error;
	return soap_out_ns__gsm_mcu_rsp_t(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__gsm_mcu_rsp_t ** SOAP_FMAC4 soap_in_PointerTons__gsm_mcu_rsp_t(struct soap *soap, const char *tag, struct ns__gsm_mcu_rsp_t **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__gsm_mcu_rsp_t **)soap_malloc(soap, sizeof(struct ns__gsm_mcu_rsp_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns__gsm_mcu_rsp_t(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__gsm_mcu_rsp_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__gsm_mcu_rsp_t, sizeof(struct ns__gsm_mcu_rsp_t), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__gsm_mcu_rsp_t(struct soap *soap, struct ns__gsm_mcu_rsp_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons__gsm_mcu_rsp_t);
	if (soap_out_PointerTons__gsm_mcu_rsp_t(soap, tag?tag:"ns:gsm-mcu-rsp-t", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__gsm_mcu_rsp_t ** SOAP_FMAC4 soap_get_PointerTons__gsm_mcu_rsp_t(struct soap *soap, struct ns__gsm_mcu_rsp_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__gsm_mcu_rsp_t(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.c */
